{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphThrottleBlock.ts"],
  "sourcesContent": ["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\n/**\r\n * A block that throttles the execution of its output flow.\r\n */\r\nexport class FlowGraphThrottleBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * Input connection: The duration of the throttle, in seconds.\r\n     */\r\n    public readonly duration: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: Resets the throttle.\r\n     */\r\n    public readonly reset: FlowGraphSignalConnection;\r\n    /**\r\n     * Output connection: The time remaining before the throttle is triggering again, in seconds.\r\n     */\r\n    public readonly lastRemainingTime: FlowGraphDataConnection<number>;\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.reset = this._registerSignalInput(\"reset\");\r\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\r\n        this.lastRemainingTime = this.registerDataOutput(\"lastRemainingTime\", RichTypeNumber, NaN);\r\n    }\r\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\r\n        if (callingSignal === this.reset) {\r\n            this.lastRemainingTime.setValue(NaN, context);\r\n            context._setExecutionVariable(this, \"lastRemainingTime\", NaN);\r\n            context._setExecutionVariable(this, \"timestamp\", 0);\r\n            return;\r\n        }\r\n        // in seconds\r\n        const durationValue = this.duration.getValue(context);\r\n        if (durationValue <= 0 || isNaN(durationValue) || !isFinite(durationValue)) {\r\n            return this._reportError(context, \"Invalid duration in Throttle block\");\r\n        }\r\n        const lastRemainingTime = context._getExecutionVariable(this, \"lastRemainingTime\", NaN);\r\n        // Using Date.now() to get ms since epoch. not using performance.now() because its precision is not needed here\r\n        const currentTime = Date.now();\r\n        if (isNaN(lastRemainingTime)) {\r\n            this.lastRemainingTime.setValue(0, context);\r\n            context._setExecutionVariable(this, \"lastRemainingTime\", 0);\r\n            context._setExecutionVariable(this, \"timestamp\", currentTime);\r\n            // according to glTF interactivity specs\r\n            return this.out._activateSignal(context);\r\n        } else {\r\n            const elapsedTime = currentTime - context._getExecutionVariable(this, \"timestamp\", 0);\r\n            // duration is in seconds, so we need to multiply by 1000\r\n            const durationInMs = durationValue * 1000;\r\n            if (durationInMs <= elapsedTime) {\r\n                this.lastRemainingTime.setValue(0, context);\r\n                context._setExecutionVariable(this, \"lastRemainingTime\", 0);\r\n                context._setExecutionVariable(this, \"timestamp\", currentTime);\r\n                return this.out._activateSignal(context);\r\n            } else {\r\n                const remainingTime = durationInMs - elapsedTime;\r\n                // output is in seconds\r\n                this.lastRemainingTime.setValue(remainingTime / 1000, context);\r\n                context._setExecutionVariable(this, \"lastRemainingTime\", remainingTime);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.Throttle;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.Throttle, FlowGraphThrottleBlock);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAEA,IASa;AATb;;;AAEA;AAEA;AAKM,IAAO,yBAAP,cAAsC,qCAAoC;MAc5E,YAAY,QAAqC;AAC7C,cAAM,MAAM;AACZ,aAAK,QAAQ,KAAK,qBAAqB,OAAO;AAC9C,aAAK,WAAW,KAAK,kBAAkB,YAAY,cAAc;AACjE,aAAK,oBAAoB,KAAK,mBAAmB,qBAAqB,gBAAgB,GAAG;MAC7F;MACO,SAAS,SAA2B,eAAwC;AAC/E,YAAI,kBAAkB,KAAK,OAAO;AAC9B,eAAK,kBAAkB,SAAS,KAAK,OAAO;AAC5C,kBAAQ,sBAAsB,MAAM,qBAAqB,GAAG;AAC5D,kBAAQ,sBAAsB,MAAM,aAAa,CAAC;AAClD;QACJ;AAEA,cAAM,gBAAgB,KAAK,SAAS,SAAS,OAAO;AACpD,YAAI,iBAAiB,KAAK,MAAM,aAAa,KAAK,CAAC,SAAS,aAAa,GAAG;AACxE,iBAAO,KAAK,aAAa,SAAS,oCAAoC;QAC1E;AACA,cAAM,oBAAoB,QAAQ,sBAAsB,MAAM,qBAAqB,GAAG;AAEtF,cAAM,cAAc,KAAK,IAAG;AAC5B,YAAI,MAAM,iBAAiB,GAAG;AAC1B,eAAK,kBAAkB,SAAS,GAAG,OAAO;AAC1C,kBAAQ,sBAAsB,MAAM,qBAAqB,CAAC;AAC1D,kBAAQ,sBAAsB,MAAM,aAAa,WAAW;AAE5D,iBAAO,KAAK,IAAI,gBAAgB,OAAO;QAC3C,OAAO;AACH,gBAAM,cAAc,cAAc,QAAQ,sBAAsB,MAAM,aAAa,CAAC;AAEpF,gBAAM,eAAe,gBAAgB;AACrC,cAAI,gBAAgB,aAAa;AAC7B,iBAAK,kBAAkB,SAAS,GAAG,OAAO;AAC1C,oBAAQ,sBAAsB,MAAM,qBAAqB,CAAC;AAC1D,oBAAQ,sBAAsB,MAAM,aAAa,WAAW;AAC5D,mBAAO,KAAK,IAAI,gBAAgB,OAAO;UAC3C,OAAO;AACH,kBAAM,gBAAgB,eAAe;AAErC,iBAAK,kBAAkB,SAAS,gBAAgB,KAAM,OAAO;AAC7D,oBAAQ,sBAAsB,MAAM,qBAAqB,aAAa;UAC1E;QACJ;MACJ;;;;MAIgB,eAAY;AACxB,eAAA;MACJ;;AAEJ,kBAAa,0BAA+B,sBAAsB;;;",
  "names": []
}
