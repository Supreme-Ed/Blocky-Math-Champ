{
  "version": 3,
  "sources": ["../../../dev/core/src/Cameras/cameraInputsManager.ts"],
  "sourcesContent": ["import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA,IAUW,kBAwDE;AAlEb;;;AACA;AAEA;AAOO,IAAI,mBAAmB,CAAA;AAwDxB,IAAO,sBAAP,MAA0B;;;;;MAgC5B,YAAY,QAAe;AAtBpB,aAAA,oBAA6B;AAuBhC,aAAK,WAAW,CAAA;AAChB,aAAK,SAAS;AACd,aAAK,cAAc,MAAK;QAAE;MAC9B;;;;;;MAOO,IAAI,OAA4B;AACnC,cAAM,OAAO,MAAM,cAAa;AAChC,YAAI,KAAK,SAAS,IAAI,GAAG;AACrB,iBAAO,KAAK,0BAA0B,OAAO,2BAA2B;AACxE;QACJ;AAEA,aAAK,SAAS,IAAI,IAAI;AAEtB,cAAM,SAAS,KAAK;AAIpB,YAAI,MAAM,aAAa;AACnB,eAAK,cAAc,KAAK,gBAAgB,MAAM,YAAY,KAAK,KAAK,CAAC;QACzE;AAEA,YAAI,KAAK,mBAAmB;AACxB,gBAAM,cAAc,KAAK,gBAAgB;QAC7C;MACJ;;;;;;MAOO,OAAO,eAAoC;AAC9C,mBAAW,OAAO,KAAK,UAAU;AAC7B,gBAAM,QAAQ,KAAK,SAAS,GAAG;AAC/B,cAAI,UAAU,eAAe;AACzB,kBAAM,cAAa;AACnB,kBAAM,SAAS;AACf,mBAAO,KAAK,SAAS,GAAG;AACxB,iBAAK,kBAAiB;AAEtB;UACJ;QACJ;MACJ;;;;;;MAOO,aAAa,WAAiB;AACjC,mBAAW,OAAO,KAAK,UAAU;AAC7B,gBAAM,QAAQ,KAAK,SAAS,GAAG;AAC/B,cAAI,MAAM,aAAY,MAAO,WAAW;AACpC,kBAAM,cAAa;AACnB,kBAAM,SAAS;AACf,mBAAO,KAAK,SAAS,GAAG;AACxB,iBAAK,kBAAiB;UAC1B;QACJ;MACJ;MAEQ,gBAAgB,IAAc;AAClC,cAAM,UAAU,KAAK;AACrB,eAAO,MAAK;AACR,kBAAO;AACP,aAAE;QACN;MACJ;;;;;MAMO,YAAY,OAA4B;AAC3C,YAAI,KAAK,mBAAmB;AACxB,gBAAM,cAAc,KAAK,gBAAgB;QAC7C;MACJ;;;;;MAMO,cAAc,mBAA4B,OAAK;AAClD,YAAI,KAAK,mBAAmB;AACxB;QACJ;AAEA,2BAAmB,OAAO,2CAA2C,QAAQ;AAC7E,aAAK,oBAAoB;AACzB,aAAK,mBAAmB;AAExB,mBAAW,OAAO,KAAK,UAAU;AAC7B,eAAK,SAAS,GAAG,EAAE,cAAc,gBAAgB;QACrD;MACJ;;;;;MAMO,cAAc,aAAa,OAAK;AACnC,mBAAW,OAAO,KAAK,UAAU;AAC7B,eAAK,SAAS,GAAG,EAAE,cAAa;AAEhC,cAAI,YAAY;AACZ,iBAAK,SAAS,GAAG,EAAE,SAAS;UAChC;QACJ;AACA,aAAK,oBAAoB;MAC7B;;;;;MAMO,oBAAiB;AACpB,aAAK,cAAc,MAAK;QAAE;AAE1B,mBAAW,OAAO,KAAK,UAAU;AAC7B,gBAAM,QAAQ,KAAK,SAAS,GAAG;AAC/B,cAAI,MAAM,aAAa;AACnB,iBAAK,cAAc,KAAK,gBAAgB,MAAM,YAAY,KAAK,KAAK,CAAC;UACzE;QACJ;MACJ;;;;MAKO,QAAK;AACR,YAAI,KAAK,mBAAmB;AACxB,eAAK,cAAc,IAAI;QAC3B;AACA,aAAK,WAAW,CAAA;AAChB,aAAK,oBAAoB;AACzB,aAAK,cAAc,MAAK;QAAE;MAC9B;;;;;;;MAQO,UAAU,kBAAqB;AAClC,cAAM,SAAiC,CAAA;AACvC,mBAAW,OAAO,KAAK,UAAU;AAC7B,gBAAM,QAAQ,KAAK,SAAS,GAAG;AAC/B,gBAAM,MAAM,oBAAoB,UAAU,KAAK;AAC/C,iBAAO,MAAM,aAAY,CAAE,IAAI;QACnC;AAEA,yBAAiB,YAAY;MACjC;;;;;;MAOO,MAAM,cAAiB;AAC1B,cAAM,eAAe,aAAa;AAClC,YAAI,cAAc;AACd,eAAK,MAAK;AAEV,qBAAW,KAAK,cAAc;AAC1B,kBAAM,YAAkB,iBAAkB,CAAC;AAC3C,gBAAI,WAAW;AACX,oBAAM,cAAc,aAAa,CAAC;AAClC,oBAAM,QAAQ,oBAAoB,MAC9B,MAAK;AACD,uBAAO,IAAI,UAAS;cACxB,GACA,aACA,IAAI;AAER,mBAAK,IAAI,KAAY;YACzB;UACJ;QACJ,OAAO;AAEH,qBAAW,KAAK,KAAK,UAAU;AAC3B,kBAAM,YAAkB,iBAAkB,KAAK,SAAS,CAAC,EAAE,aAAY,CAAE;AACzE,gBAAI,WAAW;AACX,oBAAM,QAAQ,oBAAoB,MAC9B,MAAK;AACD,uBAAO,IAAI,UAAS;cACxB,GACA,cACA,IAAI;AAER,mBAAK,OAAO,KAAK,SAAS,CAAC,CAAC;AAC5B,mBAAK,IAAI,KAAY;YACzB;UACJ;QACJ;MACJ;;;;",
  "names": []
}
