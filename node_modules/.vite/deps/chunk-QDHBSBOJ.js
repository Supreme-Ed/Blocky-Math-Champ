import {
  BackEase,
  EasingFunction,
  ExponentialEase
} from "./chunk-T4DGKPNS.js";
import {
  ArcRotateCameraKeyboardMoveInput
} from "./chunk-T2MFCFQK.js";
import {
  Mesh,
  TargetCamera
} from "./chunk-4YYSBNIR.js";
import {
  Animation
} from "./chunk-YJR5DE4R.js";
import {
  EventConstants
} from "./chunk-AHX427KC.js";
import {
  ArcRotateCameraPointersInput
} from "./chunk-QDHNJJHX.js";
import {
  PointerEventTypes
} from "./chunk-S35NOMKC.js";
import {
  Camera,
  CameraInputTypes,
  CameraInputsManager
} from "./chunk-YMSLHG7U.js";
import {
  Node
} from "./chunk-T6V6RRIQ.js";
import {
  Plane
} from "./chunk-GV2VOAY7.js";
import {
  __decorate,
  serialize,
  serializeAsMeshReference,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-S2HVPJYT.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3
} from "./chunk-5OHQ76KS.js";
import {
  Tools
} from "./chunk-X2TAJB4G.js";
import {
  PrecisionDate
} from "./chunk-AZNEH5GV.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";
import {
  Epsilon
} from "./chunk-AQLPQ2Z4.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import {
  Clamp
} from "./chunk-RASTRIFA.js";

// node_modules/@babylonjs/core/Behaviors/Cameras/autoRotationBehavior.js
var AutoRotationBehavior = class {
  constructor() {
    this._zoomStopsAnimation = false;
    this._idleRotationSpeed = 0.05;
    this._idleRotationWaitTime = 2e3;
    this._idleRotationSpinupTime = 2e3;
    this.targetAlpha = null;
    this._isPointerDown = false;
    this._lastFrameTime = null;
    this._lastInteractionTime = -Infinity;
    this._cameraRotationSpeed = 0;
    this._lastFrameRadius = 0;
  }
  /**
   * Gets the name of the behavior.
   */
  get name() {
    return "AutoRotation";
  }
  /**
   * Sets the flag that indicates if user zooming should stop animation.
   */
  set zoomStopsAnimation(flag) {
    this._zoomStopsAnimation = flag;
  }
  /**
   * Gets the flag that indicates if user zooming should stop animation.
   */
  get zoomStopsAnimation() {
    return this._zoomStopsAnimation;
  }
  /**
   * Sets the default speed at which the camera rotates around the model.
   */
  set idleRotationSpeed(speed) {
    this._idleRotationSpeed = speed;
  }
  /**
   * Gets the default speed at which the camera rotates around the model.
   */
  get idleRotationSpeed() {
    return this._idleRotationSpeed;
  }
  /**
   * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
   */
  set idleRotationWaitTime(time) {
    this._idleRotationWaitTime = time;
  }
  /**
   * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
   */
  get idleRotationWaitTime() {
    return this._idleRotationWaitTime;
  }
  /**
   * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
   */
  set idleRotationSpinupTime(time) {
    this._idleRotationSpinupTime = time;
  }
  /**
   * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
   */
  get idleRotationSpinupTime() {
    return this._idleRotationSpinupTime;
  }
  /**
   * Gets a value indicating if the camera is currently rotating because of this behavior
   */
  get rotationInProgress() {
    return Math.abs(this._cameraRotationSpeed) > 0;
  }
  /**
   * Initializes the behavior.
   */
  init() {
  }
  /**
   * Attaches the behavior to its arc rotate camera.
   * @param camera Defines the camera to attach the behavior to
   */
  attach(camera) {
    this._attachedCamera = camera;
    const scene = this._attachedCamera.getScene();
    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {
      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
        this._isPointerDown = true;
        return;
      }
      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
        this._isPointerDown = false;
      }
    });
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      if (this._reachTargetAlpha()) {
        return;
      }
      const now = PrecisionDate.Now;
      let dt = 0;
      if (this._lastFrameTime != null) {
        dt = now - this._lastFrameTime;
      }
      this._lastFrameTime = now;
      this._applyUserInteraction();
      const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;
      const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);
      this._cameraRotationSpeed = this._idleRotationSpeed * scale;
      if (this._attachedCamera) {
        this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1e3);
      }
    });
  }
  /**
   * Detaches the behavior from its current arc rotate camera.
   */
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    const scene = this._attachedCamera.getScene();
    if (this._onPrePointerObservableObserver) {
      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
    }
    this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    this._attachedCamera = null;
    this._lastFrameTime = null;
  }
  /**
   * Force-reset the last interaction time
   * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`
   */
  resetLastInteractionTime(customTime) {
    this._lastInteractionTime = customTime ?? PrecisionDate.Now;
  }
  /**
   * Returns true if camera alpha reaches the target alpha
   * @returns true if camera alpha reaches the target alpha
   */
  _reachTargetAlpha() {
    if (this._attachedCamera && this.targetAlpha) {
      return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;
    }
    return false;
  }
  /**
   * Returns true if user is scrolling.
   * @returns true if user is scrolling.
   */
  _userIsZooming() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialRadiusOffset !== 0;
  }
  _shouldAnimationStopForInteraction() {
    if (!this._attachedCamera) {
      return false;
    }
    let zoomHasHitLimit = false;
    if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {
      zoomHasHitLimit = true;
    }
    this._lastFrameRadius = this._attachedCamera.radius;
    return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();
  }
  /**
   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
   */
  _applyUserInteraction() {
    if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {
      this._lastInteractionTime = PrecisionDate.Now;
    }
  }
  // Tools
  _userIsMoving() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
  }
};

// node_modules/@babylonjs/core/Behaviors/Cameras/bouncingBehavior.js
var BouncingBehavior = class _BouncingBehavior {
  constructor() {
    this.transitionDuration = 450;
    this.lowerRadiusTransitionRange = 2;
    this.upperRadiusTransitionRange = -2;
    this._autoTransitionRange = false;
    this._radiusIsAnimating = false;
    this._radiusBounceTransition = null;
    this._animatables = new Array();
  }
  /**
   * Gets the name of the behavior.
   */
  get name() {
    return "Bouncing";
  }
  /**
   * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
   */
  get autoTransitionRange() {
    return this._autoTransitionRange;
  }
  /**
   * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
   * Transition ranges will be set to 5% of the bounding box diagonal in world space
   */
  set autoTransitionRange(value) {
    if (this._autoTransitionRange === value) {
      return;
    }
    this._autoTransitionRange = value;
    const camera = this._attachedCamera;
    if (!camera) {
      return;
    }
    if (value) {
      this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {
        if (!transformNode) {
          return;
        }
        transformNode.computeWorldMatrix(true);
        if (transformNode.getBoundingInfo) {
          const diagonal = transformNode.getBoundingInfo().diagonalLength;
          this.lowerRadiusTransitionRange = diagonal * 0.05;
          this.upperRadiusTransitionRange = diagonal * 0.05;
        }
      });
    } else if (this._onMeshTargetChangedObserver) {
      camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
  }
  /**
   * Initializes the behavior.
   */
  init() {
  }
  /**
   * Attaches the behavior to its arc rotate camera.
   * @param camera Defines the camera to attach the behavior to
   */
  attach(camera) {
    this._attachedCamera = camera;
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      if (!this._attachedCamera) {
        return;
      }
      if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {
        this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);
      }
      if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {
        this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);
      }
    });
  }
  /**
   * Detaches the behavior from its current arc rotate camera.
   */
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    if (this._onAfterCheckInputsObserver) {
      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    }
    if (this._onMeshTargetChangedObserver) {
      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
    this._attachedCamera = null;
  }
  /**
   * Checks if the camera radius is at the specified limit. Takes into account animation locks.
   * @param radiusLimit The limit to check against.
   * @returns Bool to indicate if at limit.
   */
  _isRadiusAtLimit(radiusLimit) {
    if (!this._attachedCamera) {
      return false;
    }
    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {
      return true;
    }
    return false;
  }
  /**
   * Applies an animation to the radius of the camera, extending by the radiusDelta.
   * @param radiusDelta The delta by which to animate to. Can be negative.
   */
  _applyBoundRadiusAnimation(radiusDelta) {
    if (!this._attachedCamera) {
      return;
    }
    if (!this._radiusBounceTransition) {
      _BouncingBehavior.EasingFunction.setEasingMode(_BouncingBehavior.EasingMode);
      this._radiusBounceTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, _BouncingBehavior.EasingFunction);
    }
    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;
    this._attachedCamera.wheelPrecision = Infinity;
    this._attachedCamera.inertialRadiusOffset = 0;
    this.stopAllAnimations();
    this._radiusIsAnimating = true;
    const animatable = Animation.TransitionTo("radius", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, () => this._clearAnimationLocks());
    if (animatable) {
      this._animatables.push(animatable);
    }
  }
  /**
   * Removes all animation locks. Allows new animations to be added to any of the camera properties.
   */
  _clearAnimationLocks() {
    this._radiusIsAnimating = false;
    if (this._attachedCamera) {
      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;
    }
  }
  /**
   * Stops and removes all animations that have been applied to the camera
   */
  stopAllAnimations() {
    if (this._attachedCamera) {
      this._attachedCamera.animations = [];
    }
    while (this._animatables.length) {
      this._animatables[0].onAnimationEnd = null;
      this._animatables[0].stop();
      this._animatables.shift();
    }
  }
};
BouncingBehavior.EasingFunction = new BackEase(0.3);
BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;

// node_modules/@babylonjs/core/Behaviors/Cameras/framingBehavior.js
var FramingBehavior = class _FramingBehavior {
  constructor() {
    this.onTargetFramingAnimationEndObservable = new Observable();
    this._mode = _FramingBehavior.FitFrustumSidesMode;
    this._radiusScale = 1;
    this._positionScale = 0.5;
    this._defaultElevation = 0.3;
    this._elevationReturnTime = 1500;
    this._elevationReturnWaitTime = 1e3;
    this._zoomStopsAnimation = false;
    this._framingTime = 1500;
    this.autoCorrectCameraLimitsAndSensibility = true;
    this._isPointerDown = false;
    this._lastInteractionTime = -Infinity;
    this._animatables = new Array();
    this._betaIsAnimating = false;
  }
  /**
   * Gets the name of the behavior.
   */
  get name() {
    return "Framing";
  }
  /**
   * Sets the current mode used by the behavior
   */
  set mode(mode) {
    this._mode = mode;
  }
  /**
   * Gets current mode used by the behavior.
   */
  get mode() {
    return this._mode;
  }
  /**
   * Sets the scale applied to the radius (1 by default)
   */
  set radiusScale(radius) {
    this._radiusScale = radius;
  }
  /**
   * Gets the scale applied to the radius
   */
  get radiusScale() {
    return this._radiusScale;
  }
  /**
   * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
   */
  set positionScale(scale) {
    this._positionScale = scale;
  }
  /**
   * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
   */
  get positionScale() {
    return this._positionScale;
  }
  /**
   * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
   * behaviour is triggered, in radians.
   */
  set defaultElevation(elevation) {
    this._defaultElevation = elevation;
  }
  /**
   * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
   * behaviour is triggered, in radians.
   */
  get defaultElevation() {
    return this._defaultElevation;
  }
  /**
   * Sets the time (in milliseconds) taken to return to the default beta position.
   * Negative value indicates camera should not return to default.
   */
  set elevationReturnTime(speed) {
    this._elevationReturnTime = speed;
  }
  /**
   * Gets the time (in milliseconds) taken to return to the default beta position.
   * Negative value indicates camera should not return to default.
   */
  get elevationReturnTime() {
    return this._elevationReturnTime;
  }
  /**
   * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
   */
  set elevationReturnWaitTime(time) {
    this._elevationReturnWaitTime = time;
  }
  /**
   * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
   */
  get elevationReturnWaitTime() {
    return this._elevationReturnWaitTime;
  }
  /**
   * Sets the flag that indicates if user zooming should stop animation.
   */
  set zoomStopsAnimation(flag) {
    this._zoomStopsAnimation = flag;
  }
  /**
   * Gets the flag that indicates if user zooming should stop animation.
   */
  get zoomStopsAnimation() {
    return this._zoomStopsAnimation;
  }
  /**
   * Sets the transition time when framing the mesh, in milliseconds
   */
  set framingTime(time) {
    this._framingTime = time;
  }
  /**
   * Gets the transition time when framing the mesh, in milliseconds
   */
  get framingTime() {
    return this._framingTime;
  }
  /**
   * Initializes the behavior.
   */
  init() {
  }
  /**
   * Attaches the behavior to its arc rotate camera.
   * @param camera Defines the camera to attach the behavior to
   */
  attach(camera) {
    this._attachedCamera = camera;
    const scene = this._attachedCamera.getScene();
    _FramingBehavior.EasingFunction.setEasingMode(_FramingBehavior.EasingMode);
    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {
      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
        this._isPointerDown = true;
        return;
      }
      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
        this._isPointerDown = false;
      }
    });
    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {
      if (transformNode && transformNode.getBoundingInfo) {
        this.zoomOnMesh(transformNode, void 0, () => {
          this.onTargetFramingAnimationEndObservable.notifyObservers();
        });
      }
    });
    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
      this._applyUserInteraction();
      this._maintainCameraAboveGround();
    });
  }
  /**
   * Detaches the behavior from its current arc rotate camera.
   */
  detach() {
    if (!this._attachedCamera) {
      return;
    }
    const scene = this._attachedCamera.getScene();
    if (this._onPrePointerObservableObserver) {
      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
    }
    if (this._onAfterCheckInputsObserver) {
      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
    }
    if (this._onMeshTargetChangedObserver) {
      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
    }
    this._attachedCamera = null;
  }
  /**
   * Targets the given mesh and updates zoom level accordingly.
   * @param mesh  The mesh to target.
   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
   * @param onAnimationEnd Callback triggered at the end of the framing animation
   */
  zoomOnMesh(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {
    mesh.computeWorldMatrix(true);
    const boundingBox = mesh.getBoundingInfo().boundingBox;
    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);
  }
  /**
   * Targets the given mesh with its children and updates zoom level accordingly.
   * @param mesh The mesh to target.
   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
   * @param onAnimationEnd Callback triggered at the end of the framing animation
   */
  zoomOnMeshHierarchy(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {
    mesh.computeWorldMatrix(true);
    const boundingBox = mesh.getHierarchyBoundingVectors(true);
    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);
  }
  /**
   * Targets the given meshes with their children and updates zoom level accordingly.
   * @param meshes  The mesh to target.
   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
   * @param onAnimationEnd Callback triggered at the end of the framing animation
   */
  zoomOnMeshesHierarchy(meshes, focusOnOriginXZ = false, onAnimationEnd = null) {
    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let i = 0; i < meshes.length; i++) {
      const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);
      Vector3.CheckExtends(boundingInfo.min, min, max);
      Vector3.CheckExtends(boundingInfo.max, min, max);
    }
    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);
  }
  /**
   * Targets the bounding box info defined by its extends and updates zoom level accordingly.
   * @param minimumWorld Determines the smaller position of the bounding box extend
   * @param maximumWorld Determines the bigger position of the bounding box extend
   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
   * @param onAnimationEnd Callback triggered at the end of the framing animation
   * @returns true if the zoom was done
   */
  zoomOnBoundingInfo(minimumWorld, maximumWorld, focusOnOriginXZ = false, onAnimationEnd = null) {
    let zoomTarget;
    if (!this._attachedCamera) {
      return false;
    }
    const bottom = minimumWorld.y;
    const top = maximumWorld.y;
    const zoomTargetY = bottom + (top - bottom) * this._positionScale;
    const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);
    if (!isFinite(zoomTargetY)) {
      return false;
    }
    if (focusOnOriginXZ) {
      zoomTarget = new Vector3(0, zoomTargetY, 0);
    } else {
      const centerWorld = minimumWorld.add(radiusWorld);
      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);
    }
    if (!this._vectorTransition) {
      this._vectorTransition = Animation.CreateAnimation("target", Animation.ANIMATIONTYPE_VECTOR3, 60, _FramingBehavior.EasingFunction);
    }
    this._betaIsAnimating = true;
    let animatable = Animation.TransitionTo("target", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);
    if (animatable) {
      this._animatables.push(animatable);
    }
    let radius = 0;
    if (this._mode === _FramingBehavior.FitFrustumSidesMode) {
      const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
      if (this.autoCorrectCameraLimitsAndSensibility) {
        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;
      }
      radius = position;
    } else if (this._mode === _FramingBehavior.IgnoreBoundsSizeMode) {
      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {
        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;
      }
    }
    if (this.autoCorrectCameraLimitsAndSensibility) {
      const extend = maximumWorld.subtract(minimumWorld).length();
      this._attachedCamera.panningSensibility = 5e3 / extend;
      this._attachedCamera.wheelPrecision = 100 / radius;
    }
    if (!this._radiusTransition) {
      this._radiusTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, _FramingBehavior.EasingFunction);
    }
    animatable = Animation.TransitionTo("radius", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {
      this.stopAllAnimations();
      if (onAnimationEnd) {
        onAnimationEnd();
      }
      if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {
        this._attachedCamera.storeState();
      }
    });
    if (animatable) {
      this._animatables.push(animatable);
    }
    return true;
  }
  /**
   * Calculates the lowest radius for the camera based on the bounding box of the mesh.
   * @param minimumWorld
   * @param maximumWorld
   * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order
   *		 to fully enclose the mesh in the viewing frustum.
   */
  _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld) {
    const camera = this._attachedCamera;
    if (!camera) {
      return 0;
    }
    let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);
    if (camera.lowerRadiusLimit && this._mode === _FramingBehavior.IgnoreBoundsSizeMode) {
      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;
    }
    if (camera.upperRadiusLimit) {
      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;
    }
    return distance;
  }
  /**
   * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera
   * is automatically returned to its default position (expected to be above ground plane).
   */
  _maintainCameraAboveGround() {
    if (this._elevationReturnTime < 0) {
      return;
    }
    const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;
    const defaultBeta = Math.PI * 0.5 - this._defaultElevation;
    const limitBeta = Math.PI * 0.5;
    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {
      this._betaIsAnimating = true;
      this.stopAllAnimations();
      if (!this._betaTransition) {
        this._betaTransition = Animation.CreateAnimation("beta", Animation.ANIMATIONTYPE_FLOAT, 60, _FramingBehavior.EasingFunction);
      }
      const animatabe = Animation.TransitionTo("beta", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, () => {
        this._clearAnimationLocks();
        this.stopAllAnimations();
      });
      if (animatabe) {
        this._animatables.push(animatabe);
      }
    }
  }
  /**
   * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.
   */
  _clearAnimationLocks() {
    this._betaIsAnimating = false;
  }
  /**
   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
   */
  _applyUserInteraction() {
    if (this.isUserIsMoving) {
      this._lastInteractionTime = PrecisionDate.Now;
      this.stopAllAnimations();
      this._clearAnimationLocks();
    }
  }
  /**
   * Stops and removes all animations that have been applied to the camera
   */
  stopAllAnimations() {
    if (this._attachedCamera) {
      this._attachedCamera.animations = [];
    }
    while (this._animatables.length) {
      if (this._animatables[0]) {
        this._animatables[0].onAnimationEnd = null;
        this._animatables[0].stop();
      }
      this._animatables.shift();
    }
  }
  /**
   * Gets a value indicating if the user is moving the camera
   */
  get isUserIsMoving() {
    if (!this._attachedCamera) {
      return false;
    }
    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
  }
};
FramingBehavior.EasingFunction = new ExponentialEase();
FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;
FramingBehavior.IgnoreBoundsSizeMode = 0;
FramingBehavior.FitFrustumSidesMode = 1;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js
var ffMultiplier = 40;
var ArcRotateCameraMouseWheelInput = class {
  constructor() {
    this.wheelPrecision = 3;
    this.zoomToMouseLocation = false;
    this.wheelDeltaPercentage = 0;
    this.customComputeDeltaFromMouseWheel = null;
    this._viewOffset = new Vector3(0, 0, 0);
    this._globalOffset = new Vector3(0, 0, 0);
    this._inertialPanning = Vector3.Zero();
  }
  _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta, radius) {
    let delta = 0;
    const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;
    if (mouseWheelDelta > 0) {
      delta = wheelDelta / (1 + this.wheelDeltaPercentage);
    } else {
      delta = wheelDelta * (1 + this.wheelDeltaPercentage);
    }
    return delta;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = (p) => {
      if (p.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      const event = p.event;
      let delta = 0;
      const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1;
      const wheelDelta = -(event.deltaY * platformScale);
      if (this.customComputeDeltaFromMouseWheel) {
        delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);
      } else {
        if (this.wheelDeltaPercentage) {
          delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);
          if (delta > 0) {
            let estimatedTargetRadius = this.camera.radius;
            let targetInertia = this.camera.inertialRadiusOffset + delta;
            for (let i = 0; i < 20; i++) {
              if (estimatedTargetRadius <= targetInertia) {
                break;
              }
              if (Math.abs(targetInertia * this.camera.inertia) < 1e-3) {
                break;
              }
              estimatedTargetRadius -= targetInertia;
              targetInertia *= this.camera.inertia;
            }
            estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);
            delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);
          }
        } else {
          delta = wheelDelta / (this.wheelPrecision * 40);
        }
      }
      if (delta) {
        if (this.zoomToMouseLocation) {
          if (!this._hitPlane) {
            this._updateHitPlane();
          }
          this._zoomToMouse(delta);
        } else {
          this.camera.inertialRadiusOffset += delta;
        }
      }
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
    if (this.zoomToMouseLocation) {
      this._inertialPanning.setAll(0);
    }
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this._observer = null;
      this._wheel = null;
    }
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (!this.zoomToMouseLocation) {
      return;
    }
    const camera = this.camera;
    const motion = 0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;
    if (motion) {
      this._updateHitPlane();
      camera.target.addInPlace(this._inertialPanning);
      this._inertialPanning.scaleInPlace(camera.inertia);
      this._zeroIfClose(this._inertialPanning);
    }
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "ArcRotateCameraMouseWheelInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "mousewheel";
  }
  _updateHitPlane() {
    const camera = this.camera;
    const direction = camera.target.subtract(camera.position);
    this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);
  }
  // Get position on the hit plane
  _getPosition() {
    const camera = this.camera;
    const scene = camera.getScene();
    const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);
    if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {
      this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);
      camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
      this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);
      ray.origin.addInPlace(this._globalOffset);
    }
    let distance = 0;
    if (this._hitPlane) {
      distance = ray.intersectsPlane(this._hitPlane) ?? 0;
    }
    return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));
  }
  _zoomToMouse(delta) {
    const camera = this.camera;
    const inertiaComp = 1 - camera.inertia;
    if (camera.lowerRadiusLimit) {
      const lowerLimit = camera.lowerRadiusLimit ?? 0;
      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {
        delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;
      }
    }
    if (camera.upperRadiusLimit) {
      const upperLimit = camera.upperRadiusLimit ?? 0;
      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {
        delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;
      }
    }
    const zoomDistance = delta / inertiaComp;
    const ratio = zoomDistance / camera.radius;
    const vec = this._getPosition();
    const directionToZoomLocation = TmpVectors.Vector3[6];
    vec.subtractToRef(camera.target, directionToZoomLocation);
    directionToZoomLocation.scaleInPlace(ratio);
    directionToZoomLocation.scaleInPlace(inertiaComp);
    this._inertialPanning.addInPlace(directionToZoomLocation);
    camera.inertialRadiusOffset += delta;
  }
  // Sets x y or z of passed in vector to zero if less than Epsilon.
  _zeroIfClose(vec) {
    if (Math.abs(vec.x) < Epsilon) {
      vec.x = 0;
    }
    if (Math.abs(vec.y) < Epsilon) {
      vec.y = 0;
    }
    if (Math.abs(vec.z) < Epsilon) {
      vec.z = 0;
    }
  }
};
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "zoomToMouseLocation", void 0);
__decorate([
  serialize()
], ArcRotateCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
CameraInputTypes["ArcRotateCameraMouseWheelInput"] = ArcRotateCameraMouseWheelInput;

// node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js
var ArcRotateCameraInputsManager = class extends CameraInputsManager {
  /**
   * Instantiates a new ArcRotateCameraInputsManager.
   * @param camera Defines the camera the inputs belong to
   */
  constructor(camera) {
    super(camera);
  }
  /**
   * Add mouse wheel input support to the input manager.
   * @returns the current input manager
   */
  addMouseWheel() {
    this.add(new ArcRotateCameraMouseWheelInput());
    return this;
  }
  /**
   * Add pointers input support to the input manager.
   * @returns the current input manager
   */
  addPointers() {
    this.add(new ArcRotateCameraPointersInput());
    return this;
  }
  /**
   * Add keyboard input support to the input manager.
   * @returns the current input manager
   */
  addKeyboard() {
    this.add(new ArcRotateCameraKeyboardMoveInput());
    return this;
  }
};

// node_modules/@babylonjs/core/Cameras/arcRotateCamera.js
Node.AddNodeConstructor("ArcRotateCamera", (name, scene) => {
  return () => new ArcRotateCamera(name, 0, 0, 1, Vector3.Zero(), scene);
});
function ComputeAlpha(offset) {
  let alpha = Math.PI / 2;
  if (!(offset.x === 0 && offset.z === 0)) {
    alpha = Math.acos(offset.x / Math.sqrt(Math.pow(offset.x, 2) + Math.pow(offset.z, 2)));
  }
  if (offset.z < 0) {
    alpha = 2 * Math.PI - alpha;
  }
  return alpha;
}
function ComputeBeta(verticalOffset, radius) {
  return Math.acos(verticalOffset / radius);
}
function checkNaN(value, fallback) {
  return isNaN(value) ? fallback : value;
}
var ArcRotateCamera = class _ArcRotateCamera extends TargetCamera {
  /**
   * Defines the target point of the camera.
   * The camera looks towards it from the radius distance.
   */
  get target() {
    return this._target;
  }
  set target(value) {
    this.setTarget(value);
  }
  /**
   * Defines the target transform node of the camera.
   * The camera looks towards it from the radius distance.
   * Please note that setting a target host will disable panning.
   */
  get targetHost() {
    return this._targetHost;
  }
  set targetHost(value) {
    if (value) {
      this.setTarget(value);
    }
  }
  /**
   * Return the current target position of the camera. This value is expressed in local space.
   * @returns the target position
   */
  getTarget() {
    return this.target;
  }
  /**
   * Define the current local position of the camera in the scene
   */
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this.setPosition(newPosition);
  }
  /**
   * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())
   * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.
   * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.
   */
  set upVector(vec) {
    if (!this._upToYMatrix) {
      this._yToUpMatrix = new Matrix();
      this._upToYMatrix = new Matrix();
      this._upVector = Vector3.Zero();
    }
    vec.normalize();
    this._upVector.copyFrom(vec);
    this.setMatUp();
  }
  get upVector() {
    return this._upVector;
  }
  /**
   * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.
   */
  setMatUp() {
    Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);
    Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);
  }
  //-- begin properties for backward compatibility for inputs
  /**
   * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.
   */
  get angularSensibilityX() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.angularSensibilityX;
    }
    return 0;
  }
  set angularSensibilityX(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.angularSensibilityX = value;
    }
  }
  /**
   * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.
   */
  get angularSensibilityY() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.angularSensibilityY;
    }
    return 0;
  }
  set angularSensibilityY(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.angularSensibilityY = value;
    }
  }
  /**
   * Gets or Set the pointer pinch precision or how fast is the camera zooming.
   */
  get pinchPrecision() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.pinchPrecision;
    }
    return 0;
  }
  set pinchPrecision(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.pinchPrecision = value;
    }
  }
  /**
   * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.
   * It will be used instead of pinchPrecision if different from 0.
   * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
   */
  get pinchDeltaPercentage() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.pinchDeltaPercentage;
    }
    return 0;
  }
  set pinchDeltaPercentage(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.pinchDeltaPercentage = value;
    }
  }
  /**
   * Gets or Set the pointer use natural pinch zoom to override the pinch precision
   * and pinch delta percentage.
   * When useNaturalPinchZoom is true, multi touch zoom will zoom in such
   * that any object in the plane at the camera's target point will scale
   * perfectly with finger motion.
   */
  get useNaturalPinchZoom() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.useNaturalPinchZoom;
    }
    return false;
  }
  set useNaturalPinchZoom(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.useNaturalPinchZoom = value;
    }
  }
  /**
   * Gets or Set the pointer panning sensibility or how fast is the camera moving.
   */
  get panningSensibility() {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      return pointers.panningSensibility;
    }
    return 0;
  }
  set panningSensibility(value) {
    const pointers = this.inputs.attached["pointers"];
    if (pointers) {
      pointers.panningSensibility = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.
   */
  get keysUp() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysUp;
    }
    return [];
  }
  set keysUp(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysUp = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.
   */
  get keysDown() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysDown;
    }
    return [];
  }
  set keysDown(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysDown = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.
   */
  get keysLeft() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysLeft;
    }
    return [];
  }
  set keysLeft(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysLeft = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.
   */
  get keysRight() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRight;
    }
    return [];
  }
  set keysRight(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRight = value;
    }
  }
  /**
   * Gets or Set the mouse wheel precision or how fast is the camera zooming.
   */
  get wheelPrecision() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.wheelPrecision;
    }
    return 0;
  }
  set wheelPrecision(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.wheelPrecision = value;
    }
  }
  /**
   * Gets or Set the boolean value that controls whether or not the mouse wheel
   * zooms to the location of the mouse pointer or not.  The default is false.
   */
  get zoomToMouseLocation() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.zoomToMouseLocation;
    }
    return false;
  }
  set zoomToMouseLocation(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.zoomToMouseLocation = value;
    }
  }
  /**
   * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.
   * It will be used instead of wheelPrecision if different from 0.
   * It defines the percentage of current camera.radius to use as delta when wheel zoom is used.
   */
  get wheelDeltaPercentage() {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      return mousewheel.wheelDeltaPercentage;
    }
    return 0;
  }
  set wheelDeltaPercentage(value) {
    const mousewheel = this.inputs.attached["mousewheel"];
    if (mousewheel) {
      mousewheel.wheelDeltaPercentage = value;
    }
  }
  /**
   * If true, indicates the camera is currently interpolating to a new pose.
   */
  get isInterpolating() {
    return this._isInterpolating;
  }
  /**
   * Gets the bouncing behavior of the camera if it has been enabled.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior
   */
  get bouncingBehavior() {
    return this._bouncingBehavior;
  }
  /**
   * Defines if the bouncing behavior of the camera is enabled on the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior
   */
  get useBouncingBehavior() {
    return this._bouncingBehavior != null;
  }
  set useBouncingBehavior(value) {
    if (value === this.useBouncingBehavior) {
      return;
    }
    if (value) {
      this._bouncingBehavior = new BouncingBehavior();
      this.addBehavior(this._bouncingBehavior);
    } else if (this._bouncingBehavior) {
      this.removeBehavior(this._bouncingBehavior);
      this._bouncingBehavior = null;
    }
  }
  /**
   * Gets the framing behavior of the camera if it has been enabled.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior
   */
  get framingBehavior() {
    return this._framingBehavior;
  }
  /**
   * Defines if the framing behavior of the camera is enabled on the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior
   */
  get useFramingBehavior() {
    return this._framingBehavior != null;
  }
  set useFramingBehavior(value) {
    if (value === this.useFramingBehavior) {
      return;
    }
    if (value) {
      this._framingBehavior = new FramingBehavior();
      this.addBehavior(this._framingBehavior);
    } else if (this._framingBehavior) {
      this.removeBehavior(this._framingBehavior);
      this._framingBehavior = null;
    }
  }
  /**
   * Gets the auto rotation behavior of the camera if it has been enabled.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior
   */
  get autoRotationBehavior() {
    return this._autoRotationBehavior;
  }
  /**
   * Defines if the auto rotation behavior of the camera is enabled on the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior
   */
  get useAutoRotationBehavior() {
    return this._autoRotationBehavior != null;
  }
  set useAutoRotationBehavior(value) {
    if (value === this.useAutoRotationBehavior) {
      return;
    }
    if (value) {
      this._autoRotationBehavior = new AutoRotationBehavior();
      this.addBehavior(this._autoRotationBehavior);
    } else if (this._autoRotationBehavior) {
      this.removeBehavior(this._autoRotationBehavior);
      this._autoRotationBehavior = null;
    }
  }
  /**
   * Instantiates a new ArcRotateCamera in a given scene
   * @param name Defines the name of the camera
   * @param alpha Defines the camera rotation along the longitudinal axis
   * @param beta Defines the camera rotation along the latitudinal axis
   * @param radius Defines the camera distance from its target
   * @param target Defines the camera target
   * @param scene Defines the scene the camera belongs to
   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
   */
  constructor(name, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive = true) {
    super(name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.lowerAlphaLimit = null;
    this.upperAlphaLimit = null;
    this.lowerBetaLimit = 0.01;
    this.upperBetaLimit = Math.PI - 0.01;
    this.lowerRadiusLimit = null;
    this.upperRadiusLimit = null;
    this.lowerTargetYLimit = -Infinity;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    this.pinchToPanMaxDistance = 20;
    this.panningDistanceLimit = null;
    this.panningOriginTarget = Vector3.Zero();
    this.panningInertia = 0.9;
    this.zoomOnFactor = 1;
    this.targetScreenOffset = Vector2.Zero();
    this.allowUpsideDown = true;
    this.useInputToRestoreState = true;
    this.restoreStateInterpolationFactor = 0;
    this._currentInterpolationFactor = 0;
    this._viewMatrix = new Matrix();
    this.panningAxis = new Vector3(1, 1, 0);
    this._transformedDirection = new Vector3();
    this.mapPanning = false;
    this._isInterpolating = false;
    this.onMeshTargetChangedObservable = new Observable();
    this.checkCollisions = false;
    this.collisionRadius = new Vector3(0.5, 0.5, 0.5);
    this._previousPosition = Vector3.Zero();
    this._collisionVelocity = Vector3.Zero();
    this._newPosition = Vector3.Zero();
    this._computationVector = Vector3.Zero();
    this._goalAlpha = NaN;
    this._goalBeta = NaN;
    this._goalRadius = NaN;
    this._goalTarget = new Vector3(NaN, NaN, NaN);
    this._goalTargetScreenOffset = new Vector2(NaN, NaN);
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      if (!collidedMesh) {
        this._previousPosition.copyFrom(this._position);
      } else {
        this.setPosition(newPosition);
        if (this.onCollide) {
          this.onCollide(collidedMesh);
        }
      }
      const cosa = Math.cos(this.alpha);
      const sina = Math.sin(this.alpha);
      const cosb = Math.cos(this.beta);
      let sinb = Math.sin(this.beta);
      if (sinb === 0) {
        sinb = 1e-4;
      }
      const target2 = this._getTargetPosition();
      this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
      target2.addToRef(this._computationVector, this._newPosition);
      this._position.copyFrom(this._newPosition);
      let up = this.upVector;
      if (this.allowUpsideDown && this.beta < 0) {
        up = up.clone();
        up = up.negate();
      }
      this._computeViewMatrix(this._position, target2, up);
      this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
      this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
      this._collisionTriggered = false;
    };
    this._target = Vector3.Zero();
    if (target) {
      this.setTarget(target);
    }
    this.alpha = alpha;
    this.beta = beta;
    this.radius = radius;
    this.getViewMatrix();
    this.inputs = new ArcRotateCameraInputsManager(this);
    this.inputs.addKeyboard().addMouseWheel().addPointers();
  }
  // Cache
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.alpha = void 0;
    this._cache.beta = void 0;
    this._cache.radius = void 0;
    this._cache.targetScreenOffset = Vector2.Zero();
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._cache._target.copyFrom(this._getTargetPosition());
    this._cache.alpha = this.alpha;
    this._cache.beta = this.beta;
    this._cache.radius = this.radius;
    this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);
  }
  _getTargetPosition() {
    if (this._targetHost && this._targetHost.getAbsolutePosition) {
      const pos = this._targetHost.getAbsolutePosition();
      if (this._targetBoundingCenter) {
        pos.addToRef(this._targetBoundingCenter, this._target);
      } else {
        this._target.copyFrom(pos);
      }
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    if (lockedTargetPosition) {
      return lockedTargetPosition;
    }
    return this._target;
  }
  /**
   * Stores the current state of the camera (alpha, beta, radius and target)
   * @returns the camera itself
   */
  storeState() {
    this._storedAlpha = this.alpha;
    this._storedBeta = this.beta;
    this._storedRadius = this.radius;
    this._storedTarget = this._getTargetPosition().clone();
    this._storedTargetScreenOffset = this.targetScreenOffset.clone();
    return super.storeState();
  }
  /**
   * @internal
   * Restored camera state. You must call storeState() first
   */
  _restoreStateValues() {
    if (this.hasStateStored() && this.restoreStateInterpolationFactor > Epsilon && this.restoreStateInterpolationFactor < 1) {
      this.interpolateTo(this._storedAlpha, this._storedBeta, this._storedRadius, this._storedTarget, this._storedTargetScreenOffset, this.restoreStateInterpolationFactor);
      return true;
    }
    if (!super._restoreStateValues()) {
      return false;
    }
    this.setTarget(this._storedTarget.clone());
    this.alpha = this._storedAlpha;
    this.beta = this._storedBeta;
    this.radius = this._storedRadius;
    this.targetScreenOffset = this._storedTargetScreenOffset.clone();
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    return true;
  }
  /**
   * Stops any in-progress interpolation.
   */
  stopInterpolation() {
    this._goalAlpha = NaN;
    this._goalBeta = NaN;
    this._goalRadius = NaN;
    this._goalTarget.set(NaN, NaN, NaN);
    this._goalTargetScreenOffset.set(NaN, NaN);
  }
  /**
   * Interpolates the camera to a goal state.
   * @param alpha Defines the goal alpha.
   * @param beta Defines the goal beta.
   * @param radius Defines the goal radius.
   * @param target Defines the goal target.
   * @param targetScreenOffset Defines the goal target screen offset.
   * @param interpolationFactor A value  between 0 and 1 that determines the speed of the interpolation.
   * @remarks Passing undefined for any of the parameters will use the current value (effectively stopping any in-progress interpolation for that parameter).
   *          Passing NaN will not start or stop any interpolation for that parameter (effectively allowing multiple interpolations of different parameters to overlap).
   */
  interpolateTo(alpha = this.alpha, beta = this.beta, radius = this.radius, target = this.target, targetScreenOffset = this.targetScreenOffset, interpolationFactor) {
    this.inertialAlphaOffset = 0;
    this.inertialBetaOffset = 0;
    this.inertialRadiusOffset = 0;
    this.inertialPanningX = 0;
    this.inertialPanningY = 0;
    if (interpolationFactor != null) {
      this._currentInterpolationFactor = interpolationFactor;
    } else if (this.restoreStateInterpolationFactor !== 0) {
      this._currentInterpolationFactor = this.restoreStateInterpolationFactor;
    } else {
      this._currentInterpolationFactor = 0.1;
    }
    this._goalAlpha = checkNaN(alpha, this._goalAlpha);
    this._goalBeta = checkNaN(beta, this._goalBeta);
    this._goalRadius = checkNaN(radius, this._goalRadius);
    this._goalTarget.set(checkNaN(target.x, this._goalTarget.x), checkNaN(target.y, this._goalTarget.y), checkNaN(target.z, this._goalTarget.z));
    this._goalTargetScreenOffset.set(checkNaN(targetScreenOffset.x, this._goalTargetScreenOffset.x), checkNaN(targetScreenOffset.y, this._goalTargetScreenOffset.y));
    this._goalAlpha = Clamp(this._goalAlpha, this.lowerAlphaLimit ?? -Infinity, this.upperAlphaLimit ?? Infinity);
    this._goalBeta = Clamp(this._goalBeta, this.lowerBetaLimit ?? -Infinity, this.upperBetaLimit ?? Infinity);
    this._goalRadius = Clamp(this._goalRadius, this.lowerRadiusLimit ?? -Infinity, this.upperRadiusLimit ?? Infinity);
    this._goalTarget.y = Clamp(this._goalTarget.y, this.lowerTargetYLimit ?? -Infinity, Infinity);
    this._isInterpolating = true;
  }
  // Synchronized
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronizedViewMatrix()) {
      return false;
    }
    return this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);
  }
  /**
   * Attached controls to the current camera.
   * @param ignored defines an ignored parameter kept for backward compatibility.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls
   * @param panningMouseButton Defines whether panning is allowed through mouse click button
   */
  attachControl(ignored, noPreventDefault, useCtrlForPanning = true, panningMouseButton = 2) {
    const args = arguments;
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);
    this._useCtrlForPanning = useCtrlForPanning;
    this._panningMouseButton = panningMouseButton;
    if (typeof args[0] === "boolean") {
      if (args.length > 1) {
        this._useCtrlForPanning = args[1];
      }
      if (args.length > 2) {
        this._panningMouseButton = args[2];
      }
    }
    this.inputs.attachElement(noPreventDefault);
    this._reset = () => {
      this.inertialAlphaOffset = 0;
      this.inertialBetaOffset = 0;
      this.inertialRadiusOffset = 0;
      this.inertialPanningX = 0;
      this.inertialPanningY = 0;
    };
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    this.inputs.detachElement();
    if (this._reset) {
      this._reset();
    }
  }
  /** @internal */
  _checkInputs() {
    if (this._collisionTriggered) {
      return;
    }
    this.inputs.checkInputs();
    let hasUserInteractions = false;
    if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {
      hasUserInteractions = true;
      const directionModifier = this.invertRotation ? -1 : 1;
      const handednessMultiplier = this._calculateHandednessMultiplier();
      let inertialAlphaOffset = this.inertialAlphaOffset * handednessMultiplier;
      if (this.beta < 0) {
        inertialAlphaOffset *= -1;
      }
      this.alpha += inertialAlphaOffset * directionModifier;
      this.beta += this.inertialBetaOffset * directionModifier;
      this.radius -= this.inertialRadiusOffset;
      this.inertialAlphaOffset *= this.inertia;
      this.inertialBetaOffset *= this.inertia;
      this.inertialRadiusOffset *= this.inertia;
      if (Math.abs(this.inertialAlphaOffset) < Epsilon) {
        this.inertialAlphaOffset = 0;
      }
      if (Math.abs(this.inertialBetaOffset) < Epsilon) {
        this.inertialBetaOffset = 0;
      }
      if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {
        this.inertialRadiusOffset = 0;
      }
    }
    if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {
      hasUserInteractions = true;
      const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);
      this._viewMatrix.invertToRef(this._cameraTransformMatrix);
      localDirection.multiplyInPlace(this.panningAxis);
      Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);
      if (this.mapPanning) {
        const up = this.upVector;
        const right = Vector3.CrossToRef(this._transformedDirection, up, this._transformedDirection);
        Vector3.CrossToRef(up, right, this._transformedDirection);
      } else if (!this.panningAxis.y) {
        this._transformedDirection.y = 0;
      }
      if (!this._targetHost) {
        if (this.panningDistanceLimit) {
          this._transformedDirection.addInPlace(this._target);
          const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);
          if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {
            this._target.copyFrom(this._transformedDirection);
          }
        } else {
          if (this.parent) {
            const m = TmpVectors.Matrix[0];
            this.parent.getWorldMatrix().getRotationMatrixToRef(m);
            m.transposeToRef(m);
            Vector3.TransformCoordinatesToRef(this._transformedDirection, m, this._transformedDirection);
          }
          this._target.addInPlace(this._transformedDirection);
        }
      }
      this.inertialPanningX *= this.panningInertia;
      this.inertialPanningY *= this.panningInertia;
      if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {
        this.inertialPanningX = 0;
      }
      if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {
        this.inertialPanningY = 0;
      }
    }
    if (hasUserInteractions) {
      this.stopInterpolation();
    } else if (this._isInterpolating) {
      let isInterpolating = false;
      const dt = this._scene.getEngine().getDeltaTime() / 1e3;
      const t = 1 - Math.pow(2, -dt / this._currentInterpolationFactor);
      const goalRadius = checkNaN(this._goalRadius, this.radius);
      if (!isNaN(this._goalTarget.x) || !isNaN(this._goalTarget.y) || !isNaN(this._goalTarget.z)) {
        const goalTarget = TmpVectors.Vector3[0].set(checkNaN(this._goalTarget.x, this._target.x), checkNaN(this._goalTarget.y, this._target.y), checkNaN(this._goalTarget.z, this._target.z));
        this.setTarget(Vector3.Lerp(this.target, goalTarget, t), void 0, void 0, true);
        if (Vector3.Distance(this.target, goalTarget) * 10 / goalRadius < Epsilon) {
          this._goalTarget.set(NaN, NaN, NaN);
          this.setTarget(goalTarget.clone(), void 0, void 0, true);
        } else {
          isInterpolating = true;
        }
      }
      if (!isNaN(this._goalAlpha) || !isNaN(this._goalBeta)) {
        const goalRotation = Quaternion.RotationAlphaBetaGammaToRef(checkNaN(this._goalAlpha, this.alpha), checkNaN(this._goalBeta, this.beta), 0, TmpVectors.Quaternion[0]);
        const currentRotation = Quaternion.RotationAlphaBetaGammaToRef(this.alpha, this.beta, 0, TmpVectors.Quaternion[1]);
        const newRotation = Quaternion.SlerpToRef(currentRotation, goalRotation, t, TmpVectors.Quaternion[2]);
        newRotation.normalize();
        const newAlphaBetaGamma = newRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);
        this.alpha = newAlphaBetaGamma.x;
        this.beta = newAlphaBetaGamma.y;
        if (newRotation.isApprox(goalRotation, Epsilon / 5)) {
          this._goalAlpha = NaN;
          this._goalBeta = NaN;
          const goalAlphaBetaGamma = goalRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);
          this.alpha = goalAlphaBetaGamma.x;
          this.beta = goalAlphaBetaGamma.y;
        } else {
          isInterpolating = true;
        }
      }
      if (!isNaN(this._goalRadius)) {
        this.radius += (goalRadius - this.radius) * t;
        if (Math.abs(goalRadius / this.radius - 1) < Epsilon) {
          this._goalRadius = NaN;
          this.radius = goalRadius;
        } else {
          isInterpolating = true;
        }
      }
      if (!isNaN(this._goalTargetScreenOffset.x) || !isNaN(this._goalTargetScreenOffset.y)) {
        const goalTargetScreenOffset = TmpVectors.Vector2[0].set(checkNaN(this._goalTargetScreenOffset.x, this.targetScreenOffset.x), checkNaN(this._goalTargetScreenOffset.y, this.targetScreenOffset.y));
        Vector2.LerpToRef(this.targetScreenOffset, goalTargetScreenOffset, t, this.targetScreenOffset);
        if (Vector2.Distance(this.targetScreenOffset, goalTargetScreenOffset) < Epsilon) {
          this._goalTargetScreenOffset.set(NaN, NaN);
          this.targetScreenOffset.copyFrom(goalTargetScreenOffset);
        } else {
          isInterpolating = true;
        }
      }
      this._isInterpolating = isInterpolating;
    }
    this._checkLimits();
    super._checkInputs();
  }
  _checkLimits() {
    if (this.lowerBetaLimit === null || this.lowerBetaLimit === void 0) {
      if (this.allowUpsideDown && this.beta > Math.PI) {
        this.beta = this.beta - 2 * Math.PI;
      }
    } else {
      if (this.beta < this.lowerBetaLimit) {
        this.beta = this.lowerBetaLimit;
      }
    }
    if (this.upperBetaLimit === null || this.upperBetaLimit === void 0) {
      if (this.allowUpsideDown && this.beta < -Math.PI) {
        this.beta = this.beta + 2 * Math.PI;
      }
    } else {
      if (this.beta > this.upperBetaLimit) {
        this.beta = this.upperBetaLimit;
      }
    }
    if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {
      this.alpha = this.lowerAlphaLimit;
    }
    if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {
      this.alpha = this.upperAlphaLimit;
    }
    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
      this.radius = this.lowerRadiusLimit;
      this.inertialRadiusOffset = 0;
    }
    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
      this.radius = this.upperRadiusLimit;
      this.inertialRadiusOffset = 0;
    }
    this.target.y = Math.max(this.target.y, this.lowerTargetYLimit);
  }
  /**
   * Rebuilds angles (alpha, beta) and radius from the give position and target
   */
  rebuildAnglesAndRadius() {
    this._position.subtractToRef(this._getTargetPosition(), this._computationVector);
    if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
      Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);
    }
    this.radius = this._computationVector.length();
    if (this.radius === 0) {
      this.radius = 1e-4;
    }
    const previousAlpha = this.alpha;
    this.alpha = ComputeAlpha(this._computationVector);
    this.beta = ComputeBeta(this._computationVector.y, this.radius);
    const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2 * Math.PI));
    this.alpha += alphaCorrectionTurns * 2 * Math.PI;
    this._checkLimits();
  }
  /**
   * Use a position to define the current camera related information like alpha, beta and radius
   * @param position Defines the position to set the camera at
   */
  setPosition(position) {
    if (this._position.equals(position)) {
      return;
    }
    this._position.copyFrom(position);
    this.rebuildAnglesAndRadius();
  }
  /**
   * Defines the target the camera should look at.
   * This will automatically adapt alpha beta and radius to fit within the new target.
   * Please note that setting a target as a mesh will disable panning.
   * @param target Defines the new target as a Vector or a transform node
   * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center
   * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)
   * @param cloneAlphaBetaRadius If true, replicate the current setup (alpha, beta, radius) on the new target
   */
  setTarget(target, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false) {
    cloneAlphaBetaRadius = this.overrideCloneAlphaBetaRadius ?? cloneAlphaBetaRadius;
    if (target.computeWorldMatrix) {
      if (toBoundingCenter && target.getBoundingInfo) {
        this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();
      } else {
        this._targetBoundingCenter = null;
      }
      target.computeWorldMatrix();
      this._targetHost = target;
      this._target = this._getTargetPosition();
      this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);
    } else {
      const newTarget = target;
      const currentTarget = this._getTargetPosition();
      if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {
        return;
      }
      this._targetHost = null;
      this._target = newTarget;
      this._targetBoundingCenter = null;
      this.onMeshTargetChangedObservable.notifyObservers(null);
    }
    if (!cloneAlphaBetaRadius) {
      this.rebuildAnglesAndRadius();
    }
  }
  /** @internal */
  _getViewMatrix() {
    const cosa = Math.cos(this.alpha);
    const sina = Math.sin(this.alpha);
    const cosb = Math.cos(this.beta);
    let sinb = Math.sin(this.beta);
    if (sinb === 0) {
      sinb = 1e-4;
    }
    if (this.radius === 0) {
      this.radius = 1e-4;
    }
    const target = this._getTargetPosition();
    this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
    if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
      Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);
    }
    target.addToRef(this._computationVector, this._newPosition);
    if (this.getScene().collisionsEnabled && this.checkCollisions) {
      const coordinator = this.getScene().collisionCoordinator;
      if (!this._collider) {
        this._collider = coordinator.createCollider();
      }
      this._collider._radius = this.collisionRadius;
      this._newPosition.subtractToRef(this._position, this._collisionVelocity);
      this._collisionTriggered = true;
      coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
    } else {
      this._position.copyFrom(this._newPosition);
      let up = this.upVector;
      if (this.allowUpsideDown && sinb < 0) {
        up = up.negate();
      }
      this._computeViewMatrix(this._position, target, up);
      this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
      this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
    }
    this._currentTarget = target;
    return this._viewMatrix;
  }
  /**
   * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.
   * @param meshes Defines the mesh to zoom on
   * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
   */
  zoomOn(meshes, doNotUpdateMaxZ = false) {
    meshes = meshes || this.getScene().meshes;
    const minMaxVector = Mesh.MinMax(meshes);
    let distance = this._calculateLowerRadiusFromModelBoundingSphere(minMaxVector.min, minMaxVector.max);
    distance = Math.max(Math.min(distance, this.upperRadiusLimit || Number.MAX_VALUE), this.lowerRadiusLimit || 0);
    this.radius = distance * this.zoomOnFactor;
    this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance }, doNotUpdateMaxZ);
  }
  /**
   * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.
   * The target will be changed but the radius
   * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on
   * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
   */
  focusOn(meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ = false) {
    let meshesOrMinMaxVector;
    let distance;
    if (meshesOrMinMaxVectorAndDistance.min === void 0) {
      const meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;
      meshesOrMinMaxVector = Mesh.MinMax(meshes);
      distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);
    } else {
      const minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;
      meshesOrMinMaxVector = minMaxVectorAndDistance;
      distance = minMaxVectorAndDistance.distance;
    }
    this._target = Mesh.Center(meshesOrMinMaxVector);
    if (!doNotUpdateMaxZ) {
      this.maxZ = distance * 2;
    }
  }
  /**
   * @override
   * Override Camera.createRigCamera
   * @param name the name of the camera
   * @param cameraIndex the index of the camera in the rig cameras array
   */
  createRigCamera(name, cameraIndex) {
    let alphaShift = 0;
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
      case Camera.RIG_MODE_VR:
        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);
        break;
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);
        break;
    }
    const rigCam = new _ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());
    rigCam._cameraRigParams = {};
    rigCam.isRigCamera = true;
    rigCam.rigParent = this;
    rigCam.upVector = this.upVector;
    rigCam.mode = this.mode;
    rigCam.orthoLeft = this.orthoLeft;
    rigCam.orthoRight = this.orthoRight;
    rigCam.orthoBottom = this.orthoBottom;
    rigCam.orthoTop = this.orthoTop;
    return rigCam;
  }
  /**
   * @internal
   * @override
   * Override Camera._updateRigCameras
   */
  _updateRigCameras() {
    const camLeft = this._rigCameras[0];
    const camRight = this._rigCameras[1];
    camLeft.beta = camRight.beta = this.beta;
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
      case Camera.RIG_MODE_VR:
        camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
        camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
        break;
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
        camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
        camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
        break;
    }
    super._updateRigCameras();
  }
  /**
   * @internal
   */
  _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, radiusScale = 1) {
    const boxVectorGlobalDiagonal = Vector3.Distance(minimumWorld, maximumWorld);
    const engine = this.getScene().getEngine();
    const aspectRatio = engine.getAspectRatio(this);
    const frustumSlopeY = Math.tan(this.fov / 2);
    const frustumSlopeX = frustumSlopeY * aspectRatio;
    const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;
    const radius = radiusWithoutFraming * radiusScale;
    const distanceForHorizontalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlopeX * frustumSlopeX));
    const distanceForVerticalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlopeY * frustumSlopeY));
    return Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);
  }
  /**
   * Destroy the camera and release the current resources hold by it.
   */
  dispose() {
    this.inputs.clear();
    super.dispose();
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "ArcRotateCamera";
  }
};
__decorate([
  serialize()
], ArcRotateCamera.prototype, "alpha", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "beta", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "radius", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "overrideCloneAlphaBetaRadius", void 0);
__decorate([
  serializeAsVector3("target")
], ArcRotateCamera.prototype, "_target", void 0);
__decorate([
  serializeAsMeshReference("targetHost")
], ArcRotateCamera.prototype, "_targetHost", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialAlphaOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialBetaOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialRadiusOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerAlphaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperAlphaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerBetaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperBetaLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerRadiusLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "upperRadiusLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "lowerTargetYLimit", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialPanningX", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "inertialPanningY", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "pinchToPanMaxDistance", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "panningDistanceLimit", void 0);
__decorate([
  serializeAsVector3()
], ArcRotateCamera.prototype, "panningOriginTarget", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "panningInertia", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "zoomToMouseLocation", null);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "zoomOnFactor", void 0);
__decorate([
  serializeAsVector2()
], ArcRotateCamera.prototype, "targetScreenOffset", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "allowUpsideDown", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "useInputToRestoreState", void 0);
__decorate([
  serialize()
], ArcRotateCamera.prototype, "restoreStateInterpolationFactor", void 0);
RegisterClass("BABYLON.ArcRotateCamera", ArcRotateCamera);

export {
  AutoRotationBehavior,
  BouncingBehavior,
  FramingBehavior,
  ArcRotateCameraMouseWheelInput,
  ArcRotateCameraInputsManager,
  ComputeAlpha,
  ComputeBeta,
  ArcRotateCamera
};
//# sourceMappingURL=chunk-QDHBSBOJ.js.map
