{
  "version": 3,
  "sources": ["../../../dev/core/src/Behaviors/Cameras/autoRotationBehavior.ts", "../../../dev/core/src/Behaviors/Cameras/bouncingBehavior.ts", "../../../dev/core/src/Behaviors/Cameras/framingBehavior.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/arcRotateCameraInputsManager.ts", "../../../dev/core/src/Cameras/arcRotateCamera.ts"],
  "sourcesContent": ["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n */\r\nexport class AutoRotationBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"AutoRotation\";\r\n    }\r\n\r\n    private _zoomStopsAnimation = false;\r\n    private _idleRotationSpeed = 0.05;\r\n    private _idleRotationWaitTime = 2000;\r\n    private _idleRotationSpinupTime = 2000;\r\n\r\n    /**\r\n     * Target alpha\r\n     */\r\n    public targetAlpha: Nullable<number> = null;\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the default speed at which the camera rotates around the model.\r\n     */\r\n    public set idleRotationSpeed(speed: number) {\r\n        this._idleRotationSpeed = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the default speed at which the camera rotates around the model.\r\n     */\r\n    public get idleRotationSpeed() {\r\n        return this._idleRotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public set idleRotationWaitTime(time: number) {\r\n        this._idleRotationWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public get idleRotationWaitTime() {\r\n        return this._idleRotationWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public set idleRotationSpinupTime(time: number) {\r\n        this._idleRotationSpinupTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public get idleRotationSpinupTime() {\r\n        return this._idleRotationSpinupTime;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\r\n    public get rotationInProgress(): boolean {\r\n        return Math.abs(this._cameraRotationSpeed) > 0;\r\n    }\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastFrameTime: Nullable<number> = null;\r\n    private _lastInteractionTime = -Infinity;\r\n    private _cameraRotationSpeed: number = 0;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (this._reachTargetAlpha()) {\r\n                return;\r\n            }\r\n            const now = PrecisionDate.Now;\r\n            let dt = 0;\r\n            if (this._lastFrameTime != null) {\r\n                dt = now - this._lastFrameTime;\r\n            }\r\n            this._lastFrameTime = now;\r\n\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\r\n            const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\r\n            this._cameraRotationSpeed = this._idleRotationSpeed * scale;\r\n\r\n            // Step camera rotation by rotation speed\r\n            if (this._attachedCamera) {\r\n                this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n        this._lastFrameTime = null;\r\n    }\r\n\r\n    /**\r\n     * Force-reset the last interaction time\r\n     * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\r\n     */\r\n    public resetLastInteractionTime(customTime?: number): void {\r\n        this._lastInteractionTime = customTime ?? PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Returns true if camera alpha reaches the target alpha\r\n     * @returns true if camera alpha reaches the target alpha\r\n     */\r\n    private _reachTargetAlpha(): boolean {\r\n        if (this._attachedCamera && this.targetAlpha) {\r\n            return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @returns true if user is scrolling.\r\n     */\r\n    private _userIsZooming(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    }\r\n\r\n    private _lastFrameRadius = 0;\r\n    private _shouldAnimationStopForInteraction(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        let zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    }\r\n\r\n    // Tools\r\n    private _userIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n}\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Animatable } from \"../../Animations/animatable.core\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n */\r\nexport class BouncingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Bouncing\";\r\n    }\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new BackEase(0.3);\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n\r\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\r\n    public transitionDuration = 450;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\r\n    public lowerRadiusTransitionRange = 2;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\r\n    public upperRadiusTransitionRange = -2;\r\n\r\n    private _autoTransitionRange = false;\r\n\r\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\r\n    public get autoTransitionRange(): boolean {\r\n        return this._autoTransitionRange;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\r\n    public set autoTransitionRange(value: boolean) {\r\n        if (this._autoTransitionRange === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoTransitionRange = value;\r\n\r\n        const camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {\r\n                if (!transformNode) {\r\n                    return;\r\n                }\r\n\r\n                transformNode.computeWorldMatrix(true);\r\n                if ((transformNode as AbstractMesh).getBoundingInfo) {\r\n                    const diagonal = (transformNode as AbstractMesh).getBoundingInfo().diagonalLength;\r\n\r\n                    this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                    this.upperRadiusTransitionRange = diagonal * 0.05;\r\n                }\r\n            });\r\n        } else if (this._onMeshTargetChangedObserver) {\r\n            camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n    }\r\n\r\n    // Connection\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<TransformNode>>>;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (!this._attachedCamera) {\r\n                return;\r\n            }\r\n\r\n            // Add the bounce animation to the lower radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\r\n            }\r\n\r\n            // Add the bounce animation to the upper radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Animations\r\n    private _radiusIsAnimating: boolean = false;\r\n    private _radiusBounceTransition: Nullable<Animation> = null;\r\n    private _animatables = new Array<Animatable>();\r\n    private _cachedWheelPrecision: number;\r\n\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @returns Bool to indicate if at limit.\r\n     */\r\n    private _isRadiusAtLimit(radiusLimit: Nullable<number>): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    private _applyBoundRadiusAnimation(radiusDelta: number): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        const animatable = Animation.TransitionTo(\r\n            \"radius\",\r\n            this._attachedCamera.radius + radiusDelta,\r\n            this._attachedCamera,\r\n            this._attachedCamera.getScene(),\r\n            60,\r\n            this._radiusBounceTransition,\r\n            this.transitionDuration,\r\n            () => this._clearAnimationLocks()\r\n        );\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    protected _clearAnimationLocks(): void {\r\n        this._radiusIsAnimating = false;\r\n\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n}\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Animatable } from \"../../Animations/animatable.core\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n */\r\nexport class FramingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Framing\";\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the animation to zoom on target mesh has ended\r\n     */\r\n    public onTargetFramingAnimationEndObservable = new Observable<void>();\r\n\r\n    private _mode = FramingBehavior.FitFrustumSidesMode;\r\n    private _radiusScale = 1.0;\r\n    private _positionScale = 0.5;\r\n    private _defaultElevation = 0.3;\r\n    private _elevationReturnTime = 1500;\r\n    private _elevationReturnWaitTime = 1000;\r\n    private _zoomStopsAnimation = false;\r\n    private _framingTime = 1500;\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new ExponentialEase();\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n\r\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\r\n    public set mode(mode: number) {\r\n        this._mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\r\n    public set radiusScale(radius: number) {\r\n        this._radiusScale = radius;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\r\n    public get radiusScale(): number {\r\n        return this._radiusScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public set positionScale(scale: number) {\r\n        this._positionScale = scale;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public get positionScale(): number {\r\n        return this._positionScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public set defaultElevation(elevation: number) {\r\n        this._defaultElevation = elevation;\r\n    }\r\n\r\n    /**\r\n     * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public get defaultElevation() {\r\n        return this._defaultElevation;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public set elevationReturnTime(speed: number) {\r\n        this._elevationReturnTime = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public get elevationReturnTime(): number {\r\n        return this._elevationReturnTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public set elevationReturnWaitTime(time: number) {\r\n        this._elevationReturnWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public get elevationReturnWaitTime(): number {\r\n        return this._elevationReturnWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public set framingTime(time: number) {\r\n        this._framingTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public get framingTime() {\r\n        return this._framingTime;\r\n    }\r\n\r\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\r\n    public autoCorrectCameraLimitsAndSensibility = true;\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<TransformNode>>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastInteractionTime = -Infinity;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {\r\n            if (transformNode && (transformNode as AbstractMesh).getBoundingInfo) {\r\n                this.zoomOnMesh(transformNode as AbstractMesh, undefined, () => {\r\n                    this.onTargetFramingAnimationEndObservable.notifyObservers();\r\n                });\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            this._maintainCameraAboveGround();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Framing control\r\n    private _animatables = new Array<Animatable>();\r\n    private _betaIsAnimating = false;\r\n    private _betaTransition: Animation;\r\n    private _radiusTransition: Animation;\r\n    private _vectorTransition: Animation;\r\n\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     * @returns true if the zoom was done\r\n     */\r\n    public zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): boolean {\r\n        let zoomTarget: Vector3;\r\n\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        const bottom = minimumWorld.y;\r\n        const top = maximumWorld.y;\r\n        const zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n\r\n        if (!isFinite(zoomTargetY)) {\r\n            return false; // Abort mission as there is no target\r\n        }\r\n\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        } else {\r\n            const centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        this._betaIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        let radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            const extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\r\n            this.stopAllAnimations();\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n\r\n            if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\r\n                this._attachedCamera.storeState();\r\n            }\r\n        });\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param minimumWorld\r\n     * @param maximumWorld\r\n     * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number {\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n\r\n        let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    private _maintainCameraAboveGround(): void {\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n\r\n        const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        const limitBeta = Math.PI * 0.5;\r\n\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n\r\n            const animatabe = Animation.TransitionTo(\r\n                \"beta\",\r\n                defaultBeta,\r\n                this._attachedCamera,\r\n                this._attachedCamera.getScene(),\r\n                60,\r\n                this._betaTransition,\r\n                this._elevationReturnTime,\r\n                () => {\r\n                    this._clearAnimationLocks();\r\n                    this.stopAllAnimations();\r\n                }\r\n            );\r\n\r\n            if (animatabe) {\r\n                this._animatables.push(animatabe);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    private _clearAnimationLocks(): void {\r\n        this._betaIsAnimating = false;\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\r\n    public get isUserIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    public static IgnoreBoundsSizeMode = 0;\r\n\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    public static FitFrustumSidesMode = 1;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20; i++) {\r\n                            // 20 iterations should be enough to converge\r\n                            if (estimatedTargetRadius <= targetInertia) {\r\n                                // We do not want a negative radius, so we break out of the loop\r\n                                break;\r\n                            }\r\n                            if (Math.abs(targetInertia * this.camera.inertia) < 0.001) {\r\n                                // We do not want to go below a certain threshold, so we break out of the loop\r\n                                break;\r\n                            }\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n", "import type { ArcRotateCamera } from \"./arcRotateCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: ArcRotateCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n}\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference, serializeAsVector2 } from \"../Misc/decorators\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, TmpVectors, Quaternion } from \"../Maths/math.vector\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AutoRotationBehavior } from \"../Behaviors/Cameras/autoRotationBehavior\";\r\nimport { BouncingBehavior } from \"../Behaviors/Cameras/bouncingBehavior\";\r\nimport { FramingBehavior } from \"../Behaviors/Cameras/framingBehavior\";\r\nimport { Camera } from \"./camera\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport type { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport type { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport type { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nNode.AddNodeConstructor(\"ArcRotateCamera\", (name, scene) => {\r\n    return () => new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * Computes the alpha angle based on the source position and the target position.\r\n * @param offset The directional offset between the source position and the target position\r\n * @returns The alpha angle in radians\r\n */\r\nexport function ComputeAlpha(offset: Vector3): number {\r\n    // Default alpha to π/2 to handle the edge case where x and z are both zero (when looking along up axis)\r\n    let alpha = Math.PI / 2;\r\n    if (!(offset.x === 0 && offset.z === 0)) {\r\n        alpha = Math.acos(offset.x / Math.sqrt(Math.pow(offset.x, 2) + Math.pow(offset.z, 2)));\r\n    }\r\n\r\n    if (offset.z < 0) {\r\n        alpha = 2 * Math.PI - alpha;\r\n    }\r\n\r\n    return alpha;\r\n}\r\n\r\n/**\r\n * Computes the beta angle based on the source position and the target position.\r\n * @param verticalOffset The y value of the directional offset between the source position and the target position\r\n * @param radius The distance between the source position and the target position\r\n * @returns The beta angle in radians\r\n */\r\nexport function ComputeBeta(verticalOffset: number, radius: number): number {\r\n    return Math.acos(verticalOffset / radius);\r\n}\r\n\r\n// Returns the value if not NaN, otherwise returns the fallback value.\r\nfunction checkNaN(value: number, fallback: number): number {\r\n    return isNaN(value) ? fallback : value;\r\n}\r\n\r\n/**\r\n * This represents an orbital type of camera.\r\n *\r\n * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\r\n * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#arc-rotate-camera\r\n */\r\nexport class ArcRotateCamera extends TargetCamera {\r\n    /**\r\n     * Defines the rotation angle of the camera along the longitudinal axis.\r\n     */\r\n    @serialize()\r\n    public alpha: number;\r\n\r\n    /**\r\n     * Defines the rotation angle of the camera along the latitudinal axis.\r\n     */\r\n    @serialize()\r\n    public beta: number;\r\n\r\n    /**\r\n     * Defines the radius of the camera from its target point.\r\n     */\r\n    @serialize()\r\n    public radius: number;\r\n\r\n    /**\r\n     * Defines an override value to use as the parameter to setTarget.\r\n     * This allows the parameter to be specified when animating the target (e.g. using FramingBehavior).\r\n     */\r\n    @serialize()\r\n    public overrideCloneAlphaBetaRadius: Nullable<boolean>;\r\n\r\n    @serializeAsVector3(\"target\")\r\n    protected _target: Vector3;\r\n    @serializeAsMeshReference(\"targetHost\")\r\n    protected _targetHost: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it from the radius distance.\r\n     */\r\n    public override get target(): Vector3 {\r\n        return this._target;\r\n    }\r\n    public override set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Defines the target transform node of the camera.\r\n     * The camera looks towards it from the radius distance.\r\n     * Please note that setting a target host will disable panning.\r\n     */\r\n    public get targetHost(): Nullable<TransformNode> {\r\n        return this._targetHost;\r\n    }\r\n    public set targetHost(value: Nullable<TransformNode>) {\r\n        if (value) {\r\n            this.setTarget(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public override getTarget(): Vector3 {\r\n        return this.target;\r\n    }\r\n\r\n    /**\r\n     * Define the current local position of the camera in the scene\r\n     */\r\n    public override get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public override set position(newPosition: Vector3) {\r\n        this.setPosition(newPosition);\r\n    }\r\n\r\n    protected _upToYMatrix: Matrix;\r\n    protected _yToUpMatrix: Matrix;\r\n\r\n    /**\r\n     * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.\r\n     * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.\r\n     */\r\n    override set upVector(vec: Vector3) {\r\n        if (!this._upToYMatrix) {\r\n            this._yToUpMatrix = new Matrix();\r\n            this._upToYMatrix = new Matrix();\r\n\r\n            this._upVector = Vector3.Zero();\r\n        }\r\n\r\n        vec.normalize();\r\n        this._upVector.copyFrom(vec);\r\n        this.setMatUp();\r\n    }\r\n\r\n    override get upVector() {\r\n        return this._upVector;\r\n    }\r\n\r\n    /**\r\n     * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.\r\n     */\r\n    public setMatUp() {\r\n        // from y-up to custom-up (used in _getViewMatrix)\r\n        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);\r\n\r\n        // from custom-up to y-up (used in rebuildAnglesAndRadius)\r\n        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);\r\n    }\r\n\r\n    /**\r\n     * Current inertia value on the longitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialAlphaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the latitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialBetaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the radius axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialRadiusOffset = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Minimum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerBetaLimit: Nullable<number> = 0.01;\r\n\r\n    /**\r\n     * Maximum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperBetaLimit: Nullable<number> = Math.PI - 0.01;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the target (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the target (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Minimum allowed vertical target position of the camera.\r\n     * Use this setting in combination with `upperRadiusLimit` to set a global limit for the Cameras vertical position.\r\n     */\r\n    @serialize()\r\n    public lowerTargetYLimit: number = -Infinity;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the X axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningX: number = 0;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the Y axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningY: number = 0;\r\n\r\n    /**\r\n     * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\r\n     * Basically if your fingers moves away from more than this distance you will be considered\r\n     * in pinch mode.\r\n     */\r\n    @serialize()\r\n    public pinchToPanMaxDistance: number = 20;\r\n\r\n    /**\r\n     * Defines the maximum distance the camera can pan.\r\n     * This could help keeping the camera always in your scene.\r\n     */\r\n    @serialize()\r\n    public panningDistanceLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Defines the target of the camera before panning.\r\n     */\r\n    @serializeAsVector3()\r\n    public panningOriginTarget: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Defines the value of the inertia used during panning.\r\n     * 0 would mean stop inertia and one would mean no deceleration at all.\r\n     */\r\n    @serialize()\r\n    public panningInertia = 0.9;\r\n\r\n    //-- begin properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityX(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityX;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityX(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityX = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityY(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityY;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityY(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityY = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    public get pinchPrecision(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchPrecision(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\r\n    public get pinchDeltaPercentage(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchDeltaPercentage(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer use natural pinch zoom to override the pinch precision\r\n     * and pinch delta percentage.\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     */\r\n    public get useNaturalPinchZoom(): boolean {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.useNaturalPinchZoom;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set useNaturalPinchZoom(value: boolean) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.useNaturalPinchZoom = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    public get panningSensibility(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.panningSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set panningSensibility(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.panningSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    public get wheelPrecision(): number {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelPrecision(value: number) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public get zoomToMouseLocation(): boolean {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.zoomToMouseLocation;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set zoomToMouseLocation(value: boolean) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.zoomToMouseLocation = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel zoom is used.\r\n     */\r\n    public get wheelDeltaPercentage(): number {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelDeltaPercentage(value: number) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    //-- end properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Defines how much the radius should be scaled while zooming on a particular mesh (through the zoomOn function)\r\n     */\r\n    @serialize()\r\n    public zoomOnFactor = 1;\r\n\r\n    /**\r\n     * Defines a screen offset for the camera position.\r\n     */\r\n    @serializeAsVector2()\r\n    public targetScreenOffset = Vector2.Zero();\r\n\r\n    /**\r\n     * Allows the camera to be completely reversed.\r\n     * If false the camera can not arrive upside down.\r\n     */\r\n    @serialize()\r\n    public allowUpsideDown = true;\r\n\r\n    /**\r\n     * Define if double tap/click is used to restore the previously saved state of the camera.\r\n     */\r\n    @serialize()\r\n    public useInputToRestoreState = true;\r\n\r\n    /**\r\n     * Factor for restoring information interpolation. default is 0 = off. Any value \\< 0 or \\> 1 will disable interpolation.\r\n     */\r\n    @serialize()\r\n    public restoreStateInterpolationFactor = 0;\r\n\r\n    private _currentInterpolationFactor = 0;\r\n\r\n    /** @internal */\r\n    public override _viewMatrix = new Matrix();\r\n    /** @internal */\r\n    public _useCtrlForPanning: boolean;\r\n    /** @internal */\r\n    public _panningMouseButton: number;\r\n\r\n    /**\r\n     * Defines the input associated to the camera.\r\n     */\r\n    public override inputs: ArcRotateCameraInputsManager;\r\n\r\n    /** @internal */\r\n    public override _reset: () => void;\r\n\r\n    /**\r\n     * Defines the allowed panning axis.\r\n     */\r\n    public panningAxis: Vector3 = new Vector3(1, 1, 0);\r\n    protected _transformedDirection: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * Defines if camera will eliminate transform on y axis.\r\n     */\r\n    public mapPanning: boolean = false;\r\n\r\n    // Behaviors\r\n    private _bouncingBehavior: Nullable<BouncingBehavior>;\r\n\r\n    // This is redundant with all _goal* properties being NaN, but we track it anyway because we check for active interpolation in the hot path.\r\n    private _isInterpolating = false;\r\n\r\n    /**\r\n     * If true, indicates the camera is currently interpolating to a new pose.\r\n     */\r\n    public get isInterpolating(): boolean {\r\n        return this._isInterpolating;\r\n    }\r\n\r\n    /**\r\n     * Gets the bouncing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n     */\r\n    public get bouncingBehavior(): Nullable<BouncingBehavior> {\r\n        return this._bouncingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the bouncing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n     */\r\n    public get useBouncingBehavior(): boolean {\r\n        return this._bouncingBehavior != null;\r\n    }\r\n\r\n    public set useBouncingBehavior(value: boolean) {\r\n        if (value === this.useBouncingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._bouncingBehavior = new BouncingBehavior();\r\n            this.addBehavior(this._bouncingBehavior);\r\n        } else if (this._bouncingBehavior) {\r\n            this.removeBehavior(this._bouncingBehavior);\r\n            this._bouncingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _framingBehavior: Nullable<FramingBehavior>;\r\n\r\n    /**\r\n     * Gets the framing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n     */\r\n    public get framingBehavior(): Nullable<FramingBehavior> {\r\n        return this._framingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the framing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n     */\r\n    public get useFramingBehavior(): boolean {\r\n        return this._framingBehavior != null;\r\n    }\r\n\r\n    public set useFramingBehavior(value: boolean) {\r\n        if (value === this.useFramingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._framingBehavior = new FramingBehavior();\r\n            this.addBehavior(this._framingBehavior);\r\n        } else if (this._framingBehavior) {\r\n            this.removeBehavior(this._framingBehavior);\r\n            this._framingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _autoRotationBehavior: Nullable<AutoRotationBehavior>;\r\n\r\n    /**\r\n     * Gets the auto rotation behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n     */\r\n    public get autoRotationBehavior(): Nullable<AutoRotationBehavior> {\r\n        return this._autoRotationBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the auto rotation behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n     */\r\n    public get useAutoRotationBehavior(): boolean {\r\n        return this._autoRotationBehavior != null;\r\n    }\r\n\r\n    public set useAutoRotationBehavior(value: boolean) {\r\n        if (value === this.useAutoRotationBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._autoRotationBehavior = new AutoRotationBehavior();\r\n            this.addBehavior(this._autoRotationBehavior);\r\n        } else if (this._autoRotationBehavior) {\r\n            this.removeBehavior(this._autoRotationBehavior);\r\n            this._autoRotationBehavior = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable triggered when the transform node target has been changed on the camera.\r\n     */\r\n    public onMeshTargetChangedObservable = new Observable<Nullable<TransformNode>>();\r\n\r\n    /**\r\n     * Event raised when the camera is colliding with a mesh.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Defines whether the camera should check collision with the objects oh the scene.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#how-can-i-do-this-\r\n     */\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Defines the collision radius of the camera.\r\n     * This simulates a sphere around the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    public collisionRadius = new Vector3(0.5, 0.5, 0.5);\r\n\r\n    protected _collider: Collider;\r\n    protected _previousPosition = Vector3.Zero();\r\n    protected _collisionVelocity = Vector3.Zero();\r\n    protected _newPosition = Vector3.Zero();\r\n    protected _previousAlpha: number;\r\n    protected _previousBeta: number;\r\n    protected _previousRadius: number;\r\n    //due to async collision inspection\r\n    protected _collisionTriggered: boolean;\r\n\r\n    protected _targetBoundingCenter: Nullable<Vector3>;\r\n\r\n    private _computationVector: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Instantiates a new ArcRotateCamera in a given scene\r\n     * @param name Defines the name of the camera\r\n     * @param alpha Defines the camera rotation along the longitudinal axis\r\n     * @param beta Defines the camera rotation along the latitudinal axis\r\n     * @param radius Defines the camera distance from its target\r\n     * @param target Defines the camera target\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);\r\n\r\n        this._target = Vector3.Zero();\r\n        if (target) {\r\n            this.setTarget(target);\r\n        }\r\n\r\n        this.alpha = alpha;\r\n        this.beta = beta;\r\n        this.radius = radius;\r\n\r\n        this.getViewMatrix();\r\n        this.inputs = new ArcRotateCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n    }\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public override _initCache(): void {\r\n        super._initCache();\r\n        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.alpha = undefined;\r\n        this._cache.beta = undefined;\r\n        this._cache.radius = undefined;\r\n        this._cache.targetScreenOffset = Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        this._cache._target.copyFrom(this._getTargetPosition());\r\n        this._cache.alpha = this.alpha;\r\n        this._cache.beta = this.beta;\r\n        this._cache.radius = this.radius;\r\n        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\r\n    }\r\n\r\n    protected _getTargetPosition(): Vector3 {\r\n        if (this._targetHost && this._targetHost.getAbsolutePosition) {\r\n            const pos: Vector3 = this._targetHost.getAbsolutePosition();\r\n            if (this._targetBoundingCenter) {\r\n                pos.addToRef(this._targetBoundingCenter, this._target);\r\n            } else {\r\n                this._target.copyFrom(pos);\r\n            }\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        if (lockedTargetPosition) {\r\n            return lockedTargetPosition;\r\n        }\r\n\r\n        return this._target;\r\n    }\r\n\r\n    private _storedAlpha: number;\r\n    private _storedBeta: number;\r\n    private _storedRadius: number;\r\n    private _storedTarget: Vector3;\r\n    private _storedTargetScreenOffset: Vector2;\r\n\r\n    private _goalAlpha = NaN;\r\n    private _goalBeta = NaN;\r\n    private _goalRadius = NaN;\r\n    private readonly _goalTarget = new Vector3(NaN, NaN, NaN);\r\n    private readonly _goalTargetScreenOffset = new Vector2(NaN, NaN);\r\n\r\n    /**\r\n     * Stores the current state of the camera (alpha, beta, radius and target)\r\n     * @returns the camera itself\r\n     */\r\n    public override storeState(): Camera {\r\n        this._storedAlpha = this.alpha;\r\n        this._storedBeta = this.beta;\r\n        this._storedRadius = this.radius;\r\n        this._storedTarget = this._getTargetPosition().clone();\r\n        this._storedTargetScreenOffset = this.targetScreenOffset.clone();\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Restored camera state. You must call storeState() first\r\n     */\r\n    public override _restoreStateValues(): boolean {\r\n        if (this.hasStateStored() && this.restoreStateInterpolationFactor > Epsilon && this.restoreStateInterpolationFactor < 1) {\r\n            this.interpolateTo(this._storedAlpha, this._storedBeta, this._storedRadius, this._storedTarget, this._storedTargetScreenOffset, this.restoreStateInterpolationFactor);\r\n            return true;\r\n        }\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.setTarget(this._storedTarget.clone());\r\n        this.alpha = this._storedAlpha;\r\n        this.beta = this._storedBeta;\r\n        this.radius = this._storedRadius;\r\n        this.targetScreenOffset = this._storedTargetScreenOffset.clone();\r\n\r\n        this.inertialAlphaOffset = 0;\r\n        this.inertialBetaOffset = 0;\r\n        this.inertialRadiusOffset = 0;\r\n        this.inertialPanningX = 0;\r\n        this.inertialPanningY = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Stops any in-progress interpolation.\r\n     */\r\n    public stopInterpolation(): void {\r\n        this._goalAlpha = NaN;\r\n        this._goalBeta = NaN;\r\n        this._goalRadius = NaN;\r\n        this._goalTarget.set(NaN, NaN, NaN);\r\n        this._goalTargetScreenOffset.set(NaN, NaN);\r\n    }\r\n\r\n    /**\r\n     * Interpolates the camera to a goal state.\r\n     * @param alpha Defines the goal alpha.\r\n     * @param beta Defines the goal beta.\r\n     * @param radius Defines the goal radius.\r\n     * @param target Defines the goal target.\r\n     * @param targetScreenOffset Defines the goal target screen offset.\r\n     * @param interpolationFactor A value  between 0 and 1 that determines the speed of the interpolation.\r\n     * @remarks Passing undefined for any of the parameters will use the current value (effectively stopping any in-progress interpolation for that parameter).\r\n     *          Passing NaN will not start or stop any interpolation for that parameter (effectively allowing multiple interpolations of different parameters to overlap).\r\n     */\r\n    public interpolateTo(\r\n        alpha = this.alpha,\r\n        beta = this.beta,\r\n        radius = this.radius,\r\n        target = this.target,\r\n        targetScreenOffset = this.targetScreenOffset,\r\n        interpolationFactor?: number\r\n    ): void {\r\n        this.inertialAlphaOffset = 0;\r\n        this.inertialBetaOffset = 0;\r\n        this.inertialRadiusOffset = 0;\r\n        this.inertialPanningX = 0;\r\n        this.inertialPanningY = 0;\r\n\r\n        if (interpolationFactor != null) {\r\n            this._currentInterpolationFactor = interpolationFactor;\r\n        } else if (this.restoreStateInterpolationFactor !== 0) {\r\n            this._currentInterpolationFactor = this.restoreStateInterpolationFactor;\r\n        } else {\r\n            this._currentInterpolationFactor = 0.1;\r\n        }\r\n\r\n        // If NaN is passed in for a goal value, keep the current goal value.\r\n        this._goalAlpha = checkNaN(alpha, this._goalAlpha);\r\n        this._goalBeta = checkNaN(beta, this._goalBeta);\r\n        this._goalRadius = checkNaN(radius, this._goalRadius);\r\n        this._goalTarget.set(checkNaN(target.x, this._goalTarget.x), checkNaN(target.y, this._goalTarget.y), checkNaN(target.z, this._goalTarget.z));\r\n        this._goalTargetScreenOffset.set(checkNaN(targetScreenOffset.x, this._goalTargetScreenOffset.x), checkNaN(targetScreenOffset.y, this._goalTargetScreenOffset.y));\r\n\r\n        this._goalAlpha = Clamp(this._goalAlpha, this.lowerAlphaLimit ?? -Infinity, this.upperAlphaLimit ?? Infinity);\r\n        this._goalBeta = Clamp(this._goalBeta, this.lowerBetaLimit ?? -Infinity, this.upperBetaLimit ?? Infinity);\r\n        this._goalRadius = Clamp(this._goalRadius, this.lowerRadiusLimit ?? -Infinity, this.upperRadiusLimit ?? Infinity);\r\n        this._goalTarget.y = Clamp(this._goalTarget.y, this.lowerTargetYLimit ?? -Infinity, Infinity);\r\n\r\n        this._isInterpolating = true;\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public override _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._cache._target.equals(this._getTargetPosition()) &&\r\n            this._cache.alpha === this.alpha &&\r\n            this._cache.beta === this.beta &&\r\n            this._cache.radius === this.radius &&\r\n            this._cache.targetScreenOffset.equals(this.targetScreenOffset)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     */\r\n    public override attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public override attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean, panningMouseButton: number): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault?: boolean, useCtrlForPanning: boolean | number = true, panningMouseButton: number = 2): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        const args = arguments;\r\n\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);\r\n        this._useCtrlForPanning = useCtrlForPanning as boolean;\r\n        this._panningMouseButton = panningMouseButton;\r\n        // backwards compatibility\r\n        if (typeof args[0] === \"boolean\") {\r\n            if (args.length > 1) {\r\n                this._useCtrlForPanning = args[1];\r\n            }\r\n            if (args.length > 2) {\r\n                this._panningMouseButton = args[2];\r\n            }\r\n        }\r\n\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {\r\n            this.inertialAlphaOffset = 0;\r\n            this.inertialBetaOffset = 0;\r\n            this.inertialRadiusOffset = 0;\r\n            this.inertialPanningX = 0;\r\n            this.inertialPanningY = 0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public override detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\r\n        if (this._collisionTriggered) {\r\n            return;\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        let hasUserInteractions = false;\r\n\r\n        // Inertia\r\n        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\r\n            hasUserInteractions = true;\r\n\r\n            const directionModifier = this.invertRotation ? -1 : 1;\r\n            const handednessMultiplier = this._calculateHandednessMultiplier();\r\n            let inertialAlphaOffset = this.inertialAlphaOffset * handednessMultiplier;\r\n\r\n            if (this.beta < 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n\r\n            this.alpha += inertialAlphaOffset * directionModifier;\r\n            this.beta += this.inertialBetaOffset * directionModifier;\r\n\r\n            this.radius -= this.inertialRadiusOffset;\r\n            this.inertialAlphaOffset *= this.inertia;\r\n            this.inertialBetaOffset *= this.inertia;\r\n            this.inertialRadiusOffset *= this.inertia;\r\n            if (Math.abs(this.inertialAlphaOffset) < Epsilon) {\r\n                this.inertialAlphaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialBetaOffset) < Epsilon) {\r\n                this.inertialBetaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {\r\n                this.inertialRadiusOffset = 0;\r\n            }\r\n        }\r\n\r\n        // Panning inertia\r\n        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\r\n            hasUserInteractions = true;\r\n\r\n            const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\r\n\r\n            this._viewMatrix.invertToRef(this._cameraTransformMatrix);\r\n            localDirection.multiplyInPlace(this.panningAxis);\r\n            Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);\r\n\r\n            // If mapPanning is enabled, we need to take the upVector into account and\r\n            // make sure we're not panning in the y direction\r\n            if (this.mapPanning) {\r\n                const up = this.upVector;\r\n                const right = Vector3.CrossToRef(this._transformedDirection, up, this._transformedDirection);\r\n                Vector3.CrossToRef(up, right, this._transformedDirection);\r\n            } else if (!this.panningAxis.y) {\r\n                this._transformedDirection.y = 0;\r\n            }\r\n\r\n            if (!this._targetHost) {\r\n                if (this.panningDistanceLimit) {\r\n                    this._transformedDirection.addInPlace(this._target);\r\n                    const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);\r\n                    if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {\r\n                        this._target.copyFrom(this._transformedDirection);\r\n                    }\r\n                } else {\r\n                    if (this.parent) {\r\n                        const m = TmpVectors.Matrix[0];\r\n                        this.parent.getWorldMatrix().getRotationMatrixToRef(m);\r\n                        m.transposeToRef(m);\r\n                        Vector3.TransformCoordinatesToRef(this._transformedDirection, m, this._transformedDirection);\r\n                    }\r\n                    this._target.addInPlace(this._transformedDirection);\r\n                }\r\n            }\r\n\r\n            this.inertialPanningX *= this.panningInertia;\r\n            this.inertialPanningY *= this.panningInertia;\r\n\r\n            if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {\r\n                this.inertialPanningX = 0;\r\n            }\r\n            if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {\r\n                this.inertialPanningY = 0;\r\n            }\r\n        }\r\n\r\n        if (hasUserInteractions) {\r\n            this.stopInterpolation();\r\n        } else if (this._isInterpolating) {\r\n            let isInterpolating = false;\r\n            const dt = this._scene.getEngine().getDeltaTime() / 1000;\r\n            const t = 1 - Math.pow(2, -dt / this._currentInterpolationFactor);\r\n\r\n            // NOTE: If the goal is NaN, it means we are not interpolating to a new value, so we can use the current value. Hence the calls to checkNaN.\r\n\r\n            // Get the goal radius immediately as we'll need it for determining interpolation termination for the target.\r\n            const goalRadius = checkNaN(this._goalRadius, this.radius);\r\n\r\n            // Interpolate the target if we haven't reached the goal yet.\r\n            if (!isNaN(this._goalTarget.x) || !isNaN(this._goalTarget.y) || !isNaN(this._goalTarget.z)) {\r\n                const goalTarget = TmpVectors.Vector3[0].set(\r\n                    checkNaN(this._goalTarget.x, this._target.x),\r\n                    checkNaN(this._goalTarget.y, this._target.y),\r\n                    checkNaN(this._goalTarget.z, this._target.z)\r\n                );\r\n                this.setTarget(Vector3.Lerp(this.target, goalTarget, t), undefined, undefined, true);\r\n\r\n                // Terminate the target interpolation if we the target is close relative to the radius.\r\n                // This is when visually (regardless of scale) the target appears close to its final goal position.\r\n                if ((Vector3.Distance(this.target, goalTarget) * 10) / goalRadius < Epsilon) {\r\n                    this._goalTarget.set(NaN, NaN, NaN);\r\n                    this.setTarget(goalTarget.clone(), undefined, undefined, true);\r\n                } else {\r\n                    isInterpolating = true;\r\n                }\r\n            }\r\n\r\n            // Interpolate the rotation if we haven't reached the goal yet.\r\n            if (!isNaN(this._goalAlpha) || !isNaN(this._goalBeta)) {\r\n                // Using quaternion for smoother interpolation (and no Euler angles modulo)\r\n                const goalRotation = Quaternion.RotationAlphaBetaGammaToRef(\r\n                    checkNaN(this._goalAlpha, this.alpha),\r\n                    checkNaN(this._goalBeta, this.beta),\r\n                    0,\r\n                    TmpVectors.Quaternion[0]\r\n                );\r\n                const currentRotation = Quaternion.RotationAlphaBetaGammaToRef(this.alpha, this.beta, 0, TmpVectors.Quaternion[1]);\r\n                const newRotation = Quaternion.SlerpToRef(currentRotation, goalRotation, t, TmpVectors.Quaternion[2]);\r\n                newRotation.normalize();\r\n                const newAlphaBetaGamma = newRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);\r\n                this.alpha = newAlphaBetaGamma.x;\r\n                this.beta = newAlphaBetaGamma.y;\r\n\r\n                // Terminate the rotation interpolation when the rotation appears visually close to the final goal rotation.\r\n                if (newRotation.isApprox(goalRotation, Epsilon / 5)) {\r\n                    this._goalAlpha = NaN;\r\n                    this._goalBeta = NaN;\r\n                    const goalAlphaBetaGamma = goalRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);\r\n                    this.alpha = goalAlphaBetaGamma.x;\r\n                    this.beta = goalAlphaBetaGamma.y;\r\n                } else {\r\n                    isInterpolating = true;\r\n                }\r\n            }\r\n\r\n            // Interpolate the radius if we haven't reached the goal yet.\r\n            if (!isNaN(this._goalRadius)) {\r\n                this.radius += (goalRadius - this.radius) * t;\r\n\r\n                // Terminate the radius interpolation when we are 99.9% of the way to the goal radius, at which point it is visually indistinguishable from the goal.\r\n                if (Math.abs(goalRadius / this.radius - 1) < Epsilon) {\r\n                    this._goalRadius = NaN;\r\n                    this.radius = goalRadius;\r\n                } else {\r\n                    isInterpolating = true;\r\n                }\r\n            }\r\n\r\n            // Interpolate the target screen offset if we haven't reached the goal yet.\r\n            if (!isNaN(this._goalTargetScreenOffset.x) || !isNaN(this._goalTargetScreenOffset.y)) {\r\n                const goalTargetScreenOffset = TmpVectors.Vector2[0].set(\r\n                    checkNaN(this._goalTargetScreenOffset.x, this.targetScreenOffset.x),\r\n                    checkNaN(this._goalTargetScreenOffset.y, this.targetScreenOffset.y)\r\n                );\r\n                Vector2.LerpToRef(this.targetScreenOffset, goalTargetScreenOffset, t, this.targetScreenOffset);\r\n\r\n                // Terminate the target screen offset interpolation when the target screen offset appears visually close to the final goal target screen offset.\r\n                if (Vector2.Distance(this.targetScreenOffset, goalTargetScreenOffset) < Epsilon) {\r\n                    this._goalTargetScreenOffset.set(NaN, NaN);\r\n                    this.targetScreenOffset.copyFrom(goalTargetScreenOffset);\r\n                } else {\r\n                    isInterpolating = true;\r\n                }\r\n            }\r\n\r\n            this._isInterpolating = isInterpolating;\r\n        }\r\n\r\n        // Limits\r\n        this._checkLimits();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _checkLimits() {\r\n        if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta > Math.PI) {\r\n                this.beta = this.beta - 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta < this.lowerBetaLimit) {\r\n                this.beta = this.lowerBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta < -Math.PI) {\r\n                this.beta = this.beta + 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta > this.upperBetaLimit) {\r\n                this.beta = this.upperBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {\r\n            this.alpha = this.lowerAlphaLimit;\r\n        }\r\n        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {\r\n            this.alpha = this.upperAlphaLimit;\r\n        }\r\n\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n\r\n        this.target.y = Math.max(this.target.y, this.lowerTargetYLimit);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds angles (alpha, beta) and radius from the give position and target\r\n     */\r\n    public rebuildAnglesAndRadius(): void {\r\n        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);\r\n\r\n        // need to rotate to Y up equivalent if up vector not Axis.Y\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);\r\n        }\r\n\r\n        this.radius = this._computationVector.length();\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        // Alpha and Beta\r\n        const previousAlpha = this.alpha;\r\n        this.alpha = ComputeAlpha(this._computationVector);\r\n        this.beta = ComputeBeta(this._computationVector.y, this.radius);\r\n\r\n        // Calculate the number of revolutions between the new and old alpha values.\r\n        const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2.0 * Math.PI));\r\n        // Adjust alpha so that its numerical representation is the closest one to the old value.\r\n        this.alpha += alphaCorrectionTurns * 2.0 * Math.PI;\r\n\r\n        this._checkLimits();\r\n    }\r\n\r\n    /**\r\n     * Use a position to define the current camera related information like alpha, beta and radius\r\n     * @param position Defines the position to set the camera at\r\n     */\r\n    public setPosition(position: Vector3): void {\r\n        if (this._position.equals(position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(position);\r\n\r\n        this.rebuildAnglesAndRadius();\r\n    }\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * This will automatically adapt alpha beta and radius to fit within the new target.\r\n     * Please note that setting a target as a mesh will disable panning.\r\n     * @param target Defines the new target as a Vector or a transform node\r\n     * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center\r\n     * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)\r\n     * @param cloneAlphaBetaRadius If true, replicate the current setup (alpha, beta, radius) on the new target\r\n     */\r\n    public override setTarget(target: TransformNode | Vector3, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false): void {\r\n        cloneAlphaBetaRadius = this.overrideCloneAlphaBetaRadius ?? cloneAlphaBetaRadius;\r\n\r\n        if ((target as TransformNode).computeWorldMatrix) {\r\n            if (toBoundingCenter && (<any>target).getBoundingInfo) {\r\n                this._targetBoundingCenter = (<any>target).getBoundingInfo().boundingBox.centerWorld.clone();\r\n            } else {\r\n                this._targetBoundingCenter = null;\r\n            }\r\n            (<TransformNode>target).computeWorldMatrix();\r\n            this._targetHost = <TransformNode>target;\r\n            this._target = this._getTargetPosition();\r\n\r\n            this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);\r\n        } else {\r\n            const newTarget = <Vector3>target;\r\n            const currentTarget = this._getTargetPosition();\r\n            if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\r\n                return;\r\n            }\r\n            this._targetHost = null;\r\n            this._target = newTarget;\r\n            this._targetBoundingCenter = null;\r\n            this.onMeshTargetChangedObservable.notifyObservers(null);\r\n        }\r\n\r\n        if (!cloneAlphaBetaRadius) {\r\n            this.rebuildAnglesAndRadius();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _getViewMatrix(): Matrix {\r\n        // Compute\r\n        const cosa = Math.cos(this.alpha);\r\n        const sina = Math.sin(this.alpha);\r\n        const cosb = Math.cos(this.beta);\r\n        let sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        const target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n\r\n        // Rotate according to up vector\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);\r\n        }\r\n\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        if (this.getScene().collisionsEnabled && this.checkCollisions) {\r\n            const coordinator = this.getScene().collisionCoordinator;\r\n            if (!this._collider) {\r\n                this._collider = coordinator.createCollider();\r\n            }\r\n            this._collider._radius = this.collisionRadius;\r\n            this._newPosition.subtractToRef(this._position, this._collisionVelocity);\r\n            this._collisionTriggered = true;\r\n            coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n        } else {\r\n            this._position.copyFrom(this._newPosition);\r\n\r\n            let up = this.upVector;\r\n            if (this.allowUpsideDown && sinb < 0) {\r\n                up = up.negate();\r\n            }\r\n\r\n            this._computeViewMatrix(this._position, target, up);\r\n\r\n            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n        }\r\n        this._currentTarget = target;\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        if (!collidedMesh) {\r\n            this._previousPosition.copyFrom(this._position);\r\n        } else {\r\n            this.setPosition(newPosition);\r\n\r\n            if (this.onCollide) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n\r\n        // Recompute because of constraints\r\n        const cosa = Math.cos(this.alpha);\r\n        const sina = Math.sin(this.alpha);\r\n        const cosb = Math.cos(this.beta);\r\n        let sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        const target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        this._position.copyFrom(this._newPosition);\r\n\r\n        let up = this.upVector;\r\n        if (this.allowUpsideDown && this.beta < 0) {\r\n            up = up.clone();\r\n            up = up.negate();\r\n        }\r\n\r\n        this._computeViewMatrix(this._position, target, up);\r\n        this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n        this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n\r\n        this._collisionTriggered = false;\r\n    };\r\n\r\n    /**\r\n     * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.\r\n     * @param meshes Defines the mesh to zoom on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public zoomOn(meshes?: AbstractMesh[], doNotUpdateMaxZ = false): void {\r\n        meshes = meshes || this.getScene().meshes;\r\n\r\n        const minMaxVector = Mesh.MinMax(meshes);\r\n        let distance = this._calculateLowerRadiusFromModelBoundingSphere(minMaxVector.min, minMaxVector.max);\r\n\r\n        // If there are defined limits, we need to take them into account\r\n        distance = Math.max(Math.min(distance, this.upperRadiusLimit || Number.MAX_VALUE), this.lowerRadiusLimit || 0);\r\n        this.radius = distance * this.zoomOnFactor;\r\n\r\n        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);\r\n    }\r\n\r\n    /**\r\n     * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.\r\n     * The target will be changed but the radius\r\n     * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public focusOn(meshesOrMinMaxVectorAndDistance: AbstractMesh[] | { min: Vector3; max: Vector3; distance: number }, doNotUpdateMaxZ = false): void {\r\n        let meshesOrMinMaxVector: { min: Vector3; max: Vector3 };\r\n        let distance: number;\r\n\r\n        if ((<any>meshesOrMinMaxVectorAndDistance).min === undefined) {\r\n            // meshes\r\n            const meshes = <AbstractMesh[]>meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\r\n            meshesOrMinMaxVector = Mesh.MinMax(meshes);\r\n            distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\r\n        } else {\r\n            //minMaxVector and distance\r\n            const minMaxVectorAndDistance = <any>meshesOrMinMaxVectorAndDistance;\r\n            meshesOrMinMaxVector = minMaxVectorAndDistance;\r\n            distance = minMaxVectorAndDistance.distance;\r\n        }\r\n\r\n        this._target = Mesh.Center(meshesOrMinMaxVector);\r\n\r\n        if (!doNotUpdateMaxZ) {\r\n            this.maxZ = distance * 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     * Override Camera.createRigCamera\r\n     * @param name the name of the camera\r\n     * @param cameraIndex the index of the camera in the rig cameras array\r\n     */\r\n    public override createRigCamera(name: string, cameraIndex: number): Camera {\r\n        let alphaShift: number = 0;\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\r\n                break;\r\n        }\r\n        const rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\r\n        rigCam._cameraRigParams = {};\r\n        rigCam.isRigCamera = true;\r\n        rigCam.rigParent = this;\r\n        rigCam.upVector = this.upVector;\r\n\r\n        rigCam.mode = this.mode;\r\n        rigCam.orthoLeft = this.orthoLeft;\r\n        rigCam.orthoRight = this.orthoRight;\r\n        rigCam.orthoBottom = this.orthoBottom;\r\n        rigCam.orthoTop = this.orthoTop;\r\n\r\n        return rigCam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @override\r\n     * Override Camera._updateRigCameras\r\n     */\r\n    public override _updateRigCameras() {\r\n        const camLeft = <ArcRotateCamera>this._rigCameras[0];\r\n        const camRight = <ArcRotateCamera>this._rigCameras[1];\r\n\r\n        camLeft.beta = camRight.beta = this.beta;\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3, radiusScale: number = 1): number {\r\n        const boxVectorGlobalDiagonal = Vector3.Distance(minimumWorld, maximumWorld);\r\n\r\n        // Get aspect ratio in order to calculate frustum slope\r\n        const engine = this.getScene().getEngine();\r\n        const aspectRatio = engine.getAspectRatio(this);\r\n        const frustumSlopeY = Math.tan(this.fov / 2);\r\n        const frustumSlopeX = frustumSlopeY * aspectRatio;\r\n\r\n        // Formula for setting distance\r\n        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\r\n        const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\r\n\r\n        // Horizon distance\r\n        const radius = radiusWithoutFraming * radiusScale;\r\n        const distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlopeX * frustumSlopeX));\r\n        const distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlopeY * frustumSlopeY));\r\n        return Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public override dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ArcRotateCamera\";\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.ArcRotateCamera\", ArcRotateCamera);\r\n"],
  "mappings": "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",
  "names": ["target"]
}
