{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/streamingSound.ts", "../../../dev/core/src/AudioV2/abstractAudio/streamingSoundInstance.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioStreamingSound.ts"],
  "sourcesContent": ["import { SoundState } from \"../soundState\";\nimport type { IAbstractSoundOptions, IAbstractSoundPlayOptions, IAbstractSoundStoredOptions } from \"./abstractSound\";\nimport { AbstractSound } from \"./abstractSound\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { _StreamingSoundInstance } from \"./streamingSoundInstance\";\n\n/** @internal */\nexport interface IStreamingSoundOptionsBase {\n    /**\n     * The number of instances to preload. Defaults to 1.\n     * */\n    preloadCount: number;\n}\n\n/**\n * Options for creating a streaming sound.\n */\nexport interface IStreamingSoundOptions extends IAbstractSoundOptions, IStreamingSoundOptionsBase {}\n\n/**\n * Options for playing a streaming sound.\n */\nexport interface IStreamingSoundPlayOptions extends IAbstractSoundPlayOptions {}\n\n/**\n * Options stored in a streaming sound.\n * @internal\n */\nexport interface IStreamingSoundStoredOptions extends IAbstractSoundStoredOptions, IStreamingSoundOptionsBase {}\n\n/**\n * Abstract class representing a streaming sound.\n *\n * A streaming sound has a sound buffer that is loaded into memory in chunks as it is played. This allows it to be played\n * more quickly than a static sound, but it also means that it cannot have loop points or playback rate changes.\n *\n * Due to the way streaming sounds are typically implemented, there can be a significant delay when attempting to play\n * a streaming sound for the first time. To prevent this delay, it is recommended to preload instances of the sound\n * using the {@link IStreamingSoundStoredOptions.preloadCount} options, or the {@link preloadInstanceAsync} and\n * {@link preloadInstancesAsync} methods before calling the `play` method.\n *\n * Streaming sounds are created by the {@link CreateStreamingSoundAsync} function.\n */\nexport abstract class StreamingSound extends AbstractSound {\n    private _preloadedInstances = new Array<_StreamingSoundInstance>();\n\n    protected abstract override readonly _options: IStreamingSoundStoredOptions;\n\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine);\n    }\n\n    /**\n     * The number of instances to preload. Defaults to `1`.\n     */\n    public get preloadCount(): number {\n        return this._options.preloadCount ?? 1;\n    }\n\n    /**\n     * Returns the number of instances that have been preloaded.\n     */\n    public get preloadCompletedCount(): number {\n        return this._preloadedInstances.length;\n    }\n\n    /**\n     * Preloads an instance of the sound.\n     * @returns A promise that resolves when the instance is preloaded.\n     */\n    public preloadInstanceAsync(): Promise<void> {\n        const instance = this._createInstance();\n\n        this._addPreloadedInstance(instance);\n\n        return instance.preloadedPromise;\n    }\n\n    /**\n     * Preloads the given number of instances of the sound.\n     * @param count - The number of instances to preload.\n     * @returns A promise that resolves when all instances are preloaded.\n     */\n    public async preloadInstancesAsync(count: number): Promise<void> {\n        for (let i = 0; i < count; i++) {\n            this.preloadInstanceAsync();\n        }\n\n        await Promise.all(this._preloadedInstances.map((instance) => instance.preloadedPromise));\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public play(options: Partial<IStreamingSoundPlayOptions> = {}): void {\n        if (this.state === SoundState.Paused) {\n            this.resume();\n            return;\n        }\n\n        let instance: _StreamingSoundInstance;\n\n        if (this.preloadCompletedCount > 0) {\n            instance = this._preloadedInstances[0];\n            instance.startOffset = this.startOffset;\n            this._removePreloadedInstance(instance);\n        } else {\n            instance = this._createInstance();\n        }\n\n        const onInstanceStateChanged = () => {\n            if (instance.state === SoundState.Started) {\n                this._stopExcessInstances();\n                instance.onStateChangedObservable.removeCallback(onInstanceStateChanged);\n            }\n        };\n        instance.onStateChangedObservable.add(onInstanceStateChanged);\n\n        options.startOffset ??= this.startOffset;\n        options.loop ??= this.loop;\n        options.volume ??= 1;\n\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n    }\n\n    /**\n     * Stops the sound.\n     */\n    public stop(): void {\n        this._setState(SoundState.Stopped);\n\n        if (!this._instances) {\n            return;\n        }\n\n        for (const instance of Array.from(this._instances)) {\n            instance.stop();\n        }\n    }\n\n    protected abstract override _createInstance(): _StreamingSoundInstance;\n\n    private _addPreloadedInstance(instance: _StreamingSoundInstance): void {\n        if (!this._preloadedInstances.includes(instance)) {\n            this._preloadedInstances.push(instance);\n        }\n    }\n\n    private _removePreloadedInstance(instance: _StreamingSoundInstance): void {\n        const index = this._preloadedInstances.indexOf(instance);\n        if (index !== -1) {\n            this._preloadedInstances.splice(index, 1);\n        }\n    }\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport type { IAbstractSoundInstanceOptions } from \"./abstractSoundInstance\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { IStreamingSoundOptionsBase, StreamingSound } from \"./streamingSound\";\n\n/**\n * Options for creating streaming sound instance.\n * @internal\n */\nexport interface IStreamingSoundInstanceOptions extends IAbstractSoundInstanceOptions, IStreamingSoundOptionsBase {}\n\n/** @internal */\nexport abstract class _StreamingSoundInstance extends _AbstractSoundInstance {\n    private _rejectPreloadedProimse: (reason?: any) => void;\n    private _resolvePreloadedPromise: () => void;\n\n    protected abstract override readonly _options: IStreamingSoundInstanceOptions;\n\n    /** @internal */\n    public readonly onReadyObservable = new Observable<_StreamingSoundInstance>();\n\n    /** @internal */\n    public readonly preloadedPromise = new Promise<void>((resolve, reject) => {\n        this._rejectPreloadedProimse = reject;\n        this._resolvePreloadedPromise = resolve;\n    });\n\n    protected constructor(sound: StreamingSound) {\n        super(sound);\n\n        this.onErrorObservable.add(this._rejectPreloadedProimse);\n        this.onReadyObservable.add(this._resolvePreloadedPromise);\n    }\n\n    /** @internal */\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.onErrorObservable.clear();\n        this.onReadyObservable.clear();\n\n        this._resolvePreloadedPromise();\n    }\n}\n", "import { Logger } from \"../../Misc/logger\";\nimport { Tools } from \"../../Misc/tools\";\nimport type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type {} from \"../abstractAudio/abstractSound\";\nimport type { IStreamingSoundOptions, IStreamingSoundPlayOptions, IStreamingSoundStoredOptions } from \"../abstractAudio/streamingSound\";\nimport { StreamingSound } from \"../abstractAudio/streamingSound\";\nimport { _StreamingSoundInstance } from \"../abstractAudio/streamingSoundInstance\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport type { _SpatialAudio } from \"../abstractAudio/subProperties/spatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl } from \"../audioUtils\";\nimport { SoundState } from \"../soundState\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioOutNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\ntype StreamingSoundSourceType = HTMLMediaElement | string | string[];\n\n/** @internal */\nexport class _WebAudioStreamingSound extends StreamingSound implements IWebAudioSuperNode {\n    private _spatial: Nullable<_SpatialAudio> = null;\n    private readonly _spatialAutoUpdate: boolean = true;\n    private readonly _spatialMinUpdateTime: number = 0;\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected override readonly _options: IStreamingSoundStoredOptions;\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n\n    /** @internal */\n    public _audioContext: AudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public _source: StreamingSoundSourceType;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine, options: Partial<IStreamingSoundOptions>) {\n        super(name, engine);\n\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            loop: options.loop ?? false,\n            maxInstances: options.maxInstances ?? Infinity,\n            preloadCount: options.preloadCount ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n\n        this._subGraph = new _WebAudioStreamingSound._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _init(source: StreamingSoundSourceType, options: Partial<IStreamingSoundOptions>): Promise<void> {\n        const audioContext = this.engine._audioContext;\n\n        if (!(audioContext instanceof AudioContext)) {\n            throw new Error(\"Unsupported audio context type.\");\n        }\n\n        this._audioContext = audioContext;\n        this._source = source;\n\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.init(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        if (this.preloadCount) {\n            await this.preloadInstancesAsync(this.preloadCount);\n        }\n\n        if (options.autoplay) {\n            this.play(options);\n        }\n\n        this.engine._addNode(this);\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get spatial(): _SpatialAudio {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._spatial = null;\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeNode(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStreamingSound\";\n    }\n\n    protected _createInstance(): _WebAudioStreamingSoundInstance {\n        return new _WebAudioStreamingSoundInstance(this, this._options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    private _initSpatialProperty(): _SpatialAudio {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n\n        return this._spatial;\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioStreamingSound;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n    };\n}\n\n/** @internal */\nclass _WebAudioStreamingSoundInstance extends _StreamingSoundInstance implements IWebAudioOutNode {\n    private _currentTimeChangedWhilePaused = false;\n    private _enginePlayTime: number = Infinity;\n    private _enginePauseTime: number = 0;\n    private _isReady: boolean = false;\n    private _isReadyPromise: Promise<HTMLMediaElement> = new Promise((resolve, reject) => {\n        this._resolveIsReadyPromise = resolve;\n        this._rejectIsReadyPromise = reject;\n    });\n    private _mediaElement: HTMLMediaElement;\n    private _sourceNode: Nullable<MediaElementAudioSourceNode>;\n    private _volumeNode: GainNode;\n\n    protected override readonly _options: IStreamingSoundStoredOptions;\n    protected override _sound: _WebAudioStreamingSound;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    public constructor(sound: _WebAudioStreamingSound, options: IStreamingSoundStoredOptions) {\n        super(sound);\n\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n\n        if (typeof sound._source === \"string\") {\n            this._initFromUrl(sound._source);\n        } else if (Array.isArray(sound._source)) {\n            this._initFromUrls(sound._source);\n        } else if (sound._source instanceof HTMLMediaElement) {\n            this._initFromMediaElement(sound._source);\n        }\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        const timeSinceLastStart = this._state === SoundState.Paused ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n\n    public set currentTime(value: number) {\n        const restart = this._state === SoundState.Starting || this._state === SoundState.Started;\n\n        if (restart) {\n            this._mediaElement.pause();\n            this._setState(SoundState.Stopped);\n        }\n\n        this._options.startOffset = value;\n\n        if (restart) {\n            this.play({ startOffset: value });\n        } else if (this._state === SoundState.Paused) {\n            this._currentTimeChangedWhilePaused = true;\n        }\n    }\n\n    public get _outNode(): Nullable<AudioNode> {\n        return this._volumeNode;\n    }\n\n    /** @internal */\n    public get startTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        return this._enginePlayTime;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._sourceNode?.disconnect(this._volumeNode);\n        this._sourceNode = null;\n\n        this._mediaElement.removeEventListener(\"error\", this._onError);\n        this._mediaElement.removeEventListener(\"ended\", this._onEnded);\n        this._mediaElement.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n\n        for (const source of Array.from(this._mediaElement.children)) {\n            this._mediaElement.removeChild(source);\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        this.engine.userGestureObservable.removeCallback(this._onUserGesture);\n    }\n\n    /** @internal */\n    public play(options: Partial<IStreamingSoundPlayOptions> = {}): void {\n        if (this._state === SoundState.Started) {\n            return;\n        }\n\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        this._mediaElement.loop = this._options.loop;\n\n        let startOffset = options.startOffset;\n\n        if (this._currentTimeChangedWhilePaused) {\n            startOffset = this._options.startOffset;\n            this._currentTimeChangedWhilePaused = false;\n        } else if (this._state === SoundState.Paused) {\n            startOffset = this.currentTime + this._options.startOffset;\n        }\n\n        if (startOffset && startOffset > 0) {\n            this._mediaElement.currentTime = startOffset;\n        }\n\n        this._volumeNode.gain.value = options.volume ?? 1;\n\n        this._play();\n    }\n\n    /** @internal */\n    public pause(): void {\n        if (this._state !== SoundState.Starting && this._state !== SoundState.Started) {\n            return;\n        }\n\n        this._setState(SoundState.Paused);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n\n        this._mediaElement.pause();\n    }\n\n    /** @internal */\n    public resume(): void {\n        if (this._state === SoundState.Paused) {\n            this.play();\n        } else if (this._currentTimeChangedWhilePaused) {\n            this.play();\n        }\n    }\n\n    /** @internal */\n    public override stop(): void {\n        if (this._state === SoundState.Stopped) {\n            return;\n        }\n\n        this._stop();\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStreamingSoundInstance\";\n    }\n\n    protected override _connect(node: AbstractAudioNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: AbstractAudioNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    private _initFromMediaElement(mediaElement: HTMLMediaElement): void {\n        Tools.SetCorsBehavior(mediaElement.currentSrc, mediaElement);\n\n        mediaElement.controls = false;\n        mediaElement.loop = this._options.loop;\n        mediaElement.preload = \"auto\";\n\n        mediaElement.addEventListener(\"canplaythrough\", this._onCanPlayThrough, { once: true });\n        mediaElement.addEventListener(\"ended\", this._onEnded, { once: true });\n        mediaElement.addEventListener(\"error\", this._onError, { once: true });\n\n        mediaElement.load();\n\n        this._sourceNode = new MediaElementAudioSourceNode(this._sound._audioContext, { mediaElement: mediaElement });\n        this._sourceNode.connect(this._volumeNode);\n\n        if (!this._connect(this._sound)) {\n            throw new Error(\"Connect failed\");\n        }\n\n        this._mediaElement = mediaElement;\n    }\n\n    private _initFromUrl(url: string): void {\n        const audio = new Audio(_CleanUrl(url));\n        this._initFromMediaElement(audio);\n    }\n\n    private _initFromUrls(urls: string[]): void {\n        const audio = new Audio();\n\n        for (const url of urls) {\n            const source = document.createElement(\"source\");\n            source.src = _CleanUrl(url);\n            audio.appendChild(source);\n        }\n\n        this._initFromMediaElement(audio);\n    }\n\n    private _onCanPlayThrough: () => void = () => {\n        this._isReady = true;\n        this._resolveIsReadyPromise(this._mediaElement);\n        this.onReadyObservable.notifyObservers(this);\n    };\n\n    private _onEnded: () => void = () => {\n        this.onEndedObservable.notifyObservers(this);\n        this.dispose();\n    };\n\n    private _onError: (reason: any) => void = (reason: any) => {\n        this._setState(SoundState.FailedToStart);\n        this.onErrorObservable.notifyObservers(reason);\n        this._rejectIsReadyPromise(reason);\n        this.dispose();\n    };\n\n    private _onEngineStateChanged = () => {\n        if (this.engine.state !== \"running\") {\n            return;\n        }\n\n        if (this._options.loop && this.state === SoundState.Starting) {\n            this.play();\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    };\n\n    private _onUserGesture = () => {\n        this.play();\n    };\n\n    private _play(): void {\n        this._setState(SoundState.Starting);\n\n        if (!this._isReady) {\n            this._playWhenReady();\n            return;\n        }\n\n        if (this._state !== SoundState.Starting) {\n            return;\n        }\n\n        if (this.engine.state === \"running\") {\n            const result = this._mediaElement.play();\n\n            this._enginePlayTime = this.engine.currentTime;\n            this._setState(SoundState.Started);\n\n            // It's possible that the play() method fails on Safari, even if the audio engine's state is \"running\".\n            // This occurs when the audio context is paused by the system and resumed automatically by the audio engine\n            // without a user interaction (e.g. when the Vision Pro exits and reenters immersive mode).\n            result.catch(() => {\n                this._setState(SoundState.FailedToStart);\n\n                if (this._options.loop) {\n                    this.engine.userGestureObservable.addOnce(this._onUserGesture);\n                }\n            });\n        } else if (this._options.loop) {\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        } else {\n            this.stop();\n            this._setState(SoundState.FailedToStart);\n        }\n    }\n\n    private _playWhenReady(): void {\n        this._isReadyPromise\n            .then(() => {\n                this._play();\n            })\n            .catch(() => {\n                Logger.Error(\"Streaming sound instance failed to play\");\n                this._setState(SoundState.FailedToStart);\n            });\n    }\n\n    private _rejectIsReadyPromise: (reason?: any) => void;\n    private _resolveIsReadyPromise: (mediaElement: HTMLMediaElement) => void;\n\n    private _stop(): void {\n        this._mediaElement.pause();\n        this._setState(SoundState.Stopped);\n        this._onEnded();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
