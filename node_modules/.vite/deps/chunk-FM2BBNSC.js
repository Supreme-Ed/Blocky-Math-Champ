import {
  init_shadowMapFragment
} from "./chunk-MVDDRLDF.js";
import {
  init_packingFunctions
} from "./chunk-QKUPXMF3.js";
import {
  init_clipPlaneFragmentDeclaration
} from "./chunk-WZ3KSQ3M.js";
import {
  init_clipPlaneFragment
} from "./chunk-TBDBIMGM.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-IU6YKOYY.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bayerDitherFunctions.js
var name, shader;
var init_bayerDitherFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bayerDitherFunctions.js"() {
    init_shaderStore();
    name = "bayerDitherFunctions";
    shader = `float bayerDither2(vec2 _P) {return mod(2.0*_P.y+_P.x+1.0,4.0);}
float bayerDither4(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);}
float bayerDither8(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}
`;
    if (!ShaderStore.IncludesShadersStore[name]) {
      ShaderStore.IncludesShadersStore[name] = shader;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentExtraDeclaration.js
var name2, shader2;
var init_shadowMapFragmentExtraDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentExtraDeclaration.js"() {
    init_shaderStore();
    init_packingFunctions();
    init_bayerDitherFunctions();
    name2 = "shadowMapFragmentExtraDeclaration";
    shader2 = `#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform vec2 softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
    if (!ShaderStore.IncludesShadersStore[name2]) {
      ShaderStore.IncludesShadersStore[name2] = shader2;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/shadowMap.fragment.js
var name3, shader3, shadowMapPixelShader;
var init_shadowMap_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/shadowMap.fragment.js"() {
    init_shaderStore();
    init_shadowMapFragmentExtraDeclaration();
    init_clipPlaneFragmentDeclaration();
    init_clipPlaneFragment();
    init_shadowMapFragment();
    name3 = "shadowMapPixelShader";
    shader3 = `#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
vec4 opacityMap=texture2D(diffuseSampler,vUV);float alphaFromAlphaTexture=opacityMap.a;
#if SM_SOFTTRANSPARENTSHADOW==1
if (softTransparentShadowSM.y==1.0) {opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}
#endif
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x) discard;
#endif
#endif
#include<shadowMapFragment>
}`;
    if (!ShaderStore.ShadersStore[name3]) {
      ShaderStore.ShadersStore[name3] = shader3;
    }
    shadowMapPixelShader = { name: name3, shader: shader3 };
  }
});

export {
  shadowMapPixelShader,
  init_shadowMap_fragment
};
//# sourceMappingURL=chunk-FM2BBNSC.js.map
