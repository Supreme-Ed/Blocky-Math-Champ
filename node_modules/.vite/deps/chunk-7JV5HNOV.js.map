{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/drawWrapper.ts"],
  "sourcesContent": ["import type { IDrawContext } from \"../Engines/IDrawContext\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport type { Nullable } from \"../types\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { TimingTools } from \"core/Misc/timingTools\";\r\n\r\n/** @internal */\r\nexport class DrawWrapper {\r\n    public effect: Nullable<Effect>;\r\n    public defines: Nullable<string | MaterialDefines>;\r\n    public materialContext?: IMaterialContext;\r\n    public drawContext?: IDrawContext;\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    /**\r\n     * @internal\r\n     * Forces the code from bindForSubMesh to be fully run the next time it is called\r\n     */\r\n    public _forceRebindOnNextCall = true;\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously using instances\r\n     */\r\n    public _wasPreviouslyUsingInstances: Nullable<boolean> = null;\r\n\r\n    public static GetEffect(effect: Effect | DrawWrapper): Nullable<Effect> {\r\n        return (effect as Effect).getPipelineContext === undefined ? (effect as DrawWrapper).effect : (effect as Effect);\r\n    }\r\n\r\n    constructor(engine: AbstractEngine, createMaterialContext = true) {\r\n        this.effect = null;\r\n        this.defines = null;\r\n        this.drawContext = engine.createDrawContext();\r\n        if (createMaterialContext) {\r\n            this.materialContext = engine.createMaterialContext();\r\n        }\r\n    }\r\n\r\n    public setEffect(effect: Nullable<Effect>, defines?: Nullable<string | MaterialDefines>, resetContext = true): void {\r\n        this.effect = effect;\r\n        if (defines !== undefined) {\r\n            this.defines = defines;\r\n        }\r\n        if (resetContext) {\r\n            this.drawContext?.reset();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the effect wrapper and its resources\r\n     * @param immediate if the effect should be disposed immediately or on the next frame.\r\n     * If dispose() is not called during a scene or engine dispose, we want to delay the dispose of the underlying effect. Mostly to give a chance to user code to reuse the effect in some way.\r\n     */\r\n    public dispose(immediate = false): void {\r\n        if (this.effect) {\r\n            const effect = this.effect;\r\n            if (immediate) {\r\n                effect.dispose();\r\n            } else {\r\n                TimingTools.SetImmediate(() => {\r\n                    effect.getEngine().onEndFrameObservable.addOnce(() => {\r\n                        effect.dispose();\r\n                    });\r\n                });\r\n            }\r\n            this.effect = null;\r\n        }\r\n        this.drawContext?.dispose();\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;AAOA,IAGa;AAHb;;;AAGM,IAAO,cAAP,MAAkB;MAwBb,OAAO,UAAU,QAA4B;AAChD,eAAQ,OAAkB,uBAAuB,SAAa,OAAuB,SAAU;MACnG;MAEA,YAAY,QAAwB,wBAAwB,MAAI;AAlBzD,aAAA,sBAAsB;AAMtB,aAAA,yBAAyB;AAMzB,aAAA,+BAAkD;AAOrD,aAAK,SAAS;AACd,aAAK,UAAU;AACf,aAAK,cAAc,OAAO,kBAAiB;AAC3C,YAAI,uBAAuB;AACvB,eAAK,kBAAkB,OAAO,sBAAqB;QACvD;MACJ;MAEO,UAAU,QAA0B,SAA8C,eAAe,MAAI;AAxChH;AAyCQ,aAAK,SAAS;AACd,YAAI,YAAY,QAAW;AACvB,eAAK,UAAU;QACnB;AACA,YAAI,cAAc;AACd,qBAAK,gBAAL,mBAAkB;QACtB;MACJ;;;;;;MAOO,QAAQ,YAAY,OAAK;AAvDpC;AAwDQ,YAAI,KAAK,QAAQ;AACb,gBAAM,SAAS,KAAK;AACpB,cAAI,WAAW;AACX,mBAAO,QAAO;UAClB,OAAO;AACH,wBAAY,aAAa,MAAK;AAC1B,qBAAO,UAAS,EAAG,qBAAqB,QAAQ,MAAK;AACjD,uBAAO,QAAO;cAClB,CAAC;YACL,CAAC;UACL;AACA,eAAK,SAAS;QAClB;AACA,mBAAK,gBAAL,mBAAkB;MACtB;;;;",
  "names": []
}
