{
  "version": 3,
  "sources": ["../../../dev/core/src/Shaders/gpuTransform.vertex.ts", "../../../dev/core/src/Shaders/gpuTransform.fragment.ts", "../../../dev/core/src/Culling/Helper/transformFeedbackBoundingHelper.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"gpuTransformVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\nout vec3 outPosition;const mat4 identity=mat4(\nvec4(1.0,0.0,0.0,0.0),\nvec4(0.0,1.0,0.0,0.0),\nvec4(0.0,0.0,1.0,0.0),\nvec4(0.0,0.0,0.0,1.0)\n);void main(void) {vec3 positionUpdated=position;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nmat4 finalWorld=identity;\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gpuTransformVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuTransformPixelShader\";\nconst shader = `#version 300 es\nvoid main() {discard;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gpuTransformPixelShader = { name, shader };\n", "import type { Effect } from \"core/Materials/effect\";\r\nimport type { ThinEngine } from \"core/Engines/thinEngine\";\r\nimport { VertexBuffer, Buffer } from \"core/Buffers/buffer\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindMorphTargetParameters,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareDefinesAndAttributesForMorphTargets,\r\n} from \"core/Materials/materialHelper.functions\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { IBoundingInfoHelperPlatform } from \"./IBoundingInfoHelperPlatform\";\r\nimport { extractMinAndMax } from \"core/Maths/math.functions\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\nimport \"../../Shaders/gpuTransform.vertex\";\r\nimport \"../../Shaders/gpuTransform.fragment\";\r\n\r\n/** @internal */\r\nexport class TransformFeedbackBoundingHelper implements IBoundingInfoHelperPlatform {\r\n    private static _Min = new Vector3();\r\n    private static _Max = new Vector3();\r\n\r\n    private _engine: Nullable<ThinEngine>;\r\n    private _buffers: { [key: number]: Buffer } = {};\r\n    private _effects: { [key: string]: Effect } = {};\r\n    private _meshList: AbstractMesh[];\r\n    private _meshListCounter = 0;\r\n\r\n    /**\r\n     * Creates a new TransformFeedbackBoundingHelper\r\n     * @param engine defines the engine to use\r\n     */\r\n    constructor(engine: ThinEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    /** @internal */\r\n    public processAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        this._meshListCounter = 0;\r\n\r\n        this._processMeshList(meshes);\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _processMeshList(meshes: AbstractMesh[]) {\r\n        const parallelShaderCompile = this._engine!.getCaps().parallelShaderCompile;\r\n\r\n        this._engine!.getCaps().parallelShaderCompile = undefined;\r\n\r\n        for (let i = 0; i < meshes.length; ++i) {\r\n            const mesh = meshes[i];\r\n            const vertexCount = mesh.getTotalVertices();\r\n\r\n            if (vertexCount === 0 || !(mesh as Mesh).getVertexBuffer || !(mesh as Mesh).getVertexBuffer(VertexBuffer.PositionKind)) {\r\n                continue;\r\n            }\r\n\r\n            // Get correct effect\r\n            let computeEffect: Effect;\r\n            const defines: string[] = [];\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            // Bones\r\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n                attribs.push(VertexBuffer.MatricesIndicesKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsKind);\r\n                if (mesh.numBoneInfluencers > 4) {\r\n                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n                }\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n                defines.push(\"#define BONETEXTURE \" + mesh.skeleton.isUsingTextureForMatrices);\r\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\r\n            } else {\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n            }\r\n\r\n            // Morph\r\n            const numMorphInfluencers = mesh.morphTargetManager\r\n                ? PrepareDefinesAndAttributesForMorphTargets(\r\n                      mesh.morphTargetManager,\r\n                      defines,\r\n                      attribs,\r\n                      mesh,\r\n                      true, // usePositionMorph\r\n                      false, // useNormalMorph\r\n                      false, // useTangentMorph\r\n                      false, // useUVMorph\r\n                      false, // useUV2Morph\r\n                      false // useColorMorph\r\n                  )\r\n                : 0;\r\n\r\n            // Baked Vertex Animation\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n            }\r\n\r\n            const join = defines.join(\"\\n\");\r\n            if (!this._effects[join]) {\r\n                const uniforms = [\r\n                    \"boneTextureWidth\",\r\n                    \"mBones\",\r\n                    \"morphTargetInfluences\",\r\n                    \"morphTargetCount\",\r\n                    \"morphTargetTextureInfo\",\r\n                    \"morphTargetTextureIndices\",\r\n                    \"bakedVertexAnimationSettings\",\r\n                    \"bakedVertexAnimationTextureSizeInverted\",\r\n                    \"bakedVertexAnimationTime\",\r\n                ];\r\n                const samplers = [\"boneSampler\", \"morphTargets\", \"bakedVertexAnimationTexture\"];\r\n\r\n                const computeEffectOptions = {\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: [],\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: null,\r\n                    onCompiled: null,\r\n                    onError: null,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                    maxSimultaneousLights: 0,\r\n                    transformFeedbackVaryings: [\"outPosition\"],\r\n                };\r\n                computeEffect = this._engine!.createEffect(\"gpuTransform\", computeEffectOptions, this._engine!);\r\n                this._effects[join] = computeEffect;\r\n            } else {\r\n                computeEffect = this._effects[join];\r\n            }\r\n\r\n            this._compute(mesh, computeEffect);\r\n        }\r\n\r\n        this._engine!.getCaps().parallelShaderCompile = parallelShaderCompile;\r\n    }\r\n\r\n    private _compute(mesh: AbstractMesh, effect: Effect): void {\r\n        const engine = this._engine as Engine;\r\n\r\n        // Buffer\r\n        let targetBuffer: Buffer;\r\n        const vertexCount = mesh.getTotalVertices();\r\n\r\n        if (!this._buffers[mesh.uniqueId]) {\r\n            const targetData = new Float32Array(vertexCount * 3);\r\n            targetBuffer = new Buffer(mesh.getEngine(), targetData, true, 3);\r\n            this._buffers[mesh.uniqueId] = targetBuffer;\r\n        } else {\r\n            targetBuffer = this._buffers[mesh.uniqueId];\r\n        }\r\n\r\n        // Bind\r\n        effect.getEngine().enableEffect(effect);\r\n        (mesh as Mesh)._bindDirect(effect, null, true);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, effect);\r\n\r\n        // Morph targets\r\n        BindMorphTargetParameters(mesh, effect);\r\n        if (mesh.morphTargetManager && mesh.morphTargetManager.isUsingTextureForTargets) {\r\n            mesh.morphTargetManager._bind(effect);\r\n        }\r\n\r\n        // BVA\r\n        const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n        if (bvaManager && bvaManager.isEnabled) {\r\n            mesh.bakedVertexAnimationManager?.bind(effect, false);\r\n        }\r\n\r\n        // Update\r\n        const arrayBuffer = targetBuffer.getData()! as Float32Array;\r\n        engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());\r\n        engine.setRasterizerState(false);\r\n        engine.beginTransformFeedback(true);\r\n        engine.drawArraysType(Constants.MATERIAL_PointFillMode, 0, vertexCount);\r\n        engine.endTransformFeedback();\r\n        engine.setRasterizerState(true);\r\n        engine.readTransformFeedbackBuffer(arrayBuffer);\r\n        engine.bindTransformFeedbackBuffer(null);\r\n\r\n        // Update mesh\r\n        if (this._meshListCounter === 0) {\r\n            mesh._refreshBoundingInfo(arrayBuffer, null);\r\n        } else {\r\n            const bb = mesh.getBoundingInfo().boundingBox;\r\n            const extend = extractMinAndMax(arrayBuffer, 0, vertexCount);\r\n\r\n            TransformFeedbackBoundingHelper._Min.copyFrom(bb.minimum).minimizeInPlace(extend.minimum);\r\n            TransformFeedbackBoundingHelper._Max.copyFrom(bb.maximum).maximizeInPlace(extend.maximum);\r\n\r\n            mesh._refreshBoundingInfoDirect({ minimum: TransformFeedbackBoundingHelper._Min, maximum: TransformFeedbackBoundingHelper._Max });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public registerMeshListAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        this._meshList = meshes;\r\n        this._meshListCounter = 0;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /** @internal */\r\n    public processMeshList(): void {\r\n        if (this._meshList.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._processMeshList(this._meshList);\r\n        this._meshListCounter++;\r\n    }\r\n\r\n    /** @internal */\r\n    public fetchResultsForMeshListAsync(): Promise<void> {\r\n        this._meshListCounter = 0;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        for (const key in this._buffers) {\r\n            this._buffers[key].dispose();\r\n        }\r\n        this._buffers = {};\r\n        this._effects = {};\r\n        this._engine = null;\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAWM,MACA;AAZN;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAM,OAAO;AACb,IAAM,SAAS;;;;;;;;;;;;;;;;;AAkBf,QAAI,CAAC,YAAY,aAAa,IAAI,GAAG;AACjC,kBAAY,aAAa,IAAI,IAAI;IACrC;;;;;AChCA,IAGMA,OACAC;AAJN;;AACA;AAEA,IAAMD,QAAO;AACb,IAAMC,UAAS;;;AAIf,QAAI,CAAC,YAAY,aAAaD,KAAI,GAAG;AACjC,kBAAY,aAAaA,KAAI,IAAIC;IACrC;;;;;ACRA,IAoBa;AApBb;;;AAKA;AAQA;AACA;AAEA;AACA;AAGM,IAAO,kCAAP,MAAO,iCAA+B;;;;;MAcxC,YAAY,QAAkB;AATtB,aAAA,WAAsC,CAAA;AACtC,aAAA,WAAsC,CAAA;AAEtC,aAAA,mBAAmB;AAOvB,aAAK,UAAU;MACnB;;MAGO,aAAa,QAAqC;AACrD,YAAI,CAAC,MAAM,QAAQ,MAAM,GAAG;AACxB,mBAAS,CAAC,MAAM;QACpB;AAEA,aAAK,mBAAmB;AAExB,aAAK,iBAAiB,MAAM;AAE5B,eAAO,QAAQ,QAAO;MAC1B;MAEQ,iBAAiB,QAAsB;AAC3C,cAAM,wBAAwB,KAAK,QAAS,QAAO,EAAG;AAEtD,aAAK,QAAS,QAAO,EAAG,wBAAwB;AAEhD,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACpC,gBAAM,OAAO,OAAO,CAAC;AACrB,gBAAM,cAAc,KAAK,iBAAgB;AAEzC,cAAI,gBAAgB,KAAK,CAAE,KAAc,mBAAmB,CAAE,KAAc,gBAAgB,aAAa,YAAY,GAAG;AACpH;UACJ;AAGA,cAAI;AACJ,gBAAM,UAAoB,CAAA;AAC1B,gBAAM,UAAU,CAAC,aAAa,YAAY;AAG1C,cAAI,QAAQ,KAAK,YAAY,KAAK,4BAA4B,KAAK,UAAU;AACzE,oBAAQ,KAAK,aAAa,mBAAmB;AAC7C,oBAAQ,KAAK,aAAa,mBAAmB;AAC7C,gBAAI,KAAK,qBAAqB,GAAG;AAC7B,sBAAQ,KAAK,aAAa,wBAAwB;AAClD,sBAAQ,KAAK,aAAa,wBAAwB;YACtD;AACA,oBAAQ,KAAK,kCAAkC,KAAK,kBAAkB;AACtE,oBAAQ,KAAK,yBAAyB,KAAK,SAAS,yBAAyB;AAC7E,oBAAQ,KAAK,2BAA2B,KAAK,SAAS,MAAM,SAAS,EAAE;UAC3E,OAAO;AACH,oBAAQ,KAAK,gCAAgC;UACjD;AAGA,gBAAM,sBAAsB,KAAK,qBAC3B;YACI,KAAK;YACL;YACA;YACA;YACA;;YACA;;YACA;;YACA;;YACA;;YACA;;cAEJ;AAGN,gBAAM,aAAoB,KAAM;AAChC,cAAI,cAAc,WAAW,WAAW;AACpC,oBAAQ,KAAK,wCAAwC;AACrD,qDAAyC,SAAS,MAAM,OAAO;UACnE;AAEA,gBAAM,OAAO,QAAQ,KAAK,IAAI;AAC9B,cAAI,CAAC,KAAK,SAAS,IAAI,GAAG;AACtB,kBAAM,WAAW;cACb;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;;AAEJ,kBAAM,WAAW,CAAC,eAAe,gBAAgB,6BAA6B;AAE9E,kBAAM,uBAAuB;cACzB,YAAY;cACZ,eAAe;cACf,qBAAqB,CAAA;cACrB;cACA,SAAS;cACT,WAAW;cACX,YAAY;cACZ,SAAS;cACT,iBAAiB,EAAE,6BAA6B,oBAAmB;cACnE,uBAAuB;cACvB,2BAA2B,CAAC,aAAa;;AAE7C,4BAAgB,KAAK,QAAS,aAAa,gBAAgB,sBAAsB,KAAK,OAAQ;AAC9F,iBAAK,SAAS,IAAI,IAAI;UAC1B,OAAO;AACH,4BAAgB,KAAK,SAAS,IAAI;UACtC;AAEA,eAAK,SAAS,MAAM,aAAa;QACrC;AAEA,aAAK,QAAS,QAAO,EAAG,wBAAwB;MACpD;MAEQ,SAAS,MAAoB,QAAc;AAnJvD;AAoJQ,cAAM,SAAS,KAAK;AAGpB,YAAI;AACJ,cAAM,cAAc,KAAK,iBAAgB;AAEzC,YAAI,CAAC,KAAK,SAAS,KAAK,QAAQ,GAAG;AAC/B,gBAAM,aAAa,IAAI,aAAa,cAAc,CAAC;AACnD,yBAAe,IAAI,OAAO,KAAK,UAAS,GAAI,YAAY,MAAM,CAAC;AAC/D,eAAK,SAAS,KAAK,QAAQ,IAAI;QACnC,OAAO;AACH,yBAAe,KAAK,SAAS,KAAK,QAAQ;QAC9C;AAGA,eAAO,UAAS,EAAG,aAAa,MAAM;AACrC,aAAc,YAAY,QAAQ,MAAM,IAAI;AAG7C,4BAAoB,MAAM,MAAM;AAGhC,kCAA0B,MAAM,MAAM;AACtC,YAAI,KAAK,sBAAsB,KAAK,mBAAmB,0BAA0B;AAC7E,eAAK,mBAAmB,MAAM,MAAM;QACxC;AAGA,cAAM,aAAoB,KAAM;AAEhC,YAAI,cAAc,WAAW,WAAW;AACpC,qBAAK,gCAAL,mBAAkC,KAAK,QAAQ;QACnD;AAGA,cAAM,cAAc,aAAa,QAAO;AACxC,eAAO,4BAA4B,aAAa,UAAS,CAAE;AAC3D,eAAO,mBAAmB,KAAK;AAC/B,eAAO,uBAAuB,IAAI;AAClC,eAAO,eAAe,GAAA,GAAA,WAAU;AAChC,eAAO,qBAAoB;AAC3B,eAAO,mBAAmB,IAAI;AAC9B,eAAO,4BAA4B,WAAW;AAC9C,eAAO,4BAA4B,IAAI;AAGvC,YAAI,KAAK,qBAAqB,GAAG;AAC7B,eAAK,qBAAqB,aAAa,IAAI;QAC/C,OAAO;AACH,gBAAM,KAAK,KAAK,gBAAe,EAAG;AAClC,gBAAM,SAAS,iBAAiB,aAAa,GAAG,WAAW;AAE3D,2CAAgC,KAAK,SAAS,GAAG,OAAO,EAAE,gBAAgB,OAAO,OAAO;AACxF,2CAAgC,KAAK,SAAS,GAAG,OAAO,EAAE,gBAAgB,OAAO,OAAO;AAExF,eAAK,2BAA2B,EAAE,SAAS,iCAAgC,MAAM,SAAS,iCAAgC,KAAI,CAAE;QACpI;MACJ;;MAGO,sBAAsB,QAAqC;AAC9D,YAAI,CAAC,MAAM,QAAQ,MAAM,GAAG;AACxB,mBAAS,CAAC,MAAM;QACpB;AAEA,aAAK,YAAY;AACjB,aAAK,mBAAmB;AAExB,eAAO,QAAQ,QAAO;MAC1B;;MAGO,kBAAe;AAClB,YAAI,KAAK,UAAU,WAAW,GAAG;AAC7B;QACJ;AAEA,aAAK,iBAAiB,KAAK,SAAS;AACpC,aAAK;MACT;;MAGO,+BAA4B;AAC/B,aAAK,mBAAmB;AAExB,eAAO,QAAQ,QAAO;MAC1B;;MAGO,UAAO;AACV,mBAAW,OAAO,KAAK,UAAU;AAC7B,eAAK,SAAS,GAAG,EAAE,QAAO;QAC9B;AACA,aAAK,WAAW,CAAA;AAChB,aAAK,WAAW,CAAA;AAChB,aAAK,UAAU;MACnB;;AA/Ne,oCAAA,OAAO,IAAI,QAAO;AAClB,oCAAA,OAAO,IAAI,QAAO;;;",
  "names": ["name", "shader"]
}
