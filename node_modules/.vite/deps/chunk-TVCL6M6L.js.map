{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/Animation/flowGraphPlayAnimationBlock.ts"],
  "sourcesContent": ["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\r\nimport { RichTypeAny, RichTypeNumber, RichTypeBoolean } from \"../../../flowGraphRichTypes\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\n\r\n/**\r\n * @experimental\r\n * A block that plays an animation on an animatable object.\r\n */\r\nexport class FlowGraphPlayAnimationBlock extends FlowGraphAsyncExecutionBlock {\r\n    /**\r\n     * Input connection: The speed of the animation.\r\n     */\r\n    public readonly speed: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: Should the animation loop?\r\n     * Not in glTF specs, but useful for the engine.\r\n     */\r\n    public readonly loop: FlowGraphDataConnection<boolean>;\r\n    /**\r\n     * Input connection: The starting frame of the animation.\r\n     */\r\n    public readonly from: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: The ending frame of the animation.\r\n     */\r\n    public readonly to: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The current frame of the animation.\r\n     */\r\n    public readonly currentFrame: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The current time of the animation.\r\n     */\r\n    public readonly currentTime: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The animatable that is currently running.\r\n     */\r\n    public readonly currentAnimationGroup: FlowGraphDataConnection<AnimationGroup>;\r\n\r\n    /**\r\n     * Input: Will be initialized if no animation group was provided in the configuration.\r\n     */\r\n    public readonly animationGroup: FlowGraphDataConnection<AnimationGroup>;\r\n\r\n    /**\r\n     * Input: If provided this animation will be used. Priority will be given to the animation group input.\r\n     */\r\n    public readonly animation: FlowGraphDataConnection<Animation | Animation[]>;\r\n\r\n    /**\r\n     * Input connection: The target object that will be animated. If animation group is provided this input will be ignored.\r\n     */\r\n    public readonly object: FlowGraphDataConnection<any>;\r\n\r\n    public constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config?: IFlowGraphBlockConfiguration\r\n    ) {\r\n        super(config, [\"animationLoop\", \"animationEnd\", \"animationGroupLoop\"]);\r\n\r\n        this.speed = this.registerDataInput(\"speed\", RichTypeNumber);\r\n        this.loop = this.registerDataInput(\"loop\", RichTypeBoolean);\r\n        this.from = this.registerDataInput(\"from\", RichTypeNumber, 0);\r\n        this.to = this.registerDataInput(\"to\", RichTypeNumber);\r\n\r\n        this.currentFrame = this.registerDataOutput(\"currentFrame\", RichTypeNumber);\r\n        this.currentTime = this.registerDataOutput(\"currentTime\", RichTypeNumber);\r\n\r\n        this.currentAnimationGroup = this.registerDataOutput(\"currentAnimationGroup\", RichTypeAny);\r\n        this.animationGroup = this.registerDataInput(\"animationGroup\", RichTypeAny, config?.animationGroup);\r\n        this.animation = this.registerDataInput(\"animation\", RichTypeAny);\r\n        this.object = this.registerDataInput(\"object\", RichTypeAny);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param context\r\n     */\r\n    public _preparePendingTasks(context: FlowGraphContext): void {\r\n        const ag = this.animationGroup.getValue(context);\r\n        const animation = this.animation.getValue(context);\r\n        if (!ag && !animation) {\r\n            return this._reportError(context, \"No animation or animation group provided\");\r\n        } else {\r\n            // if an animation group was already created, dispose it and create a new one\r\n            const currentAnimationGroup = this.currentAnimationGroup.getValue(context);\r\n            if (currentAnimationGroup && currentAnimationGroup !== ag) {\r\n                currentAnimationGroup.dispose();\r\n            }\r\n            let animationGroupToUse = ag;\r\n            // check which animation to use. If no animationGroup was defined and an animation was provided, use the animation\r\n            if (animation && !animationGroupToUse) {\r\n                const target = this.object.getValue(context);\r\n                if (!target) {\r\n                    return this._reportError(context, \"No target object provided\");\r\n                }\r\n                const animationsArray = Array.isArray(animation) ? animation : [animation];\r\n                const name = animationsArray[0].name;\r\n                animationGroupToUse = new AnimationGroup(\"flowGraphAnimationGroup-\" + name + \"-\" + target.name, context.configuration.scene);\r\n                let isInterpolation = false;\r\n                const interpolationAnimations = context._getGlobalContextVariable(\"interpolationAnimations\", []) as number[];\r\n                for (const anim of animationsArray) {\r\n                    animationGroupToUse.addTargetedAnimation(anim, target);\r\n                    if (interpolationAnimations.indexOf(anim.uniqueId) !== -1) {\r\n                        isInterpolation = true;\r\n                    }\r\n                }\r\n\r\n                if (isInterpolation) {\r\n                    this._checkInterpolationDuplications(context, animationsArray, target);\r\n                }\r\n            }\r\n            // not accepting 0\r\n            const speed = this.speed.getValue(context) || 1;\r\n            const from = this.from.getValue(context) ?? 0;\r\n            // not accepting 0\r\n            const to = this.to.getValue(context) || animationGroupToUse.to;\r\n            const loop = !isFinite(to) || this.loop.getValue(context);\r\n            this.currentAnimationGroup.setValue(animationGroupToUse, context);\r\n\r\n            const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n            // check if it already running\r\n            if (currentlyRunningAnimationGroups.indexOf(animationGroupToUse.uniqueId) !== -1) {\r\n                animationGroupToUse.stop();\r\n            }\r\n            try {\r\n                animationGroupToUse.start(loop, speed, from, to);\r\n                animationGroupToUse.onAnimationGroupEndObservable.add(() => this._onAnimationGroupEnd(context));\r\n                animationGroupToUse.onAnimationEndObservable.add(() => this._eventsSignalOutputs[\"animationEnd\"]._activateSignal(context));\r\n                animationGroupToUse.onAnimationLoopObservable.add(() => this._eventsSignalOutputs[\"animationLoop\"]._activateSignal(context));\r\n                animationGroupToUse.onAnimationGroupLoopObservable.add(() => this._eventsSignalOutputs[\"animationGroupLoop\"]._activateSignal(context));\r\n                currentlyRunningAnimationGroups.push(animationGroupToUse.uniqueId);\r\n                context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\r\n            } catch (e) {\r\n                this._reportError(context, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _reportError(context: FlowGraphContext, error: string | Error): void {\r\n        super._reportError(context, error);\r\n        this.currentFrame.setValue(-1, context);\r\n        this.currentTime.setValue(-1, context);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _executeOnTick(_context: FlowGraphContext): void {\r\n        const ag = this.currentAnimationGroup.getValue(_context);\r\n        if (ag) {\r\n            this.currentFrame.setValue(ag.getCurrentFrame(), _context);\r\n            this.currentTime.setValue(ag.animatables[0]?.elapsedTime ?? 0, _context);\r\n        }\r\n    }\r\n\r\n    public _execute(context: FlowGraphContext): void {\r\n        this._startPendingTasks(context);\r\n    }\r\n\r\n    private _onAnimationGroupEnd(context: FlowGraphContext) {\r\n        this._removeFromCurrentlyRunning(context, this.currentAnimationGroup.getValue(context));\r\n        this._resetAfterCanceled(context);\r\n        this.done._activateSignal(context);\r\n    }\r\n\r\n    /**\r\n     * The idea behind this function is to check every running animation group and check if the targeted animations it uses are interpolation animations.\r\n     * If they are, we want to see that they don't collide with the current interpolation animations that are starting to play.\r\n     * If they do, we want to stop the already-running animation group.\r\n     * @internal\r\n     */\r\n    private _checkInterpolationDuplications(context: FlowGraphContext, animation: Animation[], target: any) {\r\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n        for (const uniqueId of currentlyRunningAnimationGroups) {\r\n            const ag = context.assetsContext.animationGroups.find((ag) => ag.uniqueId === uniqueId);\r\n            if (ag) {\r\n                for (const anim of ag.targetedAnimations) {\r\n                    for (const animToCheck of animation) {\r\n                        if (anim.animation.targetProperty === animToCheck.targetProperty && anim.target === target) {\r\n                            this._stopAnimationGroup(context, ag);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _stopAnimationGroup(context: FlowGraphContext, animationGroup: AnimationGroup) {\r\n        // stop, while skipping the on AnimationEndObservable to avoid the \"done\" signal\r\n        animationGroup.stop(true);\r\n        animationGroup.dispose();\r\n        this._removeFromCurrentlyRunning(context, animationGroup);\r\n    }\r\n\r\n    private _removeFromCurrentlyRunning(context: FlowGraphContext, animationGroup: AnimationGroup) {\r\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n        const idx = currentlyRunningAnimationGroups.indexOf(animationGroup.uniqueId);\r\n        if (idx !== -1) {\r\n            currentlyRunningAnimationGroups.splice(idx, 1);\r\n            context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Stop any currently running animations.\r\n     */\r\n    public _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const ag = this.currentAnimationGroup.getValue(context);\r\n        if (ag) {\r\n            this._stopAnimationGroup(context, ag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.PlayAnimation;\r\n    }\r\n}\r\n\r\nRegisterClass(FlowGraphBlockNames.PlayAnimation, FlowGraphPlayAnimationBlock);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAEA,IAYa;AAZb;;;AACA;AACA;AAEA;AAQM,IAAO,8BAAP,cAA2C,6BAA4B;MAiDzE,YAIoB,QAAqC;AAErD,cAAM,QAAQ,CAAC,iBAAiB,gBAAgB,oBAAoB,CAAC;AAFrD,aAAA,SAAA;AAIhB,aAAK,QAAQ,KAAK,kBAAkB,SAAS,cAAc;AAC3D,aAAK,OAAO,KAAK,kBAAkB,QAAQ,eAAe;AAC1D,aAAK,OAAO,KAAK,kBAAkB,QAAQ,gBAAgB,CAAC;AAC5D,aAAK,KAAK,KAAK,kBAAkB,MAAM,cAAc;AAErD,aAAK,eAAe,KAAK,mBAAmB,gBAAgB,cAAc;AAC1E,aAAK,cAAc,KAAK,mBAAmB,eAAe,cAAc;AAExE,aAAK,wBAAwB,KAAK,mBAAmB,yBAAyB,WAAW;AACzF,aAAK,iBAAiB,KAAK,kBAAkB,kBAAkB,aAAa,iCAAQ,cAAc;AAClG,aAAK,YAAY,KAAK,kBAAkB,aAAa,WAAW;AAChE,aAAK,SAAS,KAAK,kBAAkB,UAAU,WAAW;MAC9D;;;;;MAMO,qBAAqB,SAAyB;AACjD,cAAM,KAAK,KAAK,eAAe,SAAS,OAAO;AAC/C,cAAM,YAAY,KAAK,UAAU,SAAS,OAAO;AACjD,YAAI,CAAC,MAAM,CAAC,WAAW;AACnB,iBAAO,KAAK,aAAa,SAAS,0CAA0C;QAChF,OAAO;AAEH,gBAAM,wBAAwB,KAAK,sBAAsB,SAAS,OAAO;AACzE,cAAI,yBAAyB,0BAA0B,IAAI;AACvD,kCAAsB,QAAO;UACjC;AACA,cAAI,sBAAsB;AAE1B,cAAI,aAAa,CAAC,qBAAqB;AACnC,kBAAM,SAAS,KAAK,OAAO,SAAS,OAAO;AAC3C,gBAAI,CAAC,QAAQ;AACT,qBAAO,KAAK,aAAa,SAAS,2BAA2B;YACjE;AACA,kBAAM,kBAAkB,MAAM,QAAQ,SAAS,IAAI,YAAY,CAAC,SAAS;AACzE,kBAAM,OAAO,gBAAgB,CAAC,EAAE;AAChC,kCAAsB,IAAI,eAAe,6BAA6B,OAAO,MAAM,OAAO,MAAM,QAAQ,cAAc,KAAK;AAC3H,gBAAI,kBAAkB;AACtB,kBAAM,0BAA0B,QAAQ,0BAA0B,2BAA2B,CAAA,CAAE;AAC/F,uBAAW,QAAQ,iBAAiB;AAChC,kCAAoB,qBAAqB,MAAM,MAAM;AACrD,kBAAI,wBAAwB,QAAQ,KAAK,QAAQ,MAAM,IAAI;AACvD,kCAAkB;cACtB;YACJ;AAEA,gBAAI,iBAAiB;AACjB,mBAAK,gCAAgC,SAAS,iBAAiB,MAAM;YACzE;UACJ;AAEA,gBAAM,QAAQ,KAAK,MAAM,SAAS,OAAO,KAAK;AAC9C,gBAAM,OAAO,KAAK,KAAK,SAAS,OAAO,KAAK;AAE5C,gBAAM,KAAK,KAAK,GAAG,SAAS,OAAO,KAAK,oBAAoB;AAC5D,gBAAM,OAAO,CAAC,SAAS,EAAE,KAAK,KAAK,KAAK,SAAS,OAAO;AACxD,eAAK,sBAAsB,SAAS,qBAAqB,OAAO;AAEhE,gBAAM,kCAAkC,QAAQ,0BAA0B,mCAAmC,CAAA,CAAE;AAE/G,cAAI,gCAAgC,QAAQ,oBAAoB,QAAQ,MAAM,IAAI;AAC9E,gCAAoB,KAAI;UAC5B;AACA,cAAI;AACA,gCAAoB,MAAM,MAAM,OAAO,MAAM,EAAE;AAC/C,gCAAoB,8BAA8B,IAAI,MAAM,KAAK,qBAAqB,OAAO,CAAC;AAC9F,gCAAoB,yBAAyB,IAAI,MAAM,KAAK,qBAAqB,cAAc,EAAE,gBAAgB,OAAO,CAAC;AACzH,gCAAoB,0BAA0B,IAAI,MAAM,KAAK,qBAAqB,eAAe,EAAE,gBAAgB,OAAO,CAAC;AAC3H,gCAAoB,+BAA+B,IAAI,MAAM,KAAK,qBAAqB,oBAAoB,EAAE,gBAAgB,OAAO,CAAC;AACrI,4CAAgC,KAAK,oBAAoB,QAAQ;AACjE,oBAAQ,0BAA0B,mCAAmC,+BAA+B;UACxG,SAAS,GAAG;AACR,iBAAK,aAAa,SAAS,CAAC;UAChC;QACJ;MACJ;MAEmB,aAAa,SAA2B,OAAqB;AAC5E,cAAM,aAAa,SAAS,KAAK;AACjC,aAAK,aAAa,SAAS,IAAI,OAAO;AACtC,aAAK,YAAY,SAAS,IAAI,OAAO;MACzC;;;;MAKgB,eAAe,UAA0B;AA7J7D;AA8JQ,cAAM,KAAK,KAAK,sBAAsB,SAAS,QAAQ;AACvD,YAAI,IAAI;AACJ,eAAK,aAAa,SAAS,GAAG,gBAAe,GAAI,QAAQ;AACzD,eAAK,YAAY,WAAS,QAAG,YAAY,CAAC,MAAhB,mBAAmB,gBAAe,GAAG,QAAQ;QAC3E;MACJ;MAEO,SAAS,SAAyB;AACrC,aAAK,mBAAmB,OAAO;MACnC;MAEQ,qBAAqB,SAAyB;AAClD,aAAK,4BAA4B,SAAS,KAAK,sBAAsB,SAAS,OAAO,CAAC;AACtF,aAAK,oBAAoB,OAAO;AAChC,aAAK,KAAK,gBAAgB,OAAO;MACrC;;;;;;;MAQQ,gCAAgC,SAA2B,WAAwB,QAAW;AAClG,cAAM,kCAAkC,QAAQ,0BAA0B,mCAAmC,CAAA,CAAE;AAC/G,mBAAW,YAAY,iCAAiC;AACpD,gBAAM,KAAK,QAAQ,cAAc,gBAAgB,KAAK,CAACA,QAAOA,IAAG,aAAa,QAAQ;AACtF,cAAI,IAAI;AACJ,uBAAW,QAAQ,GAAG,oBAAoB;AACtC,yBAAW,eAAe,WAAW;AACjC,oBAAI,KAAK,UAAU,mBAAmB,YAAY,kBAAkB,KAAK,WAAW,QAAQ;AACxF,uBAAK,oBAAoB,SAAS,EAAE;gBACxC;cACJ;YACJ;UACJ;QACJ;MACJ;MAEQ,oBAAoB,SAA2B,gBAA8B;AAEjF,uBAAe,KAAK,IAAI;AACxB,uBAAe,QAAO;AACtB,aAAK,4BAA4B,SAAS,cAAc;MAC5D;MAEQ,4BAA4B,SAA2B,gBAA8B;AACzF,cAAM,kCAAkC,QAAQ,0BAA0B,mCAAmC,CAAA,CAAE;AAC/G,cAAM,MAAM,gCAAgC,QAAQ,eAAe,QAAQ;AAC3E,YAAI,QAAQ,IAAI;AACZ,0CAAgC,OAAO,KAAK,CAAC;AAC7C,kBAAQ,0BAA0B,mCAAmC,+BAA+B;QACxG;MACJ;;;;;MAMO,oBAAoB,SAAyB;AAChD,cAAM,KAAK,KAAK,sBAAsB,SAAS,OAAO;AACtD,YAAI,IAAI;AACJ,eAAK,oBAAoB,SAAS,EAAE;QACxC;MACJ;;;;MAKgB,eAAY;AACxB,eAAA;MACJ;;AAGJ,kBAAa,+BAAoC,2BAA2B;;;",
  "names": ["ag"]
}
