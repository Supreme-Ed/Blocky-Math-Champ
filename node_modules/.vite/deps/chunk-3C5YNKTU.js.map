{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/filesInputStore.ts", "../../../dev/core/src/Misc/retryStrategy.ts", "../../../dev/core/src/Misc/error.ts", "../../../dev/core/src/Misc/stringTools.ts", "../../../dev/core/src/Misc/fileTools.ts", "../../../dev/core/src/Misc/instantiationTools.ts"],
  "sourcesContent": ["/**\r\n * Class used to help managing file picking and drag'n'drop\r\n * File Storage\r\n */\r\nexport class FilesInputStore {\r\n    /**\r\n     * List of files ready to be loaded\r\n     */\r\n    public static FilesToLoad: { [key: string]: File } = {};\r\n}\r\n", "import type { WebRequest } from \"./webRequest\";\r\n\r\n/**\r\n * Class used to define a retry strategy when error happens while loading assets\r\n */\r\nexport class RetryStrategy {\r\n    /**\r\n     * Function used to defines an exponential back off strategy\r\n     * @param maxRetries defines the maximum number of retries (3 by default)\r\n     * @param baseInterval defines the interval between retries\r\n     * @returns the strategy function to use\r\n     */\r\n    public static ExponentialBackoff(maxRetries = 3, baseInterval = 500) {\r\n        return (url: string, request: WebRequest, retryIndex: number): number => {\r\n            if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf(\"file:\") !== -1) {\r\n                return -1;\r\n            }\r\n\r\n            return Math.pow(2, retryIndex) * baseInterval;\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/**\r\n * Base error. Due to limitations of typedoc-check and missing documentation\r\n * in lib.es5.d.ts, cannot extend Error directly for RuntimeError.\r\n * @ignore\r\n */\r\nexport abstract class BaseError extends Error {\r\n    // See https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript\r\n    // and https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n\r\n    // Polyfill for Object.setPrototypeOf if necessary.\r\n    protected static _setPrototypeOf: (o: any, proto: object | null) => any =\r\n        (Object as any).setPrototypeOf ||\r\n        ((o, proto) => {\r\n            o.__proto__ = proto;\r\n            return o;\r\n        });\r\n}\r\n\r\n/* IMP! DO NOT CHANGE THE NUMBERING OF EXISTING ERROR CODES */\r\n/**\r\n * Error codes for BaseError\r\n */\r\nexport const ErrorCodes = {\r\n    // Mesh errors 0-999\r\n    /** Invalid or empty mesh vertex positions. */\r\n    MeshInvalidPositionsError: 0,\r\n\r\n    // Texture errors 1000-1999\r\n    /** Unsupported texture found. */\r\n    UnsupportedTextureError: 1000,\r\n\r\n    // GLTFLoader errors 2000-2999\r\n    /** Unexpected magic number found in GLTF file header. */\r\n    GLTFLoaderUnexpectedMagicError: 2000,\r\n\r\n    // SceneLoader errors 3000-3999\r\n    /** SceneLoader generic error code. Ideally wraps the inner exception. */\r\n    SceneLoaderError: 3000,\r\n\r\n    // File related errors 4000-4999\r\n    /** Load file error */\r\n    LoadFileError: 4000,\r\n    /** Request file error */\r\n    RequestFileError: 4001,\r\n    /** Read file error */\r\n    ReadFileError: 4002,\r\n} as const;\r\n\r\n/**\r\n * Error code type\r\n */\r\nexport type ErrorCodesType = (typeof ErrorCodes)[keyof typeof ErrorCodes];\r\n\r\n/**\r\n * Application runtime error\r\n */\r\nexport class RuntimeError extends BaseError {\r\n    /**\r\n     * The error code\r\n     */\r\n    public errorCode: ErrorCodesType;\r\n\r\n    /**\r\n     * The error that caused this outer error\r\n     */\r\n    public innerError?: Error;\r\n\r\n    /**\r\n     * Creates a new RuntimeError\r\n     * @param message defines the message of the error\r\n     * @param errorCode the error code\r\n     * @param innerError the error that caused the outer error\r\n     */\r\n    public constructor(message: string, errorCode: ErrorCodesType, innerError?: Error) {\r\n        super(message);\r\n\r\n        this.errorCode = errorCode;\r\n        this.innerError = innerError;\r\n\r\n        this.name = \"RuntimeError\";\r\n        BaseError._setPrototypeOf(this, RuntimeError.prototype);\r\n    }\r\n}\r\n\r\n/**\r\n * Used for flow control when an operation is aborted, such as with AbortController.\r\n */\r\nexport class AbortError extends BaseError {\r\n    public constructor(message = \"Operation aborted\") {\r\n        super(message);\r\n        this.name = \"AbortError\";\r\n        BaseError._setPrototypeOf(this, AbortError.prototype);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\n/**\r\n * Checks for a matching suffix at the end of a string (for ES5 and lower)\r\n * @param str Source string\r\n * @param suffix Suffix to search for in the source string\r\n * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n * @deprecated Please use native string function instead\r\n */\r\nexport const EndsWith = (str: string, suffix: string): boolean => {\r\n    return str.endsWith(suffix);\r\n};\r\n\r\n/**\r\n * Checks for a matching suffix at the beginning of a string (for ES5 and lower)\r\n * @param str Source string\r\n * @param suffix Suffix to search for in the source string\r\n * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n * @deprecated Please use native string function instead\r\n */\r\nexport const StartsWith = (str: string, suffix: string): boolean => {\r\n    if (!str) {\r\n        return false;\r\n    }\r\n    return str.startsWith(suffix);\r\n};\r\n\r\n/**\r\n * Decodes a buffer into a string\r\n * @param buffer The buffer to decode\r\n * @returns The decoded string\r\n */\r\nexport const Decode = (buffer: Uint8Array | Uint16Array): string => {\r\n    if (typeof TextDecoder !== \"undefined\") {\r\n        return new TextDecoder().decode(buffer);\r\n    }\r\n\r\n    let result = \"\";\r\n    for (let i = 0; i < buffer.byteLength; i++) {\r\n        result += String.fromCharCode(buffer[i]);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Encode a buffer to a base64 string\r\n * @param buffer defines the buffer to encode\r\n * @returns the encoded string\r\n */\r\nexport const EncodeArrayBufferToBase64 = (buffer: ArrayBuffer | ArrayBufferView): string => {\r\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n    let output = \"\";\r\n    let chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n    let i = 0;\r\n    const bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);\r\n\r\n    while (i < bytes.length) {\r\n        chr1 = bytes[i++];\r\n        chr2 = i < bytes.length ? bytes[i++] : Number.NaN;\r\n        chr3 = i < bytes.length ? bytes[i++] : Number.NaN;\r\n\r\n        enc1 = chr1 >> 2;\r\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n        enc4 = chr3 & 63;\r\n\r\n        if (isNaN(chr2)) {\r\n            enc3 = enc4 = 64;\r\n        } else if (isNaN(chr3)) {\r\n            enc4 = 64;\r\n        }\r\n        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\n/**\r\n * Converts a given base64 string as an ASCII encoded stream of data\r\n * @param base64Data The base64 encoded string to decode\r\n * @returns Decoded ASCII string\r\n */\r\nexport const DecodeBase64ToString = (base64Data: string): string => {\r\n    return atob(base64Data);\r\n};\r\n\r\n/**\r\n * Converts a given base64 string into an ArrayBuffer of raw byte data\r\n * @param base64Data The base64 encoded string to decode\r\n * @returns ArrayBuffer of byte data\r\n */\r\nexport const DecodeBase64ToBinary = (base64Data: string): ArrayBuffer => {\r\n    const decodedString = DecodeBase64ToString(base64Data);\r\n    const bufferLength = decodedString.length;\r\n    const bufferView = new Uint8Array(new ArrayBuffer(bufferLength));\r\n\r\n    for (let i = 0; i < bufferLength; i++) {\r\n        bufferView[i] = decodedString.charCodeAt(i);\r\n    }\r\n\r\n    return bufferView.buffer;\r\n};\r\n\r\n/**\r\n * Converts a number to string and pads with preceding zeroes until it is of specified length.\r\n * @param num the number to convert and pad\r\n * @param length the expected length of the string\r\n * @returns the padded string\r\n */\r\nexport const PadNumber = (num: number, length: number): string => {\r\n    let str = String(num);\r\n    while (str.length < length) {\r\n        str = \"0\" + str;\r\n    }\r\n    return str;\r\n};\r\n/**\r\n * Helper to manipulate strings\r\n */\r\nexport const StringTools = {\r\n    EndsWith,\r\n    StartsWith,\r\n    Decode,\r\n    EncodeArrayBufferToBase64,\r\n    DecodeBase64ToString,\r\n    DecodeBase64ToBinary,\r\n    PadNumber,\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { WebRequest } from \"./webRequest\";\r\nimport { IsWindowObjectExist } from \"./domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport type { IFileRequest } from \"./fileRequest\";\r\nimport { Observable } from \"./observable\";\r\nimport { FilesInputStore } from \"./filesInputStore\";\r\nimport { RetryStrategy } from \"./retryStrategy\";\r\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error\";\r\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools\";\r\nimport { _functionContainer } from \"../Engines/Processors/shaderProcessor\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Logger } from \"./logger\";\r\nimport { TimingTools } from \"./timingTools\";\r\nimport type { INative } from \"../Engines/Native/nativeInterfaces\";\r\nimport { EngineFunctionContext } from \"core/Engines/abstractEngine.functions\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\r\ndeclare const _native: INative;\r\n\r\n/** @ignore */\r\nexport class LoadFileError extends RuntimeError {\r\n    public request?: WebRequest;\r\n    public file?: File;\r\n\r\n    /**\r\n     * Creates a new LoadFileError\r\n     * @param message defines the message of the error\r\n     * @param object defines the optional web request\r\n     */\r\n    constructor(message: string, object?: WebRequest | File) {\r\n        super(message, ErrorCodes.LoadFileError);\r\n\r\n        this.name = \"LoadFileError\";\r\n        BaseError._setPrototypeOf(this, LoadFileError.prototype);\r\n\r\n        if (object instanceof WebRequest) {\r\n            this.request = object;\r\n        } else {\r\n            this.file = object;\r\n        }\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport class RequestFileError extends RuntimeError {\r\n    /**\r\n     * Creates a new LoadFileError\r\n     * @param message defines the message of the error\r\n     * @param request defines the optional web request\r\n     */\r\n    constructor(\r\n        message: string,\r\n        public request: WebRequest\r\n    ) {\r\n        super(message, ErrorCodes.RequestFileError);\r\n        this.name = \"RequestFileError\";\r\n        BaseError._setPrototypeOf(this, RequestFileError.prototype);\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport class ReadFileError extends RuntimeError {\r\n    /**\r\n     * Creates a new ReadFileError\r\n     * @param message defines the message of the error\r\n     * @param file defines the optional file\r\n     */\r\n    constructor(\r\n        message: string,\r\n        public file: File\r\n    ) {\r\n        super(message, ErrorCodes.ReadFileError);\r\n        this.name = \"ReadFileError\";\r\n        BaseError._setPrototypeOf(this, ReadFileError.prototype);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes unwanted characters from an url\r\n * @param url defines the url to clean\r\n * @returns the cleaned url\r\n */\r\nconst CleanUrl = (url: string): string => {\r\n    url = url.replace(/#/gm, \"%23\");\r\n    return url;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const FileToolsOptions: {\r\n    DefaultRetryStrategy: (url: string, request: WebRequest, retryIndex: number) => number;\r\n    BaseUrl: string;\r\n    CorsBehavior: string | ((url: string | string[]) => string);\r\n    PreprocessUrl: (url: string) => string;\r\n    ScriptBaseUrl: string;\r\n    ScriptPreprocessUrl: (url: string) => string;\r\n    CleanUrl: (url: string) => string;\r\n} = {\r\n    /**\r\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset.\r\n     * When defining this function, return the wait time before trying again or return -1 to\r\n     * stop retrying and error out.\r\n     */\r\n    DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\r\n\r\n    /**\r\n     * Gets or sets the base URL to use to load assets\r\n     */\r\n    BaseUrl: \"\",\r\n\r\n    /**\r\n     * Default behaviour for cors in the application.\r\n     * It can be a string if the expected behavior is identical in the entire app.\r\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\r\n     */\r\n    CorsBehavior: \"anonymous\",\r\n\r\n    /**\r\n     * Gets or sets a function used to pre-process url before using them to load assets\r\n     * @param url\r\n     * @returns the processed url\r\n     */\r\n    PreprocessUrl: (url: string) => url,\r\n\r\n    /**\r\n     * Gets or sets the base URL to use to load scripts\r\n     * Used for both JS and WASM\r\n     */\r\n    ScriptBaseUrl: \"\",\r\n    /**\r\n     * Gets or sets a function used to pre-process script url before using them to load.\r\n     * Used for both JS and WASM\r\n     * @param url defines the url to process\r\n     * @returns the processed url\r\n     */\r\n    ScriptPreprocessUrl: (url: string) => url,\r\n\r\n    /**\r\n     * Gets or sets a function used to clean the url before using it to load assets\r\n     * @param url defines the url to clean\r\n     * @returns the cleaned url\r\n     */\r\n    CleanUrl,\r\n};\r\n\r\n/**\r\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\r\n * @param url define the url we are trying\r\n * @param element define the dom element where to configure the cors policy\r\n * @internal\r\n */\r\nexport const SetCorsBehavior = (url: string | string[], element: { crossOrigin: string | null }): void => {\r\n    if (url && url.indexOf(\"data:\") === 0) {\r\n        return;\r\n    }\r\n\r\n    if (FileToolsOptions.CorsBehavior) {\r\n        if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\r\n            element.crossOrigin = <string>FileToolsOptions.CorsBehavior;\r\n        } else {\r\n            const result = FileToolsOptions.CorsBehavior(url);\r\n            if (result) {\r\n                element.crossOrigin = result;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Configuration used to load images\r\n * @see https://playground.babylonjs.com/#DKMEZK#2\r\n */\r\nexport const LoadImageConfiguration: {\r\n    /**\r\n     * Use this callback if you want to provide the required size of an image before loading it.\r\n     */\r\n    getRequiredSize: Nullable<\r\n        (input: string | ArrayBuffer | ArrayBufferView | Blob) => {\r\n            width: number;\r\n            height: number;\r\n        }\r\n    >;\r\n} = {\r\n    getRequiredSize: null,\r\n};\r\n\r\n/**\r\n * Loads an image as an HTMLImageElement.\r\n * @param input url string, ArrayBuffer, or Blob to load\r\n * @param onLoad callback called when the image successfully loads\r\n * @param onError callback called when the image fails to load\r\n * @param offlineProvider offline provider for caching\r\n * @param mimeType optional mime type\r\n * @param imageBitmapOptions\r\n * @param engine the engine instance to use\r\n * @returns the HTMLImageElement of the loaded image\r\n * @internal\r\n */\r\nexport const LoadImage = (\r\n    input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n    onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n    onError: (message?: string, exception?: any) => void,\r\n    offlineProvider: Nullable<IOfflineProvider>,\r\n    mimeType: string = \"\",\r\n    imageBitmapOptions?: ImageBitmapOptions,\r\n    engine = EngineStore.LastCreatedEngine\r\n): Nullable<HTMLImageElement> => {\r\n    if (typeof HTMLImageElement === \"undefined\" && !engine?._features.forceBitmapOverHTMLImageElement) {\r\n        onError(\"LoadImage is only supported in web or BabylonNative environments.\");\r\n        return null;\r\n    }\r\n\r\n    let url: string;\r\n    let usingObjectURL = false;\r\n\r\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\r\n        if (typeof Blob !== \"undefined\" && typeof URL !== \"undefined\") {\r\n            url = URL.createObjectURL(new Blob([input], { type: mimeType }));\r\n            usingObjectURL = true;\r\n        } else {\r\n            url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\r\n        }\r\n    } else if (input instanceof Blob) {\r\n        url = URL.createObjectURL(input);\r\n        usingObjectURL = true;\r\n    } else {\r\n        url = FileToolsOptions.CleanUrl(input);\r\n        url = FileToolsOptions.PreprocessUrl(url);\r\n    }\r\n\r\n    const onErrorHandler = (exception: any) => {\r\n        if (onError) {\r\n            const inputText = url || input.toString();\r\n            onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\r\n        }\r\n    };\r\n\r\n    if (engine?._features.forceBitmapOverHTMLImageElement) {\r\n        LoadFile(\r\n            url,\r\n            (data) => {\r\n                engine!\r\n                    .createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: \"none\", ...imageBitmapOptions })\r\n                    .then((imgBmp) => {\r\n                        onLoad(imgBmp);\r\n                        if (usingObjectURL) {\r\n                            URL.revokeObjectURL(url);\r\n                        }\r\n                    })\r\n                    .catch((reason) => {\r\n                        if (onError) {\r\n                            onError(\"Error while trying to load image: \" + input, reason);\r\n                        }\r\n                    });\r\n            },\r\n            undefined,\r\n            offlineProvider || undefined,\r\n            true,\r\n            (request, exception) => {\r\n                onErrorHandler(exception);\r\n            }\r\n        );\r\n\r\n        return null;\r\n    }\r\n\r\n    const img = new Image();\r\n    if (LoadImageConfiguration.getRequiredSize) {\r\n        const size = LoadImageConfiguration.getRequiredSize(input);\r\n        if (size.width) {\r\n            img.width = size.width;\r\n        }\r\n        if (size.height) {\r\n            img.height = size.height;\r\n        }\r\n    }\r\n    SetCorsBehavior(url, img);\r\n\r\n    const handlersList: { target: any; name: string; handler: any }[] = [];\r\n\r\n    const loadHandlersList = () => {\r\n        handlersList.forEach((handler) => {\r\n            handler.target.addEventListener(handler.name, handler.handler);\r\n        });\r\n    };\r\n\r\n    const unloadHandlersList = () => {\r\n        handlersList.forEach((handler) => {\r\n            handler.target.removeEventListener(handler.name, handler.handler);\r\n        });\r\n        handlersList.length = 0;\r\n    };\r\n\r\n    const loadHandler = () => {\r\n        unloadHandlersList();\r\n\r\n        onLoad(img);\r\n\r\n        // Must revoke the URL after calling onLoad to avoid security exceptions in\r\n        // certain scenarios (e.g. when hosted in vscode).\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n    };\r\n\r\n    const errorHandler = (err: any) => {\r\n        unloadHandlersList();\r\n\r\n        onErrorHandler(err);\r\n\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n    };\r\n\r\n    const cspHandler = (err: any) => {\r\n        if (err.blockedURI !== img.src || err.disposition === \"report\") {\r\n            return;\r\n        }\r\n\r\n        unloadHandlersList();\r\n        const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);\r\n\r\n        EngineStore.UseFallbackTexture = false;\r\n        onErrorHandler(cspException);\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n        img.src = \"\";\r\n    };\r\n\r\n    handlersList.push({ target: img, name: \"load\", handler: loadHandler });\r\n    handlersList.push({ target: img, name: \"error\", handler: errorHandler });\r\n    handlersList.push({ target: document, name: \"securitypolicyviolation\", handler: cspHandler });\r\n\r\n    loadHandlersList();\r\n\r\n    const fromBlob = url.substring(0, 5) === \"blob:\";\r\n    const fromData = url.substring(0, 5) === \"data:\";\r\n    const noOfflineSupport = () => {\r\n        if (fromBlob || fromData || !WebRequest.IsCustomRequestAvailable) {\r\n            img.src = url;\r\n        } else {\r\n            LoadFile(\r\n                url,\r\n                (data, _, contentType) => {\r\n                    const type = !mimeType && contentType ? contentType : mimeType;\r\n                    const blob = new Blob([data], { type });\r\n                    const url = URL.createObjectURL(blob);\r\n                    usingObjectURL = true;\r\n                    img.src = url;\r\n                },\r\n                undefined,\r\n                offlineProvider || undefined,\r\n                true,\r\n                (_request, exception) => {\r\n                    onErrorHandler(exception);\r\n                }\r\n            );\r\n        }\r\n    };\r\n\r\n    const loadFromOfflineSupport = () => {\r\n        if (offlineProvider) {\r\n            offlineProvider.loadImage(url, img);\r\n        }\r\n    };\r\n\r\n    if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {\r\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\r\n    } else {\r\n        if (url.indexOf(\"file:\") !== -1) {\r\n            const textureName = decodeURIComponent(url.substring(5).toLowerCase());\r\n            if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== \"undefined\") {\r\n                try {\r\n                    let blobURL;\r\n                    try {\r\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\r\n                    } catch (ex) {\r\n                        // Chrome doesn't support oneTimeOnly parameter\r\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\r\n                    }\r\n                    img.src = blobURL;\r\n                    usingObjectURL = true;\r\n                } catch (e) {\r\n                    img.src = \"\";\r\n                }\r\n                return img;\r\n            }\r\n        }\r\n\r\n        noOfflineSupport();\r\n    }\r\n\r\n    return img;\r\n};\r\n\r\n/**\r\n * Reads a file from a File object\r\n * @param file defines the file to load\r\n * @param onSuccess defines the callback to call when data is loaded\r\n * @param onProgress defines the callback to call during loading process\r\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n * @param onError defines the callback to call when an error occurs\r\n * @returns a file request object\r\n * @internal\r\n */\r\nexport const ReadFile = (\r\n    file: File,\r\n    onSuccess: (data: any) => void,\r\n    onProgress?: (ev: ProgressEvent) => any,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (error: ReadFileError) => void\r\n): IFileRequest => {\r\n    const reader = new FileReader();\r\n    const fileRequest: IFileRequest = {\r\n        onCompleteObservable: new Observable<IFileRequest>(),\r\n        abort: () => reader.abort(),\r\n    };\r\n\r\n    reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n    if (onError) {\r\n        reader.onerror = () => {\r\n            onError(new ReadFileError(`Unable to read ${file.name}`, file));\r\n        };\r\n    }\r\n    reader.onload = (e) => {\r\n        //target doesn't have result from ts 1.3\r\n        onSuccess((<any>e.target)[\"result\"]);\r\n    };\r\n    if (onProgress) {\r\n        reader.onprogress = onProgress;\r\n    }\r\n    if (!useArrayBuffer) {\r\n        // Asynchronous read\r\n        reader.readAsText(file);\r\n    } else {\r\n        reader.readAsArrayBuffer(file);\r\n    }\r\n\r\n    return fileRequest;\r\n};\r\n\r\n/**\r\n * Loads a file from a url, a data url, or a file url\r\n * @param fileOrUrl file, url, data url, or file url to load\r\n * @param onSuccess callback called when the file successfully loads\r\n * @param onProgress callback called while file is loading (if the server supports this mode)\r\n * @param offlineProvider defines the offline provider for caching\r\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n * @param onError callback called when the file fails to load\r\n * @param onOpened\r\n * @returns a file request object\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const LoadFile = (\r\n    fileOrUrl: File | string,\r\n    onSuccess: (data: string | ArrayBuffer, responseURL?: string, contentType?: Nullable<string>) => void,\r\n    onProgress?: (ev: ProgressEvent) => void,\r\n    offlineProvider?: IOfflineProvider,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n    onOpened?: (request: WebRequest) => void\r\n): IFileRequest => {\r\n    if ((fileOrUrl as File).name) {\r\n        return ReadFile(\r\n            fileOrUrl as File,\r\n            onSuccess,\r\n            onProgress,\r\n            useArrayBuffer,\r\n            onError\r\n                ? (error: ReadFileError) => {\r\n                      onError(undefined, error);\r\n                  }\r\n                : undefined\r\n        );\r\n    }\r\n\r\n    const url = fileOrUrl as string;\r\n\r\n    // If file and file input are set\r\n    if (url.indexOf(\"file:\") !== -1) {\r\n        let fileName = decodeURIComponent(url.substring(5).toLowerCase());\r\n        if (fileName.indexOf(\"./\") === 0) {\r\n            fileName = fileName.substring(2);\r\n        }\r\n        const file = FilesInputStore.FilesToLoad[fileName];\r\n        if (file) {\r\n            return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\r\n        }\r\n    }\r\n\r\n    // For a Base64 Data URL\r\n    const { match, type } = TestBase64DataUrl(url);\r\n    if (match) {\r\n        const fileRequest: IFileRequest = {\r\n            onCompleteObservable: new Observable<IFileRequest>(),\r\n            abort: () => () => {},\r\n        };\r\n\r\n        try {\r\n            const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);\r\n            onSuccess(data, undefined, type);\r\n        } catch (error) {\r\n            if (onError) {\r\n                onError(undefined, error);\r\n            } else {\r\n                Logger.Error(error.message || \"Failed to parse the Data URL\");\r\n            }\r\n        }\r\n\r\n        TimingTools.SetImmediate(() => {\r\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n        });\r\n\r\n        return fileRequest;\r\n    }\r\n\r\n    return RequestFile(\r\n        url,\r\n        (data, request) => {\r\n            onSuccess(data, request?.responseURL, request?.getResponseHeader(\"content-type\"));\r\n        },\r\n        onProgress,\r\n        offlineProvider,\r\n        useArrayBuffer,\r\n        onError\r\n            ? (error) => {\r\n                  onError(error.request, new LoadFileError(error.message, error.request));\r\n              }\r\n            : undefined,\r\n        onOpened\r\n    );\r\n};\r\n\r\n/**\r\n * Loads a file from a url\r\n * @param url url to load\r\n * @param onSuccess callback called when the file successfully loads\r\n * @param onProgress callback called while file is loading (if the server supports this mode)\r\n * @param offlineProvider defines the offline provider for caching\r\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n * @param onError callback called when the file fails to load\r\n * @param onOpened callback called when the web request is opened\r\n * @returns a file request object\r\n * @internal\r\n */\r\nexport const RequestFile = (\r\n    url: string,\r\n    onSuccess?: (data: string | ArrayBuffer, request?: WebRequest) => void,\r\n    onProgress?: (event: ProgressEvent) => void,\r\n    offlineProvider?: IOfflineProvider,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (error: RequestFileError) => void,\r\n    onOpened?: (request: WebRequest) => void\r\n): IFileRequest => {\r\n    url = FileToolsOptions.CleanUrl(url);\r\n    url = FileToolsOptions.PreprocessUrl(url);\r\n\r\n    const loadUrl = FileToolsOptions.BaseUrl + url;\r\n\r\n    let aborted = false;\r\n    const fileRequest: IFileRequest = {\r\n        onCompleteObservable: new Observable<IFileRequest>(),\r\n        abort: () => (aborted = true),\r\n    };\r\n\r\n    const requestFile = () => {\r\n        let request: Nullable<WebRequest> = new WebRequest();\r\n        let retryHandle: Nullable<ReturnType<typeof setTimeout>> = null;\r\n        let onReadyStateChange: Nullable<() => void>;\r\n\r\n        const unbindEvents = () => {\r\n            if (!request) {\r\n                return;\r\n            }\r\n\r\n            if (onProgress) {\r\n                request.removeEventListener(\"progress\", onProgress);\r\n            }\r\n            if (onReadyStateChange) {\r\n                request.removeEventListener(\"readystatechange\", onReadyStateChange);\r\n            }\r\n            request.removeEventListener(\"loadend\", onLoadEnd!);\r\n        };\r\n\r\n        let onLoadEnd: Nullable<() => void> = () => {\r\n            unbindEvents();\r\n\r\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n            fileRequest.onCompleteObservable.clear();\r\n\r\n            onProgress = undefined;\r\n            onReadyStateChange = null;\r\n            onLoadEnd = null;\r\n            onError = undefined;\r\n            onOpened = undefined;\r\n            onSuccess = undefined;\r\n        };\r\n\r\n        fileRequest.abort = () => {\r\n            aborted = true;\r\n\r\n            if (onLoadEnd) {\r\n                onLoadEnd();\r\n            }\r\n\r\n            if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\r\n                request.abort();\r\n            }\r\n\r\n            if (retryHandle !== null) {\r\n                clearTimeout(retryHandle);\r\n                retryHandle = null;\r\n            }\r\n\r\n            request = null;\r\n        };\r\n\r\n        const handleError = (error: any) => {\r\n            const message = error.message || \"Unknown error\";\r\n            if (onError && request) {\r\n                onError(new RequestFileError(message, request));\r\n            } else {\r\n                Logger.Error(message);\r\n            }\r\n        };\r\n\r\n        const retryLoop = (retryIndex: number) => {\r\n            if (!request) {\r\n                return;\r\n            }\r\n            request.open(\"GET\", loadUrl);\r\n\r\n            if (onOpened) {\r\n                try {\r\n                    onOpened(request);\r\n                } catch (e) {\r\n                    handleError(e);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (useArrayBuffer) {\r\n                request.responseType = \"arraybuffer\";\r\n            }\r\n\r\n            if (onProgress) {\r\n                request.addEventListener(\"progress\", onProgress);\r\n            }\r\n\r\n            if (onLoadEnd) {\r\n                request.addEventListener(\"loadend\", onLoadEnd);\r\n            }\r\n\r\n            onReadyStateChange = () => {\r\n                if (aborted || !request) {\r\n                    return;\r\n                }\r\n\r\n                // In case of undefined state in some browsers.\r\n                if (request.readyState === (XMLHttpRequest.DONE || 4)) {\r\n                    // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\r\n                    if (onReadyStateChange) {\r\n                        request.removeEventListener(\"readystatechange\", onReadyStateChange);\r\n                    }\r\n\r\n                    if ((request.status >= 200 && request.status < 300) || (request.status === 0 && (!IsWindowObjectExist() || IsFileURL()))) {\r\n                        // It's possible for the request to have a success status code but null response if the underlying\r\n                        // underlying HTTP connection was closed prematurely. See _onHttpResponseClose in xhr2.js. In this\r\n                        // case we will throw an exception if we call the onSuccess handler because \"data\" will be null\r\n                        // and that then bypasses the retry strategy.\r\n                        const data = useArrayBuffer ? request.response : request.responseText;\r\n                        if (data !== null) {\r\n                            try {\r\n                                if (onSuccess) {\r\n                                    onSuccess(data, request);\r\n                                }\r\n                            } catch (e) {\r\n                                handleError(e);\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\r\n                    if (retryStrategy) {\r\n                        const waitTime = retryStrategy(loadUrl, request, retryIndex);\r\n                        if (waitTime !== -1) {\r\n                            // Prevent the request from completing for retry.\r\n                            unbindEvents();\r\n\r\n                            request = new WebRequest();\r\n                            retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\r\n                    if (onError) {\r\n                        onError(error);\r\n                    }\r\n                }\r\n            };\r\n\r\n            request.addEventListener(\"readystatechange\", onReadyStateChange);\r\n\r\n            request.send();\r\n        };\r\n\r\n        retryLoop(0);\r\n    };\r\n\r\n    // Caching all files\r\n    if (offlineProvider && offlineProvider.enableSceneOffline) {\r\n        const noOfflineSupport = (request?: any) => {\r\n            if (request && request.status > 400) {\r\n                if (onError) {\r\n                    onError(request);\r\n                }\r\n            } else {\r\n                requestFile();\r\n            }\r\n        };\r\n\r\n        const loadFromOfflineSupport = () => {\r\n            // TODO: database needs to support aborting and should return a IFileRequest\r\n\r\n            if (offlineProvider) {\r\n                offlineProvider.loadFile(\r\n                    FileToolsOptions.BaseUrl + url,\r\n                    (data) => {\r\n                        if (!aborted && onSuccess) {\r\n                            onSuccess(data);\r\n                        }\r\n\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                    },\r\n                    onProgress\r\n                        ? (event) => {\r\n                              if (!aborted && onProgress) {\r\n                                  onProgress(event);\r\n                              }\r\n                          }\r\n                        : undefined,\r\n                    noOfflineSupport,\r\n                    useArrayBuffer\r\n                );\r\n            }\r\n        };\r\n\r\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\r\n    } else {\r\n        requestFile();\r\n    }\r\n\r\n    return fileRequest;\r\n};\r\n\r\n/**\r\n * Reads the mime type from a URL, if available.\r\n * @param url\r\n * @returns\r\n */\r\nexport const GetMimeType = (url: string): string | undefined => {\r\n    const { match, type } = TestBase64DataUrl(url);\r\n    if (match) {\r\n        return type || undefined;\r\n    }\r\n\r\n    const lastDot = url.lastIndexOf(\".\");\r\n    const extension = url.substring(lastDot + 1).toLowerCase();\r\n\r\n    switch (extension) {\r\n        case \"glb\":\r\n            return \"model/gltf-binary\";\r\n        case \"bin\":\r\n            return \"application/octet-stream\";\r\n        case \"gltf\":\r\n            return \"model/gltf+json\";\r\n        case \"jpg\":\r\n        case \"jpeg\":\r\n            return \"image/jpeg\";\r\n        case \"png\":\r\n            return \"image/png\";\r\n        case \"webp\":\r\n            return \"image/webp\";\r\n        default:\r\n            return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Checks if the loaded document was accessed via `file:`-Protocol.\r\n * @returns boolean\r\n * @internal\r\n */\r\nexport const IsFileURL = (): boolean => {\r\n    return typeof location !== \"undefined\" && location.protocol === \"file:\";\r\n};\r\n\r\n/**\r\n * Test if the given uri is a valid base64 data url\r\n * @param uri The uri to test\r\n * @returns True if the uri is a base64 data url or false otherwise\r\n * @internal\r\n */\r\nexport const IsBase64DataUrl = (uri: string): boolean => {\r\n    return Base64DataUrlRegEx.test(uri);\r\n};\r\n\r\nexport const TestBase64DataUrl = (uri: string): { match: boolean; type: string } => {\r\n    const results = Base64DataUrlRegEx.exec(uri);\r\n    if (results === null || results.length === 0) {\r\n        return { match: false, type: \"\" };\r\n    } else {\r\n        const type = results[0].replace(\"data:\", \"\").replace(\"base64,\", \"\");\r\n        return { match: true, type };\r\n    }\r\n};\r\n\r\n/**\r\n * Decode the given base64 uri.\r\n * @param uri The uri to decode\r\n * @returns The decoded base64 data.\r\n * @internal\r\n */\r\nexport function DecodeBase64UrlToBinary(uri: string): ArrayBuffer {\r\n    return DecodeBase64ToBinary(uri.split(\",\")[1]);\r\n}\r\n\r\n/**\r\n * Decode the given base64 uri into a UTF-8 encoded string.\r\n * @param uri The uri to decode\r\n * @returns The decoded base64 data.\r\n * @internal\r\n */\r\nexport const DecodeBase64UrlToString = (uri: string): string => {\r\n    return DecodeBase64ToString(uri.split(\",\")[1]);\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    AbstractEngine._FileToolsLoadImage = LoadImage;\r\n    EngineFunctionContext.loadFile = LoadFile;\r\n    _functionContainer.loadFile = LoadFile;\r\n};\r\n\r\ninitSideEffects();\r\n\r\n// deprecated\r\n\r\n/**\r\n * FileTools defined as any.\r\n * This should not be imported or used in future releases or in any module in the framework\r\n * @internal\r\n * @deprecated import the needed function from fileTools.ts\r\n */\r\nexport let FileTools: {\r\n    DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer;\r\n    DecodeBase64UrlToString: (uri: string) => string;\r\n    DefaultRetryStrategy: any;\r\n    BaseUrl: any;\r\n    CorsBehavior: any;\r\n    PreprocessUrl: any;\r\n    IsBase64DataUrl: (uri: string) => boolean;\r\n    IsFileURL: () => boolean;\r\n    LoadFile: (\r\n        fileOrUrl: string | File,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest;\r\n    LoadImage: (\r\n        input: string | ArrayBuffer | Blob | ArrayBufferView,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string | undefined, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string | undefined,\r\n        imageBitmapOptions?: ImageBitmapOptions | undefined\r\n    ) => Nullable<HTMLImageElement>;\r\n    ReadFile: (\r\n        file: File,\r\n        onSuccess: (data: any) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: ReadFileError) => void) | undefined\r\n    ) => IFileRequest;\r\n    RequestFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void,\r\n        onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: RequestFileError) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest;\r\n    SetCorsBehavior: (url: string | string[], element: { crossOrigin: string | null }) => void;\r\n};\r\n/**\r\n * @internal\r\n */\r\nexport const _injectLTSFileTools = (\r\n    DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer,\r\n    DecodeBase64UrlToString: (uri: string) => string,\r\n    FileToolsOptions: { DefaultRetryStrategy: any; BaseUrl: any; CorsBehavior: any; PreprocessUrl: any; CleanUrl: any },\r\n    IsBase64DataUrl: (uri: string) => boolean,\r\n    IsFileURL: () => boolean,\r\n    LoadFile: (\r\n        fileOrUrl: string | File,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest,\r\n    LoadImage: (\r\n        input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string | undefined, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string,\r\n        imageBitmapOptions?: ImageBitmapOptions | undefined\r\n    ) => Nullable<HTMLImageElement>,\r\n    ReadFile: (\r\n        file: File,\r\n        onSuccess: (data: any) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: ReadFileError) => void) | undefined\r\n    ) => IFileRequest,\r\n    RequestFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void,\r\n        onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: RequestFileError) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest,\r\n    SetCorsBehavior: (url: string | string[], element: { crossOrigin: string | null }) => void\r\n) => {\r\n    /**\r\n     * Backwards compatibility.\r\n     * @internal\r\n     * @deprecated\r\n     */\r\n    FileTools = {\r\n        DecodeBase64UrlToBinary,\r\n        DecodeBase64UrlToString,\r\n        DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\r\n        BaseUrl: FileToolsOptions.BaseUrl,\r\n        CorsBehavior: FileToolsOptions.CorsBehavior,\r\n        PreprocessUrl: FileToolsOptions.PreprocessUrl,\r\n        IsBase64DataUrl,\r\n        IsFileURL,\r\n        LoadFile,\r\n        LoadImage,\r\n        ReadFile,\r\n        RequestFile,\r\n        SetCorsBehavior,\r\n    };\r\n\r\n    Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.DefaultRetryStrategy;\r\n        },\r\n        set: function (this: null, value: (url: string, request: WebRequest, retryIndex: number) => number) {\r\n            FileToolsOptions.DefaultRetryStrategy = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"BaseUrl\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.BaseUrl;\r\n        },\r\n        set: function (this: null, value: string) {\r\n            FileToolsOptions.BaseUrl = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"PreprocessUrl\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.PreprocessUrl;\r\n        },\r\n        set: function (this: null, value: (url: string) => string) {\r\n            FileToolsOptions.PreprocessUrl = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"CorsBehavior\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.CorsBehavior;\r\n        },\r\n        set: function (this: null, value: string | ((url: string | string[]) => string)) {\r\n            FileToolsOptions.CorsBehavior = value;\r\n        },\r\n    });\r\n};\r\n\r\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);\r\n", "import { Logger } from \"./logger\";\r\nimport { GetClass } from \"./typeStore\";\r\n\r\n/**\r\n * Class used to enable instantiation of objects by class name\r\n */\r\nexport class InstantiationTools {\r\n    /**\r\n     * Use this object to register external classes like custom textures or material\r\n     * to allow the loaders to instantiate them\r\n     */\r\n    public static RegisteredExternalClasses: { [key: string]: Object } = {};\r\n\r\n    /**\r\n     * Tries to instantiate a new object from a given class name\r\n     * @param className defines the class name to instantiate\r\n     * @returns the new object or null if the system was not able to do the instantiation\r\n     */\r\n    public static Instantiate(className: string): any {\r\n        if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className]) {\r\n            return this.RegisteredExternalClasses[className];\r\n        }\r\n\r\n        const internalClass = GetClass(className);\r\n        if (internalClass) {\r\n            return internalClass;\r\n        }\r\n\r\n        Logger.Warn(className + \" not found, you may have missed an import.\");\r\n\r\n        const arr = className.split(\".\");\r\n\r\n        let fn: any = window || this;\r\n        for (let i = 0, len = arr.length; i < len; i++) {\r\n            fn = fn[arr[i]];\r\n        }\r\n\r\n        if (typeof fn !== \"function\") {\r\n            return null;\r\n        }\r\n\r\n        return fn;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["url", "DecodeBase64UrlToBinary", "DecodeBase64UrlToString", "FileToolsOptions", "IsBase64DataUrl", "IsFileURL", "LoadFile", "LoadImage", "ReadFile", "RequestFile", "SetCorsBehavior"]
}
