{
  "version": 3,
  "sources": ["../../../dev/core/src/Maths/math.path.ts"],
  "sourcesContent": ["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Clamp, WithinEpsilon } from \"./math.scalar.functions\";\r\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector\";\r\nimport type { Vector4 } from \"./math.vector\";\r\nimport { Epsilon } from \"./math.constants\";\r\n\r\n/**\r\n * Defines potential orientation for back face culling\r\n */\r\nexport const enum Orientation {\r\n    /**\r\n     * Clockwise\r\n     */\r\n    CW = 0,\r\n    /** Counter clockwise */\r\n    CCW = 1,\r\n}\r\n\r\n/** Class used to represent a Bezier curve */\r\nexport class BezierCurve {\r\n    /**\r\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\r\n     * @param t defines the time\r\n     * @param x1 defines the left coordinate on X axis\r\n     * @param y1 defines the left coordinate on Y axis\r\n     * @param x2 defines the right coordinate on X axis\r\n     * @param y2 defines the right coordinate on Y axis\r\n     * @returns the interpolated value\r\n     */\r\n    public static Interpolate(t: number, x1: number, y1: number, x2: number, y2: number): number {\r\n        if (t === 0) {\r\n            return 0;\r\n        }\r\n        // Extract X (which is equal to time here)\r\n        const f0 = 1 - 3 * x2 + 3 * x1;\r\n        const f1 = 3 * x2 - 6 * x1;\r\n        const f2 = 3 * x1;\r\n\r\n        let refinedT = t;\r\n        for (let i = 0; i < 5; i++) {\r\n            const refinedT2 = refinedT * refinedT;\r\n            const refinedT3 = refinedT2 * refinedT;\r\n\r\n            const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\r\n            const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\r\n            refinedT -= (x - t) * slope;\r\n            refinedT = Math.min(1, Math.max(0, refinedT));\r\n        }\r\n\r\n        // Resolve cubic bezier for the given x\r\n        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines angle representation\r\n */\r\nexport class Angle {\r\n    private _radians: number;\r\n\r\n    /**\r\n     * Creates an Angle object of \"radians\" radians (float).\r\n     * @param radians the angle in radians\r\n     */\r\n    constructor(radians: number) {\r\n        this._radians = radians;\r\n        if (this._radians < 0.0) {\r\n            this._radians += 2.0 * Math.PI;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get value in degrees\r\n     * @returns the Angle value in degrees (float)\r\n     */\r\n    public degrees() {\r\n        return (this._radians * 180.0) / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * Get value in radians\r\n     * @returns the Angle value in radians (float)\r\n     */\r\n    public radians() {\r\n        return this._radians;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Angle object with a value of the angle (in radians) between the line connecting the two points and the x-axis\r\n     * @param a defines first point as the origin\r\n     * @param b defines point\r\n     * @returns a new Angle\r\n     */\r\n    public static BetweenTwoPoints(a: DeepImmutable<Vector2>, b: DeepImmutable<Vector2>): Angle {\r\n        const delta = b.subtract(a);\r\n        const theta = Math.atan2(delta.y, delta.x);\r\n        return new Angle(theta);\r\n    }\r\n\r\n    /**\r\n     * Gets the angle between the two vectors\r\n     * @param a defines first vector\r\n     * @param b defines vector\r\n     * @returns Returns an new Angle between 0 and PI\r\n     */\r\n    public static BetweenTwoVectors<Vec extends Vector2 | Vector3 | Vector4>(a: DeepImmutable<Vec>, b: DeepImmutable<Vec>): Angle {\r\n        let product = a.lengthSquared() * b.lengthSquared();\r\n        if (product === 0) return new Angle(Math.PI / 2);\r\n        product = Math.sqrt(product);\r\n        let cosVal = a.dot(b as any) / product;\r\n        cosVal = Clamp(cosVal, -1, 1);\r\n        const angle = Math.acos(cosVal);\r\n        return new Angle(angle);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Angle object from the given float in radians\r\n     * @param radians defines the angle value in radians\r\n     * @returns a new Angle\r\n     */\r\n    public static FromRadians(radians: number): Angle {\r\n        return new Angle(radians);\r\n    }\r\n    /**\r\n     * Gets a new Angle object from the given float in degrees\r\n     * @param degrees defines the angle value in degrees\r\n     * @returns a new Angle\r\n     */\r\n    public static FromDegrees(degrees: number): Angle {\r\n        return new Angle((degrees * Math.PI) / 180.0);\r\n    }\r\n}\r\n\r\n/**\r\n * This represents an arc in a 2d space.\r\n */\r\nexport class Arc2 {\r\n    /**\r\n     * Defines the center point of the arc.\r\n     */\r\n    public centerPoint: Vector2;\r\n    /**\r\n     * Defines the radius of the arc.\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Defines the angle of the arc (from mid point to end point).\r\n     */\r\n    public angle: Angle;\r\n    /**\r\n     * Defines the start angle of the arc (from start point to middle point).\r\n     */\r\n    public startAngle: Angle;\r\n    /**\r\n     * Defines the orientation of the arc (clock wise/counter clock wise).\r\n     */\r\n    public orientation: Orientation;\r\n\r\n    /**\r\n     * Creates an Arc object from the three given points : start, middle and end.\r\n     * @param startPoint Defines the start point of the arc\r\n     * @param midPoint Defines the middle point of the arc\r\n     * @param endPoint Defines the end point of the arc\r\n     */\r\n    constructor(\r\n        /** Defines the start point of the arc */\r\n        public startPoint: Vector2,\r\n        /** Defines the mid point of the arc */\r\n        public midPoint: Vector2,\r\n        /** Defines the end point of the arc */\r\n        public endPoint: Vector2\r\n    ) {\r\n        const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\r\n        const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\r\n        const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\r\n        const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\r\n\r\n        this.centerPoint = new Vector2(\r\n            (startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det,\r\n            ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det\r\n        );\r\n\r\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\r\n\r\n        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\r\n\r\n        const a1 = this.startAngle.degrees();\r\n        let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\r\n        let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\r\n\r\n        // angles correction\r\n        if (a2 - a1 > +180.0) {\r\n            a2 -= 360.0;\r\n        }\r\n        if (a2 - a1 < -180.0) {\r\n            a2 += 360.0;\r\n        }\r\n        if (a3 - a2 > +180.0) {\r\n            a3 -= 360.0;\r\n        }\r\n        if (a3 - a2 < -180.0) {\r\n            a3 += 360.0;\r\n        }\r\n\r\n        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\r\n        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a 2D path made up of multiple 2D points\r\n */\r\nexport class Path2 {\r\n    private _points = new Array<Vector2>();\r\n    private _length = 0.0;\r\n\r\n    /**\r\n     * If the path start and end point are the same\r\n     */\r\n    public closed = false;\r\n\r\n    /**\r\n     * Creates a Path2 object from the starting 2D coordinates x and y.\r\n     * @param x the starting points x value\r\n     * @param y the starting points y value\r\n     */\r\n    constructor(x: number, y: number) {\r\n        this._points.push(new Vector2(x, y));\r\n    }\r\n\r\n    /**\r\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\r\n     * @param x the added points x value\r\n     * @param y the added points y value\r\n     * @returns the updated Path2.\r\n     */\r\n    public addLineTo(x: number, y: number): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        const newPoint = new Vector2(x, y);\r\n        const previousPoint = this._points[this._points.length - 1];\r\n        this._points.push(newPoint);\r\n        this._length += newPoint.subtract(previousPoint).length();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\r\n     * @param midX middle point x value\r\n     * @param midY middle point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addArcTo(midX: number, midY: number, endX: number, endY: number, numberOfSegments = 36): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        const startPoint = this._points[this._points.length - 1];\r\n        const midPoint = new Vector2(midX, midY);\r\n        const endPoint = new Vector2(endX, endY);\r\n\r\n        const arc = new Arc2(startPoint, midPoint, endPoint);\r\n\r\n        let increment = arc.angle.radians() / numberOfSegments;\r\n        if (arc.orientation === Orientation.CW) {\r\n            increment *= -1;\r\n        }\r\n        let currentAngle = arc.startAngle.radians() + increment;\r\n\r\n        for (let i = 0; i < numberOfSegments; i++) {\r\n            const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\r\n            const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\r\n            this.addLineTo(x, y);\r\n            currentAngle += increment;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the quadratic curve definition to the current Path2.\r\n     * @param controlX control point x value\r\n     * @param controlY control point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addQuadraticCurveTo(controlX: number, controlY: number, endX: number, endY: number, numberOfSegments = 36): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n\r\n        const equation = (t: number, val0: number, val1: number, val2: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        const startPoint = this._points[this._points.length - 1];\r\n        for (let i = 0; i <= numberOfSegments; i++) {\r\n            const step = i / numberOfSegments;\r\n            const x = equation(step, startPoint.x, controlX, endX);\r\n            const y = equation(step, startPoint.y, controlY, endY);\r\n            this.addLineTo(x, y);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the bezier curve definition to the current Path2.\r\n     * @param originTangentX tangent vector at the origin point x value\r\n     * @param originTangentY tangent vector at the origin point y value\r\n     * @param destinationTangentX tangent vector at the destination point x value\r\n     * @param destinationTangentY tangent vector at the destination point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addBezierCurveTo(\r\n        originTangentX: number,\r\n        originTangentY: number,\r\n        destinationTangentX: number,\r\n        destinationTangentY: number,\r\n        endX: number,\r\n        endY: number,\r\n        numberOfSegments = 36\r\n    ): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n\r\n        const equation = (t: number, val0: number, val1: number, val2: number, val3: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        const startPoint = this._points[this._points.length - 1];\r\n        for (let i = 0; i <= numberOfSegments; i++) {\r\n            const step = i / numberOfSegments;\r\n            const x = equation(step, startPoint.x, originTangentX, destinationTangentX, endX);\r\n            const y = equation(step, startPoint.y, originTangentY, destinationTangentY, endY);\r\n            this.addLineTo(x, y);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Defines if a given point is inside the polygon defines by the path\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside\r\n     */\r\n    public isPointInside(point: Vector2) {\r\n        let isInside = false;\r\n        const count = this._points.length;\r\n        for (let p = count - 1, q = 0; q < count; p = q++) {\r\n            let edgeLow = this._points[p];\r\n            let edgeHigh = this._points[q];\r\n\r\n            let edgeDx = edgeHigh.x - edgeLow.x;\r\n            let edgeDy = edgeHigh.y - edgeLow.y;\r\n\r\n            if (Math.abs(edgeDy) > Number.EPSILON) {\r\n                // Not parallel\r\n                if (edgeDy < 0) {\r\n                    edgeLow = this._points[q];\r\n                    edgeDx = -edgeDx;\r\n                    edgeHigh = this._points[p];\r\n                    edgeDy = -edgeDy;\r\n                }\r\n\r\n                if (point.y < edgeLow.y || point.y > edgeHigh.y) {\r\n                    continue;\r\n                }\r\n\r\n                if (point.y === edgeLow.y && point.x === edgeLow.x) {\r\n                    return true;\r\n                } else {\r\n                    const perpEdge = edgeDy * (point.x - edgeLow.x) - edgeDx * (point.y - edgeLow.y);\r\n                    if (perpEdge === 0) {\r\n                        return true;\r\n                    }\r\n                    if (perpEdge < 0) {\r\n                        continue;\r\n                    }\r\n                    isInside = !isInside;\r\n                }\r\n            } else {\r\n                // parallel or collinear\r\n                if (point.y !== edgeLow.y) {\r\n                    continue;\r\n                }\r\n\r\n                if ((edgeHigh.x <= point.x && point.x <= edgeLow.x) || (edgeLow.x <= point.x && point.x <= edgeHigh.x)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return isInside;\r\n    }\r\n\r\n    /**\r\n     * Closes the Path2.\r\n     * @returns the Path2.\r\n     */\r\n    public close(): Path2 {\r\n        this.closed = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets the sum of the distance between each sequential point in the path\r\n     * @returns the Path2 total length (float).\r\n     */\r\n    public length(): number {\r\n        let result = this._length;\r\n\r\n        if (this.closed) {\r\n            const lastPoint = this._points[this._points.length - 1];\r\n            const firstPoint = this._points[0];\r\n            result += firstPoint.subtract(lastPoint).length();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the area of the polygon defined by the path\r\n     * @returns area value\r\n     */\r\n    public area(): number {\r\n        const n = this._points.length;\r\n        let value = 0.0;\r\n\r\n        for (let p = n - 1, q = 0; q < n; p = q++) {\r\n            value += this._points[p].x * this._points[q].y - this._points[q].x * this._points[p].y;\r\n        }\r\n\r\n        return value * 0.5;\r\n    }\r\n\r\n    /**\r\n     * Gets the points which construct the path\r\n     * @returns the Path2 internal array of points.\r\n     */\r\n    public getPoints(): Vector2[] {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the point at the distance aways from the starting point\r\n     * @param normalizedLengthPosition the length along the path to retrieve the point from\r\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\r\n     */\r\n    public getPointAtLengthPosition(normalizedLengthPosition: number): Vector2 {\r\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\r\n            return Vector2.Zero();\r\n        }\r\n\r\n        const lengthPosition = normalizedLengthPosition * this.length();\r\n\r\n        let previousOffset = 0;\r\n        for (let i = 0; i < this._points.length; i++) {\r\n            const j = (i + 1) % this._points.length;\r\n\r\n            const a = this._points[i];\r\n            const b = this._points[j];\r\n            const bToA = b.subtract(a);\r\n\r\n            const nextOffset = bToA.length() + previousOffset;\r\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\r\n                const dir = bToA.normalize();\r\n                const localOffset = lengthPosition - previousOffset;\r\n\r\n                return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\r\n            }\r\n            previousOffset = nextOffset;\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * Creates a new path starting from an x and y position\r\n     * @param x starting x value\r\n     * @param y starting y value\r\n     * @returns a new Path2 starting at the coordinates (x, y).\r\n     */\r\n    public static StartingAt(x: number, y: number): Path2 {\r\n        return new Path2(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a 3D path made up of multiple 3D points\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\r\n */\r\nexport class Path3D {\r\n    private _curve = new Array<Vector3>();\r\n    private _distances = new Array<number>();\r\n    private _tangents = new Array<Vector3>();\r\n    private _normals = new Array<Vector3>();\r\n    private _binormals = new Array<Vector3>();\r\n    private _raw: boolean;\r\n    private _alignTangentsWithPath: boolean;\r\n\r\n    // holds interpolated point data\r\n    private readonly _pointAtData = {\r\n        id: 0,\r\n        point: Vector3.Zero(),\r\n        previousPointArrayIndex: 0,\r\n\r\n        position: 0,\r\n        subPosition: 0,\r\n\r\n        interpolateReady: false,\r\n        interpolationMatrix: Matrix.Identity(),\r\n    };\r\n\r\n    /**\r\n     * new Path3D(path, normal, raw)\r\n     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\r\n     * please read the description in the tutorial : https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\r\n     * @param path an array of Vector3, the curve axis of the Path3D\r\n     * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\r\n     * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\r\n     */\r\n    constructor(\r\n        /**\r\n         * an array of Vector3, the curve axis of the Path3D\r\n         */\r\n        public path: Vector3[],\r\n        firstNormal: Nullable<Vector3> = null,\r\n        raw?: boolean,\r\n        alignTangentsWithPath = false\r\n    ) {\r\n        for (let p = 0; p < path.length; p++) {\r\n            this._curve[p] = path[p].clone(); // hard copy\r\n        }\r\n        this._raw = raw || false;\r\n        this._alignTangentsWithPath = alignTangentsWithPath;\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n    }\r\n\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    public getCurve(): Vector3[] {\r\n        return this._curve;\r\n    }\r\n\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    public getPoints(): Vector3[] {\r\n        return this._curve;\r\n    }\r\n\r\n    /**\r\n     * @returns the computed length (float) of the path.\r\n     */\r\n    public length() {\r\n        return this._distances[this._distances.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with tangent vectors on each Path3D curve point.\r\n     * @returns an array populated with tangent vectors on each Path3D curve point.\r\n     */\r\n    public getTangents(): Vector3[] {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with normal vectors on each Path3D curve point.\r\n     * @returns an array populated with normal vectors on each Path3D curve point.\r\n     */\r\n    public getNormals(): Vector3[] {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with binormal vectors on each Path3D curve point.\r\n     * @returns an array populated with binormal vectors on each Path3D curve point.\r\n     */\r\n    public getBinormals(): Vector3[] {\r\n        return this._binormals;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     */\r\n    public getDistances(): number[] {\r\n        return this._distances;\r\n    }\r\n\r\n    /**\r\n     * Returns an interpolated point along this path\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns a new Vector3 as the point\r\n     */\r\n    public getPointAt(position: number): Vector3 {\r\n        return this._updatePointAtData(position).point;\r\n    }\r\n\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\r\n     * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\r\n     */\r\n    public getTangentAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\r\n     * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\r\n     */\r\n    public getNormalAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\r\n     * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\r\n     */\r\n    public getBinormalAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\r\n     */\r\n    public getDistanceAt(position: number): number {\r\n        return this.length() * position;\r\n    }\r\n\r\n    /**\r\n     * Returns the array index of the previous point of an interpolated point along this path\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the array index\r\n     */\r\n    public getPreviousPointIndexAt(position: number) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.previousPointArrayIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the sub position\r\n     */\r\n    public getSubPositionAt(position: number) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.subPosition;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\r\n     * @param target the vector of which to get the closest position to\r\n     * @returns the position of the closest virtual point on this path to the target vector\r\n     */\r\n    public getClosestPositionTo(target: Vector3) {\r\n        let smallestDistance = Number.MAX_VALUE;\r\n        let closestPosition = 0.0;\r\n        for (let i = 0; i < this._curve.length - 1; i++) {\r\n            const point = this._curve[i + 0];\r\n            const tangent = this._curve[i + 1].subtract(point).normalize();\r\n            const subLength = this._distances[i + 1] - this._distances[i + 0];\r\n            const subPosition = Math.min((Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target)) / subLength, 1.0);\r\n            const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\r\n\r\n            if (distance < smallestDistance) {\r\n                smallestDistance = distance;\r\n                closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\r\n            }\r\n        }\r\n        return closestPosition;\r\n    }\r\n\r\n    /**\r\n     * Returns a sub path (slice) of this path\r\n     * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @returns a sub path (slice) of this path\r\n     */\r\n    public slice(start: number = 0.0, end: number = 1.0) {\r\n        if (start < 0.0) {\r\n            start = 1 - ((start * -1.0) % 1.0);\r\n        }\r\n        if (end < 0.0) {\r\n            end = 1 - ((end * -1.0) % 1.0);\r\n        }\r\n        if (start > end) {\r\n            const _start = start;\r\n            start = end;\r\n            end = _start;\r\n        }\r\n        const curvePoints = this.getCurve();\r\n\r\n        const startPoint = this.getPointAt(start);\r\n        let startIndex = this.getPreviousPointIndexAt(start);\r\n\r\n        const endPoint = this.getPointAt(end);\r\n        const endIndex = this.getPreviousPointIndexAt(end) + 1;\r\n\r\n        const slicePoints: Vector3[] = [];\r\n        if (start !== 0.0) {\r\n            startIndex++;\r\n            slicePoints.push(startPoint);\r\n        }\r\n\r\n        slicePoints.push(...curvePoints.slice(startIndex, endIndex));\r\n        if (end !== 1.0 || start === 1.0) {\r\n            slicePoints.push(endPoint);\r\n        }\r\n        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\r\n    }\r\n\r\n    /**\r\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\r\n     * @param path path which all values are copied into the curves points\r\n     * @param firstNormal which should be projected onto the curve\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\r\n     * @returns the same object updated.\r\n     */\r\n    public update(path: Vector3[], firstNormal: Nullable<Vector3> = null, alignTangentsWithPath = false): Path3D {\r\n        for (let p = 0; p < path.length; p++) {\r\n            this._curve[p].x = path[p].x;\r\n            this._curve[p].y = path[p].y;\r\n            this._curve[p].z = path[p].z;\r\n        }\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n        return this;\r\n    }\r\n\r\n    // private function compute() : computes tangents, normals and binormals\r\n    private _compute(firstNormal: Nullable<Vector3>, alignTangentsWithPath = false): void {\r\n        const l = this._curve.length;\r\n\r\n        if (l < 2) {\r\n            return;\r\n        }\r\n\r\n        // first and last tangents\r\n        this._tangents[0] = this._getFirstNonNullVector(0);\r\n        if (!this._raw) {\r\n            this._tangents[0].normalize();\r\n        }\r\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\r\n        if (!this._raw) {\r\n            this._tangents[l - 1].normalize();\r\n        }\r\n\r\n        // normals and binormals at first point : arbitrary vector with _normalVector()\r\n        const tg0 = this._tangents[0];\r\n        const pp0 = this._normalVector(tg0, firstNormal);\r\n        this._normals[0] = pp0;\r\n        if (!this._raw) {\r\n            this._normals[0].normalize();\r\n        }\r\n        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\r\n        if (!this._raw) {\r\n            this._binormals[0].normalize();\r\n        }\r\n        this._distances[0] = 0.0;\r\n\r\n        // normals and binormals : next points\r\n        let prev: Vector3; // previous vector (segment)\r\n        let cur: Vector3; // current vector (segment)\r\n        let curTang: Vector3; // current tangent\r\n        // previous normal\r\n        let prevNor: Vector3; // previous normal\r\n        let prevBinor: Vector3; // previous binormal\r\n\r\n        for (let i = 1; i < l; i++) {\r\n            // tangents\r\n            prev = this._getLastNonNullVector(i);\r\n            if (i < l - 1) {\r\n                cur = this._getFirstNonNullVector(i);\r\n                this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\r\n                this._tangents[i].normalize();\r\n            }\r\n            this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\r\n\r\n            // normals and binormals\r\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\r\n            curTang = this._tangents[i];\r\n            prevBinor = this._binormals[i - 1];\r\n            this._normals[i] = Vector3.Cross(prevBinor, curTang);\r\n            if (!this._raw) {\r\n                if (this._normals[i].length() === 0) {\r\n                    prevNor = this._normals[i - 1];\r\n                    this._normals[i] = prevNor.clone();\r\n                } else {\r\n                    this._normals[i].normalize();\r\n                }\r\n            }\r\n            this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\r\n            if (!this._raw) {\r\n                this._binormals[i].normalize();\r\n            }\r\n        }\r\n        this._pointAtData.id = NaN;\r\n    }\r\n\r\n    // private function getFirstNonNullVector(index)\r\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\r\n    private _getFirstNonNullVector(index: number): Vector3 {\r\n        let i = 1;\r\n        let nNVector: Vector3 = this._curve[index + i].subtract(this._curve[index]);\r\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\r\n            i++;\r\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\r\n        }\r\n        return nNVector;\r\n    }\r\n\r\n    // private function getLastNonNullVector(index)\r\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\r\n    private _getLastNonNullVector(index: number): Vector3 {\r\n        let i = 1;\r\n        let nLVector: Vector3 = this._curve[index].subtract(this._curve[index - i]);\r\n        while (nLVector.length() === 0 && index > i + 1) {\r\n            i++;\r\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\r\n        }\r\n        return nLVector;\r\n    }\r\n\r\n    // private function normalVector(v0, vt, va) :\r\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\r\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\r\n    private _normalVector(vt: Vector3, va: Nullable<Vector3>): Vector3 {\r\n        let normal0: Vector3;\r\n        let tgl = vt.length();\r\n        if (tgl === 0.0) {\r\n            tgl = 1.0;\r\n        }\r\n\r\n        if (va === undefined || va === null) {\r\n            let point: Vector3;\r\n            if (!WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\r\n                // search for a point in the plane\r\n                point = new Vector3(0.0, -1.0, 0.0);\r\n            } else if (!WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(1.0, 0.0, 0.0);\r\n            } else if (!WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(0.0, 0.0, 1.0);\r\n            } else {\r\n                point = Vector3.Zero();\r\n            }\r\n            normal0 = Vector3.Cross(vt, point);\r\n        } else {\r\n            normal0 = Vector3.Cross(vt, va);\r\n            Vector3.CrossToRef(normal0, vt, normal0);\r\n        }\r\n        normal0.normalize();\r\n        return normal0;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at data for an interpolated point along this curve\r\n     * @param position the position of the point along this curve, from 0.0 to 1.0\r\n     * @param interpolateTNB\r\n     * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\r\n     * @returns the (updated) point at data\r\n     */\r\n    private _updatePointAtData(position: number, interpolateTNB: boolean = false) {\r\n        // set an id for caching the result\r\n        if (this._pointAtData.id === position) {\r\n            if (!this._pointAtData.interpolateReady) {\r\n                this._updateInterpolationMatrix();\r\n            }\r\n            return this._pointAtData;\r\n        } else {\r\n            this._pointAtData.id = position;\r\n        }\r\n        const curvePoints = this.getPoints();\r\n\r\n        // clamp position between 0.0 and 1.0\r\n        if (position <= 0.0) {\r\n            return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\r\n        } else if (position >= 1.0) {\r\n            return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\r\n        }\r\n\r\n        let previousPoint: Vector3 = curvePoints[0];\r\n        let currentPoint: Vector3;\r\n        let currentLength = 0.0;\r\n        const targetLength = position * this.length();\r\n\r\n        for (let i = 1; i < curvePoints.length; i++) {\r\n            currentPoint = curvePoints[i];\r\n            const distance = Vector3.Distance(previousPoint, currentPoint);\r\n            currentLength += distance;\r\n            if (currentLength === targetLength) {\r\n                return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\r\n            } else if (currentLength > targetLength) {\r\n                const toLength = currentLength - targetLength;\r\n                const diff = toLength / distance;\r\n                const dir = previousPoint.subtract(currentPoint);\r\n                const point = currentPoint.add(dir.scaleInPlace(diff));\r\n                return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\r\n            }\r\n            previousPoint = currentPoint;\r\n        }\r\n        return this._pointAtData;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at data from the specified parameters\r\n     * @param position where along the path the interpolated point is, from 0.0 to 1.0\r\n     * @param subPosition\r\n     * @param point the interpolated point\r\n     * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\r\n     * @param interpolateTNB whether to compute the interpolated tangent, normal and binormal\r\n     * @returns the (updated) point at data\r\n     */\r\n    private _setPointAtData(position: number, subPosition: number, point: Vector3, parentIndex: number, interpolateTNB: boolean) {\r\n        this._pointAtData.point = point;\r\n        this._pointAtData.position = position;\r\n        this._pointAtData.subPosition = subPosition;\r\n        this._pointAtData.previousPointArrayIndex = parentIndex;\r\n        this._pointAtData.interpolateReady = interpolateTNB;\r\n\r\n        if (interpolateTNB) {\r\n            this._updateInterpolationMatrix();\r\n        }\r\n        return this._pointAtData;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at interpolation matrix for the tangents, normals and binormals\r\n     */\r\n    private _updateInterpolationMatrix() {\r\n        this._pointAtData.interpolationMatrix = Matrix.Identity();\r\n        const parentIndex = this._pointAtData.previousPointArrayIndex;\r\n\r\n        if (parentIndex !== this._tangents.length - 1) {\r\n            const index = parentIndex + 1;\r\n\r\n            const tangentFrom = this._tangents[parentIndex].clone();\r\n            const normalFrom = this._normals[parentIndex].clone();\r\n            const binormalFrom = this._binormals[parentIndex].clone();\r\n\r\n            const tangentTo = this._tangents[index].clone();\r\n            const normalTo = this._normals[index].clone();\r\n            const binormalTo = this._binormals[index].clone();\r\n\r\n            const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\r\n            const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\r\n            const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\r\n\r\n            quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n * A Curve3 is designed from a series of successive Vector3.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves\r\n */\r\nexport class Curve3 {\r\n    private _points: Vector3[];\r\n    private _length: number = 0.0;\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#quadratic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Quadratic Bezier\r\n     * @param v1 (Vector3) the control point\r\n     * @param v2 (Vector3) the end point of the Quadratic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateQuadraticBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\r\n        const bez: Vector3[] = [];\r\n        const equation = (t: number, val0: number, val1: number, val2: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#cubic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Cubic Bezier\r\n     * @param v1 (Vector3) the first control point\r\n     * @param v2 (Vector3) the second control point\r\n     * @param v3 (Vector3) the end point of the Cubic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateCubicBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, v3: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\r\n        const bez: Vector3[] = [];\r\n        const equation = (t: number, val0: number, val1: number, val2: number, val3: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-spline\r\n     * @param p1 (Vector3) the origin point of the Hermite Spline\r\n     * @param t1 (Vector3) the tangent vector at the origin point\r\n     * @param p2 (Vector3) the end point of the Hermite Spline\r\n     * @param t2 (Vector3) the tangent vector at the end point\r\n     * @param nSeg (integer) the number of curve segments or nSeg + 1 points in the array\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateHermiteSpline(p1: DeepImmutable<Vector3>, t1: DeepImmutable<Vector3>, p2: DeepImmutable<Vector3>, t2: DeepImmutable<Vector3>, nSeg: number): Curve3 {\r\n        const hermite: Vector3[] = [];\r\n        const step = 1.0 / nSeg;\r\n        for (let i = 0; i <= nSeg; i++) {\r\n            hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\r\n        }\r\n        return new Curve3(hermite);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a CatmullRom Spline curve :\r\n     * @param points (array of Vector3) the points the spline must pass through. At least, four points required\r\n     * @param nbPoints (integer) the wanted number of points between each curve control points\r\n     * @param closed (boolean) optional with default false, when true forms a closed loop from the points\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateCatmullRomSpline(points: DeepImmutable<Vector3[]>, nbPoints: number, closed?: boolean): Curve3 {\r\n        const catmullRom: Vector3[] = [];\r\n        const step = 1.0 / nbPoints;\r\n        let amount = 0.0;\r\n        if (closed) {\r\n            const pointsCount = points.length;\r\n            for (let i = 0; i < pointsCount; i++) {\r\n                amount = 0;\r\n                for (let c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(\r\n                        Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount)\r\n                    );\r\n                    amount += step;\r\n                }\r\n            }\r\n            catmullRom.push(catmullRom[0]);\r\n        } else {\r\n            const totalPoints: Vector3[] = [];\r\n            totalPoints.push(points[0].clone());\r\n            Array.prototype.push.apply(totalPoints, points);\r\n            totalPoints.push(points[points.length - 1].clone());\r\n            let i = 0;\r\n            for (; i < totalPoints.length - 3; i++) {\r\n                amount = 0;\r\n                for (let c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n                    amount += step;\r\n                }\r\n            }\r\n            i--;\r\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n        }\r\n        return new Curve3(catmullRom);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along an arc through three vector3 points:\r\n     * The three points should not be colinear. When they are the Curve3 is empty.\r\n     * @param first (Vector3) the first point the arc must pass through.\r\n     * @param second (Vector3) the second point the arc must pass through.\r\n     * @param third (Vector3) the third point the arc must pass through.\r\n     * @param steps (number) the larger the number of steps the more detailed the arc.\r\n     * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\r\n     * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\r\n     * @returns the created Curve3\r\n     */\r\n    public static ArcThru3Points(first: Vector3, second: Vector3, third: Vector3, steps: number = 32, closed: boolean = false, fullCircle: boolean = false): Curve3 {\r\n        const arc: Vector3[] = [];\r\n        const vec1 = second.subtract(first);\r\n        const vec2 = third.subtract(second);\r\n        const vec3 = first.subtract(third);\r\n        const zAxis = Vector3.Cross(vec1, vec2);\r\n        const len4 = zAxis.length();\r\n        if (len4 < Math.pow(10, -8)) {\r\n            return new Curve3(arc); // colinear points arc is empty\r\n        }\r\n        const len1_sq = vec1.lengthSquared();\r\n        const len2_sq = vec2.lengthSquared();\r\n        const len3_sq = vec3.lengthSquared();\r\n        const len4_sq = zAxis.lengthSquared();\r\n        const len1 = vec1.length();\r\n        const len2 = vec2.length();\r\n        const len3 = vec3.length();\r\n        const radius = (0.5 * len1 * len2 * len3) / len4;\r\n        const dot1 = Vector3.Dot(vec1, vec3);\r\n        const dot2 = Vector3.Dot(vec1, vec2);\r\n        const dot3 = Vector3.Dot(vec2, vec3);\r\n        const a = (-0.5 * len2_sq * dot1) / len4_sq;\r\n        const b = (-0.5 * len3_sq * dot2) / len4_sq;\r\n        const c = (-0.5 * len1_sq * dot3) / len4_sq;\r\n        const center = first.scale(a).add(second.scale(b)).add(third.scale(c));\r\n        const radiusVec = first.subtract(center);\r\n        const xAxis = radiusVec.normalize();\r\n        const yAxis = Vector3.Cross(zAxis, xAxis).normalize();\r\n        if (fullCircle) {\r\n            const dStep = (2 * Math.PI) / steps;\r\n            for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {\r\n                arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\r\n            }\r\n            arc.push(first);\r\n        } else {\r\n            const dStep = 1 / steps;\r\n            let theta = 0;\r\n            let point = Vector3.Zero();\r\n            do {\r\n                point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\r\n                arc.push(point);\r\n                theta += dStep;\r\n            } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\r\n            arc.push(third);\r\n            if (closed) {\r\n                arc.push(first);\r\n            }\r\n        }\r\n        return new Curve3(arc);\r\n    }\r\n\r\n    /**\r\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n     * A Curve3 is designed from a series of successive Vector3.\r\n     * Tuto : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#curve3-object\r\n     * @param points points which make up the curve\r\n     */\r\n    constructor(points: Vector3[]) {\r\n        this._points = points;\r\n        this._length = this._computeLength(points);\r\n    }\r\n\r\n    /**\r\n     * @returns the Curve3 stored array of successive Vector3\r\n     */\r\n    public getPoints() {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * @returns the computed length (float) of the curve.\r\n     */\r\n    public length() {\r\n        return this._length;\r\n    }\r\n\r\n    /**\r\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\r\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\r\n     * curveA and curveB keep unchanged.\r\n     * @param curve the curve to continue from this curve\r\n     * @returns the newly constructed curve\r\n     */\r\n    public continue(curve: DeepImmutable<Curve3>): Curve3 {\r\n        const lastPoint = this._points[this._points.length - 1];\r\n        const continuedPoints = this._points.slice();\r\n        const curvePoints = curve.getPoints();\r\n        for (let i = 1; i < curvePoints.length; i++) {\r\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\r\n        }\r\n        const continuedCurve = new Curve3(continuedPoints);\r\n        return continuedCurve;\r\n    }\r\n\r\n    private _computeLength(path: DeepImmutable<Vector3[]>): number {\r\n        let l = 0;\r\n        for (let i = 1; i < path.length; i++) {\r\n            l += path[i].subtract(path[i - 1]).length();\r\n        }\r\n        return l;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["Orientation"]
}
