{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts", "../../../dev/core/src/Materials/Textures/Procedurals/proceduralTexture.ts"],
  "sourcesContent": ["import { Tools } from \"../../../Misc/tools\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { ISceneComponent } from \"../../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector4, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../../../Engines/abstractEngine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { RenderTargetTextureOptions } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\n\r\n/**\r\n * Options to create a procedural texture\r\n */\r\nexport interface IProceduralTextureCreationOptions extends RenderTargetTextureOptions {\r\n    /**\r\n     * Defines a fallback texture in case there were issues to create the custom texture\r\n     */\r\n    fallbackTexture?: Nullable<Texture>;\r\n    /**\r\n     * The shader language of the shader. (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n    /**\r\n     * Additional async code to run before preparing the effect\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Define the list of custom preprocessor defines used in the shader\r\n     */\r\n    public defines: string = \"\";\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: ThinTexture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    /** @internal */\r\n    private _shaderLanguage: ShaderLanguage;\r\n\r\n    /**\r\n     * Gets the shader language type used to generate vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _vectors4: { [key: string]: Vector4 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: AbstractEngine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n    private _options: IProceduralTextureCreationOptions;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\r\n     *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\r\n     *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> | IProceduralTextureCreationOptions = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {\r\n            this._options = fallbackTexture;\r\n            this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;\r\n        } else {\r\n            this._options = {};\r\n            this._fallbackTexture = fallbackTexture;\r\n        }\r\n\r\n        this._shaderLanguage = this._options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            if (this._rtWrapper.is3D) {\r\n                this.setFloat(\"layer\", 0);\r\n                this.setInt(\"layerNum\", 0);\r\n            }\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n        this._drawWrapper.effect = null;\r\n        this._cachedDefines = null;\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return this.defines;\r\n    }\r\n\r\n    /**\r\n     * Executes a function when the texture will be ready to be drawn.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenReady(func: (texture: ProceduralTexture) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        const effect = this.getEffect();\r\n        if (effect) {\r\n            effect.executeWhenCompiled(() => {\r\n                func(this);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public override isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        const shaders = {\r\n            vertex: \"procedural\",\r\n            fragmentElement: this._fragment.fragmentElement,\r\n            fragmentSource: this._fragment.fragmentSource,\r\n            fragment: typeof this._fragment === \"string\" ? this._fragment : undefined,\r\n        };\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(\r\n                shaders,\r\n                [VertexBuffer.PositionKind],\r\n                this._uniforms,\r\n                this._samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                () => {\r\n                    this._rtWrapper?.dispose();\r\n                    this._rtWrapper = this._texture = null;\r\n\r\n                    if (this._fallbackTexture) {\r\n                        this._texture = this._fallbackTexture._texture;\r\n\r\n                        if (this._texture) {\r\n                            this._texture.incrementReferences();\r\n                        }\r\n                    }\r\n\r\n                    this._fallbackTextureUsed = true;\r\n                },\r\n                undefined,\r\n                this._shaderLanguage,\r\n                async () => {\r\n                    if (this._options.extraInitializationsAsync) {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../../ShadersWGSL/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../../Shaders/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        }\r\n                    } else {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await import(\"../../../ShadersWGSL/procedural.vertex\");\r\n                        } else {\r\n                            await import(\"../../../Shaders/procedural.vertex\");\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: ThinTexture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (const name in this._vectors4) {\r\n                this._drawWrapper.effect!.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, true);\r\n            }\r\n        } else {\r\n            let numLayers = 1;\r\n            if (this._rtWrapper.is3D) {\r\n                numLayers = this._rtWrapper.depth;\r\n            } else if (this._rtWrapper.is2DArray) {\r\n                numLayers = this._rtWrapper.layers;\r\n            }\r\n            for (let layer = 0; layer < numLayers; layer++) {\r\n                engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true, 0, layer);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {\r\n                    this._drawWrapper.effect?.setFloat(\"layer\", numLayers !== 1 ? layer / (numLayers - 1) : 0);\r\n                    this._drawWrapper.effect?.setInt(\"layerNum\", layer);\r\n                    for (const name in this._textures) {\r\n                        this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n                    }\r\n                }\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);\r\n            }\r\n        }\r\n\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture, true);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n"],
  "mappings": "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",
  "names": []
}
