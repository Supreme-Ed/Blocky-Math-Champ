{
  "version": 3,
  "sources": ["../../../dev/core/src/Cameras/Inputs/BaseCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraPointersInput.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    /**\r\n     * Which pointer ID is currently down (only for mouse events, not used for touch events)\r\n     */\r\n    private _currentMousePointerIdDown: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (\r\n                p.type !== PointerEventTypes.POINTERDOWN &&\r\n                p.type !== PointerEventTypes.POINTERDOUBLETAP &&\r\n                isTouch &&\r\n                this._pointA?.pointerId !== evt.pointerId &&\r\n                this._pointB?.pointerId !== evt.pointerId\r\n            ) {\r\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentMousePointerIdDown === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else {\r\n                    return; // We are already tracking two pointers so ignore this one\r\n                }\r\n\r\n                if (this._currentMousePointerIdDown === -1 && !isTouch) {\r\n                    this._currentMousePointerIdDown = evt.pointerId;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentMousePointerIdDown === evt.pointerId || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentMousePointerIdDown = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = (evt: Event) => this.onContextMenu(evt as PointerEvent);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentMousePointerIdDown = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type type of event\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point The current position of the pointer\r\n     * @param offsetX The offsetX of the pointer when the event occurred\r\n     * @param offsetY The offsetY of the pointer when the event occurred\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA First point in the pair\r\n     * @param _pointB Second point in the pair\r\n     * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)\r\n     * @param pinchSquaredDistance Sqr Distance between the points this time\r\n     * @param previousMultiTouchPanPosition Previous center point between the points\r\n     * @param multiTouchPanPosition Current center point between the points\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the event to be handled\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonDown(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public override buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point current touch point\r\n     * @param offsetX offset on X\r\n     * @param offsetY offset on Y\r\n     */\r\n    public override onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public override onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA point A\r\n     * @param pointB point B\r\n     * @param previousPinchSquaredDistance distance between points in previous pinch\r\n     * @param pinchSquaredDistance distance between points in current pinch\r\n     * @param previousMultiTouchPanPosition multi-touch position in previous step\r\n     * @param multiTouchPanPosition multi-touch position in current step\r\n     */\r\n    public override onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt Defines the event to track\r\n     */\r\n    public override onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public override onButtonUp(_evt: IPointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public override onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;IAgBsB;;;;AAdtB;AAEA;AAIA;AAQM,IAAgB,0BAAhB,MAAuC;MAA7C,cAAA;AAuBY,aAAA,6BAAqC;AAOtC,aAAA,UAAU,CAAC,GAAG,GAAG,CAAC;MAoU7B;;;;;MA9TW,cAAc,kBAA0B;AAE3C,2BAAmB,MAAM,iCAAiC,SAAS;AACnE,cAAM,SAAS,KAAK,OAAO,UAAS;AACpC,cAAM,UAAU,OAAO,gBAAe;AACtC,YAAI,+BAA+B;AACnC,YAAI,gCAAwD;AAE5D,aAAK,UAAU;AACf,aAAK,UAAU;AAEf,aAAK,UAAU;AACf,aAAK,WAAW;AAChB,aAAK,WAAW;AAChB,aAAK,YAAY;AACjB,aAAK,kBAAkB;AAEvB,aAAK,gBAAgB,CAAC,MAAK;;AACvB,gBAAM,MAAqB,EAAE;AAC7B,gBAAM,UAAU,IAAI,gBAAgB;AAEpC,cAAI,EAAE,SAAS,kBAAkB,eAAe,KAAK,QAAQ,QAAQ,IAAI,MAAM,MAAM,IAAI;AACrF;UACJ;AAEA,gBAAM,aAA0B,IAAI;AAEpC,eAAK,UAAU,IAAI;AACnB,eAAK,WAAW,IAAI;AACpB,eAAK,WAAW,IAAI;AACpB,eAAK,YAAY,IAAI;AACrB,eAAK,kBAAkB,IAAI;AAE3B,cAAI,OAAO,eAAe;AACtB,kBAAM,UAAU,IAAI;AACpB,kBAAM,UAAU,IAAI;AAEpB,iBAAK,QAAQ,MAAM,SAAS,OAAO;AACnC,iBAAK,UAAU;AACf,iBAAK,UAAU;UACnB,WACI,EAAE,SAAS,kBAAkB,eAC7B,EAAE,SAAS,kBAAkB,oBAC7B,aACA,UAAK,YAAL,mBAAc,eAAc,IAAI,eAChC,UAAK,YAAL,mBAAc,eAAc,IAAI,WAClC;AACE;UACJ,WAAW,EAAE,SAAS,kBAAkB,gBAAgB,KAAK,+BAA+B,MAAM,UAAU;AACxG,gBAAI;AACA,uDAAY,kBAAkB,IAAI;YACtC,SAAS,GAAG;YAEZ;AAEA,gBAAI,KAAK,YAAY,MAAM;AACvB,mBAAK,UAAU;gBACX,GAAG,IAAI;gBACP,GAAG,IAAI;gBACP,WAAW,IAAI;gBACf,MAAM,IAAI;;YAElB,WAAW,KAAK,YAAY,MAAM;AAC9B,mBAAK,UAAU;gBACX,GAAG,IAAI;gBACP,GAAG,IAAI;gBACP,WAAW,IAAI;gBACf,MAAM,IAAI;;YAElB,OAAO;AACH;YACJ;AAEA,gBAAI,KAAK,+BAA+B,MAAM,CAAC,SAAS;AACpD,mBAAK,6BAA6B,IAAI;YAC1C;AACA,iBAAK,aAAa,GAAG;AAErB,gBAAI,CAAC,kBAAkB;AACnB,kBAAI,eAAc;AAClB,yBAAW,QAAQ,MAAK;YAC5B;UACJ,WAAW,EAAE,SAAS,kBAAkB,kBAAkB;AACtD,iBAAK,YAAY,IAAI,WAAW;UACpC,WAAW,EAAE,SAAS,kBAAkB,cAAc,KAAK,+BAA+B,IAAI,aAAa,UAAU;AACjH,gBAAI;AACA,uDAAY,sBAAsB,IAAI;YAC1C,SAAS,GAAG;YAEZ;AAEA,gBAAI,CAAC,SAAS;AACV,mBAAK,UAAU;YACnB;AAOA,gBAAI,OAAO,QAAQ;AACf,mBAAK,UAAU,KAAK,UAAU;YAClC,OAAO;AAGH,kBAAI,KAAK,WAAW,KAAK,WAAW,KAAK,QAAQ,aAAa,IAAI,WAAW;AACzE,qBAAK,UAAU,KAAK;AACpB,qBAAK,UAAU;cACnB,WAAW,KAAK,WAAW,KAAK,WAAW,KAAK,QAAQ,aAAa,IAAI,WAAW;AAChF,qBAAK,UAAU;cACnB,OAAO;AACH,qBAAK,UAAU,KAAK,UAAU;cAClC;YACJ;AAEA,gBAAI,iCAAiC,KAAK,+BAA+B;AAGrE,mBAAK;gBACD,KAAK;gBACL,KAAK;gBACL;gBACA;;gBACA;gBACA;;;AAEJ,6CAA+B;AAC/B,8CAAgC;YACpC;AAEA,iBAAK,6BAA6B;AAClC,iBAAK,WAAW,GAAG;AAEnB,gBAAI,CAAC,kBAAkB;AACnB,kBAAI,eAAc;YACtB;UACJ,WAAW,EAAE,SAAS,kBAAkB,aAAa;AACjD,gBAAI,CAAC,kBAAkB;AACnB,kBAAI,eAAc;YACtB;AAGA,gBAAI,KAAK,WAAW,KAAK,YAAY,MAAM;AACvC,oBAAM,UAAU,IAAI,UAAU,KAAK,QAAQ;AAC3C,oBAAM,UAAU,IAAI,UAAU,KAAK,QAAQ;AAC3C,mBAAK,QAAQ,IAAI,IAAI;AACrB,mBAAK,QAAQ,IAAI,IAAI;AACrB,mBAAK,QAAQ,KAAK,SAAS,SAAS,OAAO;YAC/C,WAES,KAAK,WAAW,KAAK,SAAS;AACnC,oBAAM,KAAK,KAAK,QAAQ,cAAc,IAAI,YAAY,KAAK,UAAU,KAAK;AAC1E,iBAAG,IAAI,IAAI;AACX,iBAAG,IAAI,IAAI;AACX,oBAAM,QAAQ,KAAK,QAAQ,IAAI,KAAK,QAAQ;AAC5C,oBAAM,QAAQ,KAAK,QAAQ,IAAI,KAAK,QAAQ;AAC5C,oBAAM,uBAAuB,QAAQ,QAAQ,QAAQ;AACrD,oBAAM,wBAAwB;gBAC1B,IAAI,KAAK,QAAQ,IAAI,KAAK,QAAQ,KAAK;gBACvC,IAAI,KAAK,QAAQ,IAAI,KAAK,QAAQ,KAAK;gBACvC,WAAW,IAAI;gBACf,MAAM,EAAE;;AAGZ,mBAAK,aAAa,KAAK,SAAS,KAAK,SAAS,8BAA8B,sBAAsB,+BAA+B,qBAAqB;AAEtJ,8CAAgC;AAChC,6CAA+B;YACnC;UACJ;QACJ;AAEA,aAAK,YAAY,KAAK,OACjB,SAAQ,EACR,cAAc,0BACX,KAAK,eACL,kBAAkB,cAAc,kBAAkB,YAAY,kBAAkB,cAAc,kBAAkB,gBAAgB;AAGxI,aAAK,eAAe,MAAK;AACrB,eAAK,UAAU,KAAK,UAAU;AAC9B,yCAA+B;AAC/B,0CAAgC;AAChC,eAAK,YAAW;QACpB;AAEA,aAAK,mBAAmB,CAAC,QAAe,KAAK,cAAc,GAAmB;AAE9E,mBAAW,QAAQ,iBAAiB,eAAe,KAAK,kBAAkB,KAAK;AAE/E,cAAM,aAAa,KAAK,OAAO,SAAQ,EAAG,UAAS,EAAG,cAAa;AAEnE,YAAI,YAAY;AACZ,gBAAM,sBAAsB,YAAY,CAAC,EAAE,MAAM,QAAQ,SAAS,KAAK,aAAY,CAAE,CAAC;QAC1F;MACJ;;;;MAKO,gBAAa;AAChB,YAAI,KAAK,cAAc;AACnB,gBAAM,aAAa,KAAK,OAAO,SAAQ,EAAG,UAAS,EAAG,cAAa;AACnE,cAAI,YAAY;AACZ,kBAAM,wBAAwB,YAAY,CAAC,EAAE,MAAM,QAAQ,SAAS,KAAK,aAAY,CAAE,CAAC;UAC5F;QACJ;AAEA,YAAI,KAAK,WAAW;AAChB,eAAK,OAAO,SAAQ,EAAG,cAAc,6BAA6B,KAAK,SAAS;AAChF,eAAK,YAAY;AAEjB,cAAI,KAAK,kBAAkB;AACvB,kBAAM,eAAe,KAAK,OAAO,SAAQ,EAAG,UAAS,EAAG,gBAAe;AACvE,4BAAgB,aAAa,oBAAoB,eAAe,KAAK,gBAAgB;UACzF;AAEA,eAAK,eAAe;QACxB;AAEA,aAAK,UAAU;AACf,aAAK,WAAW;AAChB,aAAK,WAAW;AAChB,aAAK,YAAY;AACjB,aAAK,kBAAkB;AACvB,aAAK,6BAA6B;MACtC;;;;;MAMO,eAAY;AACf,eAAO;MACX;;;;;MAMO,gBAAa;AAChB,eAAO;MACX;;;;;;;MAQO,YAAY,MAAY;MAAG;;;;;;;;;MAU3B,QAAQ,OAA+B,SAAiB,SAAe;MAAS;;;;;;;;;;;;MAahF,aACH,SACA,SACA,8BACA,sBACA,+BACA,uBAA6C;MACxC;;;;;;MAOF,cAAc,KAAiB;AAClC,YAAI,eAAc;MACtB;;;;;;;MAQO,aAAa,MAAmB;MAAS;;;;;;;MAQzC,WAAW,MAAmB;MAAS;;;;;MAMvC,cAAW;MAAU;;AA7TrB,eAAA;MADN,UAAS;;;;;;ICjCD;;;;AAXb;AAEA;AACA;AAQM,IAAO,+BAAP,MAAO,sCAAqC,wBAAuB;MAAzE,cAAA;;AAuBoB,aAAA,UAAU,CAAC,GAAG,GAAG,CAAC;AAO3B,aAAA,sBAAsB;AAOtB,aAAA,sBAAsB;AAMtB,aAAA,iBAAiB;AASjB,aAAA,uBAAuB;AASvB,aAAA,sBAA+B;AAM/B,aAAA,YAAqB;AAMrB,aAAA,qBAA6B;AAM7B,aAAA,oBAA6B;AAO7B,aAAA,uBAAgC;AAKhC,aAAA,eAAe;AAEd,aAAA,cAAuB;AACvB,aAAA,0BAAkC;AAClC,aAAA,cAAuB;MAmJnC;;;;;MAnOoB,eAAY;AACxB,eAAO;MACX;;;;;;MAqFQ,0BAA0B,+BAAuD,uBAA6C;AAClI,YAAI,KAAK,uBAAuB,KAAK,iCAAiC,uBAAuB;AACzF,gBAAM,aAAa,sBAAsB,IAAI,8BAA8B;AAC3E,gBAAM,aAAa,sBAAsB,IAAI,8BAA8B;AAC3E,eAAK,OAAO,oBAAoB,CAAC,aAAa,KAAK;AACnD,eAAK,OAAO,oBAAoB,aAAa,KAAK;QACtD;MACJ;;;;;;MAOQ,kBAAkB,8BAAsC,sBAA4B;AACxF,cAAM,SAAS,KAAK,OAAO,UAAU,8BAA6B;AAClE,YAAI,KAAK,qBAAqB;AAC1B,eAAK,OAAO,SAAU,SAAS,KAAK,KAAK,4BAA4B,IAAK,KAAK,KAAK,oBAAoB;QAC5G,WAAW,KAAK,sBAAsB;AAClC,eAAK,OAAO,yBAAyB,uBAAuB,gCAAgC,OAAQ,SAAS,KAAK;QACtH,OAAO;AACH,eAAK,OAAO,yBACP,uBAAuB,iCACtB,KAAK,kBAAkB,KAAK,eAAe,IAAI,OAAO,KAAK,sBAAsB,KAAK,uBAAwB;QACxH;MACJ;;;;;;;MAQgB,QAAQ,OAA+B,SAAiB,SAAe;AACnF,YAAI,KAAK,uBAAuB,MAAO,KAAK,YAAY,KAAK,OAAO,sBAAuB,KAAK,cAAc;AAC1G,eAAK,OAAO,oBAAoB,CAAC,UAAU,KAAK;AAChD,eAAK,OAAO,oBAAoB,UAAU,KAAK;QACnD,OAAO;AACH,eAAK,OAAO,uBAAuB,UAAU,KAAK;AAClD,eAAK,OAAO,sBAAsB,UAAU,KAAK;QACrD;MACJ;;;;MAKgB,cAAW;AACvB,YAAI,KAAK,OAAO,wBAAwB;AACpC,eAAK,OAAO,aAAY;QAC5B;MACJ;;;;;;;;;;MAWgB,aACZ,QACA,QACA,8BACA,sBACA,+BACA,uBAA6C;AAE7C,YAAI,iCAAiC,KAAK,kCAAkC,MAAM;AAI9E;QACJ;AACA,YAAI,yBAAyB,KAAK,0BAA0B,MAAM;AAE9D;QACJ;AAGA,YAAI,KAAK,sBAAsB;AAC3B,eAAK,kBAAkB,8BAA8B,oBAAoB;AACzE,eAAK,0BAA0B,+BAA+B,qBAAqB;QAGvF,WAAW,KAAK,qBAAqB,KAAK,WAAW;AACjD,eAAK;AAEL,cACI,KAAK,eACJ,KAAK,0BAA0B,MAAM,KAAK,IAAI,KAAK,KAAK,oBAAoB,IAAI,KAAK,KAAK,4BAA4B,CAAC,IAAI,KAAK,OAAO,uBAC1I;AAEE,iBAAK,kBAAkB,8BAA8B,oBAAoB;AAGzE,iBAAK,cAAc;UACvB,OAAO;AAEH,iBAAK,0BAA0B,+BAA+B,qBAAqB;UACvF;QAGJ,WAAW,KAAK,mBAAmB;AAC/B,eAAK,0BAA0B,+BAA+B,qBAAqB;QAGvF,WAAW,KAAK,WAAW;AACvB,eAAK,kBAAkB,8BAA8B,oBAAoB;QAC7E;MACJ;;;;;;MAOgB,aAAa,KAAkB;AAC3C,aAAK,cAAc,IAAI,WAAW,KAAK,OAAO;MAClD;;;;;;MAOgB,WAAW,MAAmB;AAC1C,aAAK,0BAA0B;AAC/B,aAAK,cAAc;MACvB;;;;MAKgB,cAAW;AACvB,aAAK,cAAc;AACnB,aAAK,0BAA0B;AAC/B,aAAK,cAAc;MACvB;;AAxOc,iCAAA,wBAAgC;AAc9B,eAAA;MADf,UAAS;;AAQH,eAAA;MADN,UAAS;;AAQH,eAAA;MADN,UAAS;;AAOH,eAAA;MADN,UAAS;;AAUH,eAAA;MADN,UAAS;;AAUH,eAAA;MADN,UAAS;;AAOH,eAAA;MADN,UAAS;;AAOH,eAAA;MADN,UAAS;;AAOH,eAAA;MADN,UAAS;;AAQH,eAAA;MADN,UAAS;;AA8JR,qBAAkB,8BAA8B,IAAI;;;",
  "names": []
}
