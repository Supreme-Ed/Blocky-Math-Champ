{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/flowGraphSetVariableBlock.ts"],
  "sourcesContent": ["import { RegisterClass } from \"core/Misc/typeStore\";\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\nimport { FlowGraphExecutionBlockWithOutSignal } from \"../../flowGraphExecutionBlockWithOutSignal\";\nimport type { FlowGraphSignalConnection } from \"../../flowGraphSignalConnection\";\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\n\n/**\n * The configuration of the FlowGraphGetVariableBlock.\n */\nexport interface IFlowGraphSetVariableBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The name of the variable to set.\n     */\n    variable?: string;\n\n    /**\n     * The name of the variables to set.\n     */\n    variables?: string[];\n}\n\n/**\n * This block will set a variable on the context.\n */\nexport class FlowGraphSetVariableBlock<T> extends FlowGraphExecutionBlockWithOutSignal {\n    constructor(config: IFlowGraphSetVariableBlockConfiguration) {\n        super(config);\n        // check if the variable is defined\n        if (!config.variable && !config.variables) {\n            throw new Error(\"FlowGraphSetVariableBlock: variable/variables is not defined\");\n        }\n        // check if the variable is an array\n        if (config.variables && config.variable) {\n            throw new Error(\"FlowGraphSetVariableBlock: variable and variables are both defined\");\n        }\n        // check if we have either a variable or variables. If we have variables, set the inputs correctly\n        if (config.variables) {\n            for (const variable of config.variables) {\n                this.registerDataInput(variable, RichTypeAny);\n            }\n        } else {\n            this.registerDataInput(\"value\", RichTypeAny);\n        }\n    }\n\n    public override _execute(context: FlowGraphContext, _callingSignal: FlowGraphSignalConnection): void {\n        if (this.config?.variables) {\n            for (const variable of this.config.variables) {\n                this._saveVariable(context, variable);\n            }\n        } else {\n            this._saveVariable(context, this.config?.variable!, \"value\");\n        }\n        this.out._activateSignal(context);\n    }\n\n    private _saveVariable(context: FlowGraphContext, variableName: string, inputName?: string): void {\n        // check if there is an animation(group) running on this variable. If there is, stop the animation - a value was force-set.\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\n        for (const animationUniqueId of currentlyRunningAnimationGroups) {\n            const animation = context.assetsContext.animationGroups[animationUniqueId];\n            // check if there is a target animation that has the target set to be the context\n            for (const targetAnimation of animation.targetedAnimations) {\n                if (targetAnimation.target === context) {\n                    // check if the target property is the variable we are setting\n                    if (targetAnimation.target === context) {\n                        // check the variable name\n                        if (targetAnimation.animation.targetProperty === variableName) {\n                            // stop the animation\n                            animation.stop();\n                            // remove the animation from the currently running animations\n                            const index = currentlyRunningAnimationGroups.indexOf(animationUniqueId);\n                            if (index > -1) {\n                                currentlyRunningAnimationGroups.splice(index, 1);\n                            }\n                            context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        const value = this.getDataInput(inputName || variableName)?.getValue(context);\n        context.setVariable(variableName, value);\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.SetVariable;\n    }\n\n    public override serialize(serializationObject?: any): void {\n        super.serialize(serializationObject);\n        serializationObject.config.variable = this.config?.variable;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.SetVariable, FlowGraphSetVariableBlock);\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA,IA0Ba;AA1Bb;;;AAGA;AAGA;AAoBM,IAAO,4BAAP,cAA4C,qCAAoC;MAClF,YAAY,QAA+C;AACvD,cAAM,MAAM;AAEZ,YAAI,CAAC,OAAO,YAAY,CAAC,OAAO,WAAW;AACvC,gBAAM,IAAI,MAAM,8DAA8D;QAClF;AAEA,YAAI,OAAO,aAAa,OAAO,UAAU;AACrC,gBAAM,IAAI,MAAM,oEAAoE;QACxF;AAEA,YAAI,OAAO,WAAW;AAClB,qBAAW,YAAY,OAAO,WAAW;AACrC,iBAAK,kBAAkB,UAAU,WAAW;UAChD;QACJ,OAAO;AACH,eAAK,kBAAkB,SAAS,WAAW;QAC/C;MACJ;MAEgB,SAAS,SAA2B,gBAAyC;AA/CjG;AAgDQ,aAAI,UAAK,WAAL,mBAAa,WAAW;AACxB,qBAAW,YAAY,KAAK,OAAO,WAAW;AAC1C,iBAAK,cAAc,SAAS,QAAQ;UACxC;QACJ,OAAO;AACH,eAAK,cAAc,UAAS,UAAK,WAAL,mBAAa,UAAW,OAAO;QAC/D;AACA,aAAK,IAAI,gBAAgB,OAAO;MACpC;MAEQ,cAAc,SAA2B,cAAsB,WAAkB;AA1D7F;AA4DQ,cAAM,kCAAkC,QAAQ,0BAA0B,mCAAmC,CAAA,CAAE;AAC/G,mBAAW,qBAAqB,iCAAiC;AAC7D,gBAAM,YAAY,QAAQ,cAAc,gBAAgB,iBAAiB;AAEzE,qBAAW,mBAAmB,UAAU,oBAAoB;AACxD,gBAAI,gBAAgB,WAAW,SAAS;AAEpC,kBAAI,gBAAgB,WAAW,SAAS;AAEpC,oBAAI,gBAAgB,UAAU,mBAAmB,cAAc;AAE3D,4BAAU,KAAI;AAEd,wBAAM,QAAQ,gCAAgC,QAAQ,iBAAiB;AACvE,sBAAI,QAAQ,IAAI;AACZ,oDAAgC,OAAO,OAAO,CAAC;kBACnD;AACA,0BAAQ,0BAA0B,mCAAmC,+BAA+B;AACpG;gBACJ;cACJ;YACJ;UACJ;QACJ;AACA,cAAM,SAAQ,UAAK,aAAa,aAAa,YAAY,MAA3C,mBAA8C,SAAS;AACrE,gBAAQ,YAAY,cAAc,KAAK;MAC3C;MAEgB,eAAY;AACxB,eAAA;MACJ;MAEgB,UAAU,qBAAyB;AA5FvD;AA6FQ,cAAM,UAAU,mBAAmB;AACnC,4BAAoB,OAAO,YAAW,UAAK,WAAL,mBAAa;MACvD;;AAGJ,kBAAa,6BAAkC,yBAAyB;;;",
  "names": []
}
