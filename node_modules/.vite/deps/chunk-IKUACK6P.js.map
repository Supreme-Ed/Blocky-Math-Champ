{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/staticSound.ts", "../../../dev/core/src/AudioV2/abstractAudio/staticSoundBuffer.ts", "../../../dev/core/src/AudioV2/abstractAudio/staticSoundInstance.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioStaticSound.ts"],
  "sourcesContent": ["import { SoundState } from \"../soundState\";\nimport type { IAbstractSoundOptions, IAbstractSoundPlayOptions, IAbstractSoundStoredOptions } from \"./abstractSound\";\nimport { AbstractSound } from \"./abstractSound\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { IStaticSoundBufferOptions, StaticSoundBuffer } from \"./staticSoundBuffer\";\nimport type { _StaticSoundInstance } from \"./staticSoundInstance\";\n\n/** @internal */\nexport interface IStaticSoundOptionsBase {\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    duration: number;\n    /**\n     * The end of the loop range in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     * - Has no effect if {@link loop} is `false`.\n     */\n    loopEnd: number;\n    /**\n     * The start of the loop range in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     * - Has no effect if {@link loop} is `false`.\n     *\n     */\n    loopStart: number;\n}\n\n/**\n * Options stored in a static sound.\n * @internal\n */\nexport interface IStaticSoundStoredOptions extends IAbstractSoundStoredOptions, IStaticSoundOptionsBase {\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Can be combined with {@link playbackRate}.\n     */\n    pitch: number;\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Can be combined with {@link pitch}.\n     */\n    playbackRate: number;\n}\n\n/**\n * Options for creating a static sound.\n */\nexport interface IStaticSoundOptions extends IAbstractSoundOptions, IStaticSoundBufferOptions, IStaticSoundStoredOptions {}\n\n/**\n * Options for playing a static sound.\n */\nexport interface IStaticSoundPlayOptions extends IAbstractSoundPlayOptions, IStaticSoundOptionsBase {\n    /**\n     * The time to wait before playing the sound, in seconds. Defaults to `0`.\n     */\n    waitTime: number;\n}\n\n/**\n * Options for stopping a static sound.\n */\nexport interface IStaticSoundStopOptions {\n    /**\n     * The time to wait before stopping the sound, in seconds. Defaults to `0`.\n     */\n    waitTime: number;\n}\n\n/**\n * Abstract class representing a static sound.\n *\n * A static sound has a sound buffer that is loaded into memory all at once. This allows it to have more capabilities\n * than a streaming sound, such as loop points and playback rate changes, but it also means that the sound must be\n * fully downloaded and decoded before it can be played, which may take a long time for sounds with long durations.\n *\n * To prevent downloading and decoding a sound multiple times, a sound's buffer can be shared with other sounds.\n * See {@link CreateSoundBufferAsync}, {@link StaticSoundBuffer} and {@link StaticSound.buffer} for more information.\n *\n * Static sounds are created by the {@link CreateSoundAsync} function.\n */\nexport abstract class StaticSound extends AbstractSound {\n    protected override _instances: Set<_StaticSoundInstance>;\n    protected abstract override readonly _options: IStaticSoundStoredOptions;\n\n    /**\n     * The sound buffer that the sound uses.\n     *\n     * This buffer can be shared with other static sounds.\n     */\n    public abstract readonly buffer: StaticSoundBuffer;\n\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine);\n    }\n\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    public get duration(): number {\n        return this._options.duration;\n    }\n\n    public set duration(value: number) {\n        this._options.duration = value;\n    }\n\n    /**\n     * The start of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     */\n    public get loopStart(): number {\n        return this._options.loopStart;\n    }\n\n    public set loopStart(value: number) {\n        this._options.loopStart = value;\n    }\n\n    /**\n     * The end of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     */\n    public get loopEnd(): number {\n        return this._options.loopEnd;\n    }\n\n    public set loopEnd(value: number) {\n        this._options.loopEnd = value;\n    }\n\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Gets combined with {@link playbackRate} to determine the final pitch.\n     */\n    public get pitch(): number {\n        return this._options.pitch;\n    }\n\n    public set pitch(value: number) {\n        this._options.pitch = value;\n\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.pitch = value;\n        }\n    }\n\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Gets combined with {@link pitch} to determine the final playback rate.\n     */\n    public get playbackRate(): number {\n        return this._options.playbackRate;\n    }\n\n    public set playbackRate(value: number) {\n        this._options.playbackRate = value;\n\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.playbackRate = value;\n        }\n    }\n\n    protected abstract override _createInstance(): _StaticSoundInstance;\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public play(options: Partial<IStaticSoundPlayOptions> = {}): void {\n        if (this.state === SoundState.Paused) {\n            this.resume();\n            return;\n        }\n\n        options.duration ??= this.duration;\n        options.loop ??= this.loop;\n        options.loopStart ??= this.loopStart;\n        options.loopEnd ??= this.loopEnd;\n        options.startOffset ??= this.startOffset;\n        options.volume ??= 1;\n        options.waitTime ??= 0;\n\n        const instance = this._createInstance();\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n\n        this._stopExcessInstances();\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     * @param options - The options to use when stopping the sound.\n     */\n    public stop(options: Partial<IStaticSoundStopOptions> = {}): void {\n        if (options.waitTime && 0 < options.waitTime) {\n            this._setState(SoundState.Stopping);\n        } else {\n            this._setState(SoundState.Stopped);\n        }\n\n        if (!this._instances) {\n            return;\n        }\n\n        for (const instance of Array.from(this._instances)) {\n            instance.stop(options);\n        }\n    }\n}\n", "import type { AudioEngineV2 } from \"./audioEngineV2\";\n\n/**\n * Options for creating a static sound buffer.\n */\nexport interface IStaticSoundBufferOptions {\n    /**\n     * Whether to skip codec checking before attempting to load each source URL when `source` is a string array. Defaults to `false`.\n     * - Has no effect if the sound's source is not a string array.\n     * @see {@link CreateSoundAsync} `source` parameter.\n     */\n    skipCodecCheck: boolean;\n}\n\n/**\n * Abstract class representing a static sound buffer.\n *\n * A static sound buffer is a fully downloaded and decoded array of audio data that is ready to be played.\n *\n * Static sound buffers can be reused multiple times by different {@link StaticSound} instances.\n *\n * Static sound buffers are created by the {@link CreateSoundBufferAsync} function.\n *\n * @see {@link StaticSound.buffer}\n */\nexport abstract class StaticSoundBuffer {\n    /**\n     * The engine that the sound buffer belongs to.\n     */\n    public readonly engine: AudioEngineV2;\n\n    protected constructor(engine: AudioEngineV2) {\n        this.engine = engine;\n    }\n\n    /**\n     * The sample rate of the sound buffer.\n     */\n    public abstract readonly sampleRate: number;\n\n    /**\n     * The length of the sound buffer, in sample frames.\n     */\n    public abstract readonly length: number;\n\n    /**\n     * The duration of the sound buffer, in seconds.\n     */\n    public abstract readonly duration: number;\n\n    /**\n     * The number of channels in the sound buffer.\n     */\n    public abstract readonly channelCount: number;\n}\n", "import type { IAbstractSoundInstanceOptions } from \"./abstractSoundInstance\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { IStaticSoundOptionsBase, IStaticSoundPlayOptions, IStaticSoundStopOptions } from \"./staticSound\";\n\n/**\n * Options for creating a static sound instance.\n * @internal\n */\nexport interface IStaticSoundInstanceOptions extends IAbstractSoundInstanceOptions, IStaticSoundOptionsBase {}\n\n/** @internal */\nexport abstract class _StaticSoundInstance extends _AbstractSoundInstance {\n    protected abstract override readonly _options: IStaticSoundInstanceOptions;\n\n    public abstract pitch: number;\n    public abstract playbackRate: number;\n\n    public abstract override play(options: Partial<IStaticSoundPlayOptions>): void;\n    public abstract override stop(options?: Partial<IStaticSoundStopOptions>): void;\n}\n", "import type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type { IStaticSoundOptions, IStaticSoundPlayOptions, IStaticSoundStopOptions, IStaticSoundStoredOptions } from \"../abstractAudio/staticSound\";\nimport { StaticSound } from \"../abstractAudio/staticSound\";\nimport type { IStaticSoundBufferOptions } from \"../abstractAudio/staticSoundBuffer\";\nimport { StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer\";\nimport type { IStaticSoundInstanceOptions } from \"../abstractAudio/staticSoundInstance\";\nimport { _StaticSoundInstance } from \"../abstractAudio/staticSoundInstance\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport type { _SpatialAudio } from \"../abstractAudio/subProperties/spatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl, _FileExtensionRegex } from \"../audioUtils\";\nimport { SoundState } from \"../soundState\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioOutNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\ntype StaticSoundSourceType = ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[];\n\n/** @internal */\nexport class _WebAudioStaticSound extends StaticSound implements IWebAudioSuperNode {\n    private _buffer: _WebAudioStaticSoundBuffer;\n    private _spatial: Nullable<_SpatialWebAudio> = null;\n    private readonly _spatialAutoUpdate: boolean = true;\n    private readonly _spatialMinUpdateTime: number = 0;\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected override readonly _options: IStaticSoundStoredOptions;\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n\n    /** @internal */\n    public _audioContext: AudioContext | OfflineAudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine, options: Partial<IStaticSoundOptions>) {\n        super(name, engine);\n\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            duration: options.duration ?? 0,\n            loop: options.loop ?? false,\n            loopEnd: options.loopEnd ?? 0,\n            loopStart: options.loopStart ?? 0,\n            maxInstances: options.maxInstances ?? Infinity,\n            pitch: options.pitch ?? 0,\n            playbackRate: options.playbackRate ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n\n        this._subGraph = new _WebAudioStaticSound._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _init(source: StaticSoundSourceType, options: Partial<IStaticSoundOptions>): Promise<void> {\n        this._audioContext = this.engine._audioContext;\n\n        if (source instanceof _WebAudioStaticSoundBuffer) {\n            this._buffer = source as _WebAudioStaticSoundBuffer;\n        } else if (typeof source === \"string\" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {\n            this._buffer = (await this.engine.createSoundBufferAsync(source, options)) as _WebAudioStaticSoundBuffer;\n        }\n\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.init(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        if (options.autoplay) {\n            this.play();\n        }\n\n        this.engine._addNode(this);\n    }\n\n    /** @internal */\n    public get buffer(): _WebAudioStaticSoundBuffer {\n        return this._buffer;\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get spatial(): _SpatialAudio {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._spatial?.dispose();\n        this._spatial = null;\n\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeNode(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStaticSound\";\n    }\n\n    protected _createInstance(): _WebAudioStaticSoundInstance {\n        return new _WebAudioStaticSoundInstance(this, this._options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    private _initSpatialProperty(): _SpatialAudio {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n\n        return this._spatial;\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioStaticSound;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n    };\n}\n\n/** @internal */\nexport class _WebAudioStaticSoundBuffer extends StaticSoundBuffer {\n    /** @internal */\n    public _audioBuffer: AudioBuffer;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n    }\n\n    public async _init(source: StaticSoundSourceType, options: Partial<IStaticSoundBufferOptions>): Promise<void> {\n        if (source instanceof AudioBuffer) {\n            this._audioBuffer = source;\n        } else if (typeof source === \"string\") {\n            await this._initFromUrl(source);\n        } else if (Array.isArray(source)) {\n            await this._initFromUrls(source, options.skipCodecCheck ?? false);\n        } else if (source instanceof ArrayBuffer) {\n            await this._initFromArrayBuffer(source);\n        }\n    }\n\n    /** @internal */\n    public get channelCount(): number {\n        return this._audioBuffer.numberOfChannels;\n    }\n\n    /** @internal */\n    public get duration(): number {\n        return this._audioBuffer.duration;\n    }\n\n    /** @internal */\n    public get length(): number {\n        return this._audioBuffer.length;\n    }\n\n    /** @internal */\n    public get sampleRate(): number {\n        return this._audioBuffer.sampleRate;\n    }\n\n    private async _initFromArrayBuffer(arrayBuffer: ArrayBuffer): Promise<void> {\n        this._audioBuffer = await this.engine._audioContext.decodeAudioData(arrayBuffer);\n    }\n\n    private async _initFromUrl(url: string): Promise<void> {\n        url = _CleanUrl(url);\n        await this._initFromArrayBuffer(await (await fetch(url)).arrayBuffer());\n    }\n\n    private async _initFromUrls(urls: string[], skipCodecCheck: boolean): Promise<void> {\n        for (const url of urls) {\n            if (skipCodecCheck) {\n                await this._initFromUrl(url);\n            } else {\n                const matches = url.match(_FileExtensionRegex);\n                const format = matches?.at(1);\n                if (format && this.engine.isFormatValid(format)) {\n                    try {\n                        await this._initFromUrl(url);\n                    } catch (e) {\n                        if (format && 0 < format.length) {\n                            this.engine.flagInvalidFormat(format);\n                        }\n                    }\n                }\n            }\n\n            if (this._audioBuffer) {\n                break;\n            }\n        }\n    }\n}\n\n/** @internal */\nclass _WebAudioStaticSoundInstance extends _StaticSoundInstance implements IWebAudioOutNode {\n    private _enginePlayTime: number = 0;\n    private _enginePauseTime: number = 0;\n    private _sourceNode: Nullable<AudioBufferSourceNode> = null;\n    private _volumeNode: GainNode;\n\n    protected override readonly _options: IStaticSoundInstanceOptions;\n    protected override _sound: _WebAudioStaticSound;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    public constructor(sound: _WebAudioStaticSound, options: IStaticSoundInstanceOptions) {\n        super(sound);\n\n        this._options = options;\n\n        this._volumeNode = new GainNode(sound._audioContext);\n        this._initSourceNode();\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        const timeSinceLastStart = this._state === SoundState.Paused ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n\n    public set currentTime(value: number) {\n        const restart = this._state === SoundState.Starting || this._state === SoundState.Started;\n\n        if (restart) {\n            this.stop();\n            this._deinitSourceNode();\n        }\n\n        this._options.startOffset = value;\n\n        if (restart) {\n            this.play();\n        }\n    }\n\n    public get _outNode(): Nullable<AudioNode> {\n        return this._volumeNode;\n    }\n\n    /** @internal */\n    public set pitch(value: number) {\n        if (this._sourceNode) {\n            this.engine._setAudioParam(this._sourceNode.detune, value);\n        }\n    }\n\n    /** @internal */\n    public set playbackRate(value: number) {\n        if (this._sourceNode) {\n            this.engine._setAudioParam(this._sourceNode.playbackRate, value);\n        }\n    }\n\n    /** @internal */\n    public get startTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        return this._enginePlayTime;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._sourceNode = null;\n\n        this.stop();\n\n        this._deinitSourceNode();\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStaticSoundInstance\";\n    }\n\n    /** @internal */\n    public play(options: Partial<IStaticSoundPlayOptions> = {}): void {\n        if (this._state === SoundState.Started) {\n            return;\n        }\n\n        if (options.duration !== undefined) {\n            this._options.duration = options.duration;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        if (options.loopStart !== undefined) {\n            this._options.loopStart = options.loopStart;\n        }\n        if (options.loopEnd !== undefined) {\n            this._options.loopEnd = options.loopEnd;\n        }\n        if (options.startOffset !== undefined) {\n            this._options.startOffset = options.startOffset;\n        }\n\n        let startOffset = this._options.startOffset;\n\n        if (this._state === SoundState.Paused) {\n            startOffset += this.currentTime;\n            startOffset %= this._sound.buffer.duration;\n        }\n\n        this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);\n\n        this._volumeNode.gain.value = options.volume ?? 1;\n\n        this._initSourceNode();\n\n        if (this.engine.state === \"running\") {\n            this._setState(SoundState.Started);\n            this._sourceNode?.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : undefined);\n        } else if (this._options.loop) {\n            this._setState(SoundState.Starting);\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n    }\n\n    /** @internal */\n    public pause(): void {\n        if (this._state === SoundState.Paused) {\n            return;\n        }\n\n        this._setState(SoundState.Paused);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n\n        this._sourceNode?.stop();\n        this._deinitSourceNode();\n    }\n\n    /** @internal */\n    public resume(): void {\n        if (this._state === SoundState.Paused) {\n            this.play();\n        }\n    }\n\n    /** @internal */\n    public stop(options: Partial<IStaticSoundStopOptions> = {}): void {\n        if (this._state === SoundState.Stopped) {\n            return;\n        }\n\n        this._setState(SoundState.Stopped);\n\n        const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._sourceNode?.stop(engineStopTime);\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n\n    protected override _connect(node: AbstractAudioNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: AbstractAudioNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected _onEnded = () => {\n        this._enginePlayTime = 0;\n\n        this.onEndedObservable.notifyObservers(this);\n        this._deinitSourceNode();\n    };\n\n    private _deinitSourceNode(): void {\n        if (!this._sourceNode) {\n            return;\n        }\n\n        if (!this._disconnect(this._sound)) {\n            throw new Error(\"Disconnect failed\");\n        }\n\n        this._sourceNode.disconnect(this._volumeNode);\n        this._sourceNode.removeEventListener(\"ended\", this._onEnded);\n\n        this._sourceNode = null;\n    }\n\n    private _initSourceNode(): void {\n        if (!this._sourceNode) {\n            this._sourceNode = new AudioBufferSourceNode(this._sound._audioContext, { buffer: this._sound.buffer._audioBuffer });\n\n            this._sourceNode.addEventListener(\"ended\", this._onEnded, { once: true });\n            this._sourceNode.connect(this._volumeNode);\n\n            if (!this._connect(this._sound)) {\n                throw new Error(\"Connect failed\");\n            }\n        }\n\n        const node = this._sourceNode;\n        node.detune.value = this._sound.pitch;\n        node.loop = this._options.loop;\n        node.loopEnd = this._options.loopEnd;\n        node.loopStart = this._options.loopStart;\n        node.playbackRate.value = this._sound.playbackRate;\n    }\n\n    private _onEngineStateChanged = () => {\n        if (this.engine.state !== \"running\") {\n            return;\n        }\n\n        if (this._options.loop && this.state === SoundState.Starting) {\n            this.play();\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    };\n}\n"],
  "mappings": "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",
  "names": []
}
