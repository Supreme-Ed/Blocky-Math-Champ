import {
  init_bakedVertexAnimation,
  init_bakedVertexAnimationDeclaration
} from "./chunk-FY3WF3G7.js";
import {
  init_instancesVertex
} from "./chunk-3GKD2CMZ.js";
import {
  init_morphTargetsVertexDeclaration
} from "./chunk-SVH5S56E.js";
import {
  init_morphTargetsVertexGlobal
} from "./chunk-A75QMHDJ.js";
import {
  init_morphTargetsVertex
} from "./chunk-QOVALOJF.js";
import {
  init_bonesVertex
} from "./chunk-MV7NREEA.js";
import {
  init_shadowMapVertexMetric
} from "./chunk-FKGKZ7NJ.js";
import {
  init_bonesDeclaration
} from "./chunk-4QH3AMXR.js";
import {
  init_morphTargetsVertexGlobalDeclaration
} from "./chunk-GLKKHPTW.js";
import {
  init_meshUboDeclaration
} from "./chunk-6CJN4P6B.js";
import {
  init_sceneUboDeclaration
} from "./chunk-P5QS23MJ.js";
import {
  init_clipPlaneVertexDeclaration
} from "./chunk-EA2CB46P.js";
import {
  init_clipPlaneVertex
} from "./chunk-YX2M7NON.js";
import {
  init_helperFunctions
} from "./chunk-W4QLV37H.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-IU6YKOYY.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapVertexExtraDeclaration.js
var name, shader;
var init_shadowMapVertexExtraDeclaration = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapVertexExtraDeclaration.js"() {
    init_shaderStore();
    name = "shadowMapVertexExtraDeclaration";
    shader = `#if SM_NORMALBIAS==1
uniform lightDataSM: vec3f;
#endif
uniform biasAndScaleSM: vec3f;uniform depthValuesSM: vec2f;varying vDepthMetricSM: f32;
#if SM_USEDISTANCE==1
varying vPositionWSM: vec3f;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying zSM: f32;
#endif
`;
    if (!ShaderStore.IncludesShadersStoreWGSL[name]) {
      ShaderStore.IncludesShadersStoreWGSL[name] = shader;
    }
  }
});

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapVertexNormalBias.js
var name2, shader2;
var init_shadowMapVertexNormalBias = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapVertexNormalBias.js"() {
    init_shaderStore();
    name2 = "shadowMapVertexNormalBias";
    shader2 = `#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
var worldLightDirSM: vec3f=normalize(-uniforms.lightDataSM.xyz);
#else
var directionToLightSM: vec3f=uniforms.lightDataSM.xyz-worldPos.xyz;var worldLightDirSM: vec3f=normalize(directionToLightSM);
#endif
var ndlSM: f32=dot(vNormalW,worldLightDirSM);var sinNLSM: f32=sqrt(1.0-ndlSM*ndlSM);var normalBiasSM: f32=uniforms.biasAndScaleSM.y*sinNLSM;worldPos=vec4f(worldPos.xyz-vNormalW*normalBiasSM,worldPos.w);
#endif
`;
    if (!ShaderStore.IncludesShadersStoreWGSL[name2]) {
      ShaderStore.IncludesShadersStoreWGSL[name2] = shader2;
    }
  }
});

// node_modules/@babylonjs/core/ShadersWGSL/shadowMap.vertex.js
var name3, shader3, shadowMapVertexShaderWGSL;
var init_shadowMap_vertex = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/shadowMap.vertex.js"() {
    init_shaderStore();
    init_bonesDeclaration();
    init_bakedVertexAnimationDeclaration();
    init_morphTargetsVertexGlobalDeclaration();
    init_morphTargetsVertexDeclaration();
    init_helperFunctions();
    init_sceneUboDeclaration();
    init_meshUboDeclaration();
    init_shadowMapVertexExtraDeclaration();
    init_clipPlaneVertexDeclaration();
    init_morphTargetsVertexGlobal();
    init_morphTargetsVertex();
    init_instancesVertex();
    init_bonesVertex();
    init_bakedVertexAnimation();
    init_shadowMapVertexNormalBias();
    init_shadowMapVertexMetric();
    init_clipPlaneVertex();
    name3 = "shadowMapVertexShader";
    shader3 = `attribute position: vec3f;
#ifdef NORMAL
attribute normal: vec3f;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute world0: vec4f;attribute world1: vec4f;attribute world2: vec4f;attribute world3: vec4f;
#endif
#include<helperFunctions>
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
#ifdef ALPHATEXTURE
varying vUV: vec2f;uniform diffuseMatrix: mat4x4f;
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;
#ifdef UV1
var uvUpdated: vec2f=input.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=input.uv2;
#endif
#ifdef NORMAL
var normalUpdated: vec3f=input.normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);
#ifdef NORMAL
var normWorldSM: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
var vNormalW: vec3f=normalUpdated/ vec3f(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
var vNormalW: vec3f=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
vertexOutputs.position=scene.viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef UV2
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
#include<clipPlaneVertex>
}`;
    if (!ShaderStore.ShadersStoreWGSL[name3]) {
      ShaderStore.ShadersStoreWGSL[name3] = shader3;
    }
    shadowMapVertexShaderWGSL = { name: name3, shader: shader3 };
  }
});

export {
  shadowMapVertexShaderWGSL,
  init_shadowMap_vertex
};
//# sourceMappingURL=chunk-RSLQTM5T.js.map
