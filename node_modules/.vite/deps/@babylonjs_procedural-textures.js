import {
  ProceduralTexture
} from "./chunk-CY3KAZX4.js";
import "./chunk-TVPPWBFP.js";
import "./chunk-ZN3EIGOC.js";
import "./chunk-NJBK2XMC.js";
import "./chunk-JSI3PP2X.js";
import "./chunk-32ACW7PM.js";
import "./chunk-GT3FRCP2.js";
import "./chunk-L6IWRFIF.js";
import "./chunk-ZXVFJ3IO.js";
import "./chunk-5AQS7OFY.js";
import "./chunk-YC7U4GEU.js";
import "./chunk-QVQCC6KU.js";
import "./chunk-SGWWALOD.js";
import "./chunk-I2PO3XEU.js";
import "./chunk-SZB5QSYK.js";
import "./chunk-RJ5EFZEJ.js";
import {
  SerializationHelper
} from "./chunk-6FOOJLIC.js";
import {
  __decorate,
  serialize,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsTexture,
  serializeAsVector2
} from "./chunk-S2HVPJYT.js";
import {
  Vector2
} from "./chunk-HCCQEXEI.js";
import "./chunk-O3MXSCPD.js";
import "./chunk-NKFA2CX7.js";
import "./chunk-2ZEUD233.js";
import "./chunk-IW7YW5OA.js";
import "./chunk-LUQW2NAL.js";
import "./chunk-4GUORC2E.js";
import "./chunk-AZNEH5GV.js";
import "./chunk-OJJXGLTO.js";
import "./chunk-AYMFJBP3.js";
import "./chunk-GWFZRJMO.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";
import {
  Color3,
  Color4
} from "./chunk-CP6JW3MU.js";
import "./chunk-XAFM6OF7.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import "./chunk-RASTRIFA.js";
import "./chunk-DC5AMYBS.js";

// node_modules/@babylonjs/procedural-textures/brick/brickProceduralTexture.fragment.js
var name = "brickProceduralTexturePixelShader";
var shader = `precision highp float;varying vec2 vPosition;varying vec2 vUV;uniform float numberOfBricksHeight;uniform float numberOfBricksWidth;uniform vec3 brickColor;uniform vec3 jointColor;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}
float noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}
float fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}
return total;}
float roundF(float number){return sign(number)*floor(abs(number)+0.5);}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float brickW=1.0/numberOfBricksWidth;float brickH=1.0/numberOfBricksHeight;float jointWPercentage=0.01;float jointHPercentage=0.05;vec3 color=brickColor;float yi=vUV.y/brickH;float nyi=roundF(yi);float xi=vUV.x/brickW;if (mod(floor(yi),2.0)==0.0){xi=xi-0.5;}
float nxi=roundF(xi);vec2 brickvUV=vec2((xi-floor(xi))/brickH,(yi-floor(yi))/ brickW);if (yi<nyi+jointHPercentage && yi>nyi-jointHPercentage){color=mix(jointColor,vec3(0.37,0.25,0.25),(yi-nyi)/jointHPercentage+0.2);}
else if (xi<nxi+jointWPercentage && xi>nxi-jointWPercentage){color=mix(jointColor,vec3(0.44,0.44,0.44),(xi-nxi)/jointWPercentage+0.2);}
else {float brickColorSwitch=mod(floor(yi)+floor(xi),3.0);if (brickColorSwitch==0.0)
color=mix(color,vec3(0.33,0.33,0.33),0.3);else if (brickColorSwitch==2.0)
color=mix(color,vec3(0.11,0.11,0.11),0.3);}
gl_FragColor=vec4(color,1.0);}`;
if (!ShaderStore.ShadersStore[name]) {
  ShaderStore.ShadersStore[name] = shader;
}

// node_modules/@babylonjs/procedural-textures/brick/brickProceduralTexture.js
var BrickProceduralTexture = class _BrickProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "brickProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this._numberOfBricksHeight = 15;
    this._numberOfBricksWidth = 5;
    this._jointColor = new Color3(0.72, 0.72, 0.72);
    this._brickColor = new Color3(0.77, 0.47, 0.4);
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setFloat("numberOfBricksHeight", this._numberOfBricksHeight);
    this.setFloat("numberOfBricksWidth", this._numberOfBricksWidth);
    this.setColor3("brickColor", this._brickColor);
    this.setColor3("jointColor", this._jointColor);
  }
  get numberOfBricksHeight() {
    return this._numberOfBricksHeight;
  }
  set numberOfBricksHeight(value) {
    this._numberOfBricksHeight = value;
    this.updateShaderUniforms();
  }
  get numberOfBricksWidth() {
    return this._numberOfBricksWidth;
  }
  set numberOfBricksWidth(value) {
    this._numberOfBricksWidth = value;
    this.updateShaderUniforms();
  }
  get jointColor() {
    return this._jointColor;
  }
  set jointColor(value) {
    this._jointColor = value;
    this.updateShaderUniforms();
  }
  get brickColor() {
    return this._brickColor;
  }
  set brickColor(value) {
    this._brickColor = value;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this brick procedural texture
   * @returns a serialized brick procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.BrickProceduralTexture";
    return serializationObject;
  }
  /**
   * Creates a Brick Procedural Texture from parsed brick procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing brick procedural texture information
   * @returns a parsed Brick Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _BrickProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    return texture;
  }
};
__decorate([
  serialize()
], BrickProceduralTexture.prototype, "numberOfBricksHeight", null);
__decorate([
  serialize()
], BrickProceduralTexture.prototype, "numberOfBricksWidth", null);
__decorate([
  serializeAsColor3()
], BrickProceduralTexture.prototype, "jointColor", null);
__decorate([
  serializeAsColor3()
], BrickProceduralTexture.prototype, "brickColor", null);
RegisterClass("BABYLON.BrickProceduralTexture", BrickProceduralTexture);

// node_modules/@babylonjs/procedural-textures/cloud/cloudProceduralTexture.fragment.js
var name2 = "cloudProceduralTexturePixelShader";
var shader2 = `precision highp float;varying vec2 vUV;uniform vec4 skyColor;uniform vec4 cloudColor;uniform float amplitude;uniform int numOctaves;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}
float noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}
float fbm(vec2 n) {float total=0.0,ampl=amplitude;
#ifdef WEBGL2
for (int i=0; i<numOctaves; i++) {
#else
for (int i=0; i<4; i++) {
#endif
total+=noise(n)*ampl;n+=n;ampl*=0.5;}
return total;}
void main() {vec2 p=vUV*12.0;vec4 c=mix(skyColor,cloudColor,fbm(p));gl_FragColor=c;}
`;
if (!ShaderStore.ShadersStore[name2]) {
  ShaderStore.ShadersStore[name2] = shader2;
}

// node_modules/@babylonjs/procedural-textures/cloud/cloudProceduralTexture.js
var CloudProceduralTexture = class _CloudProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "cloudProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this._skyColor = new Color4(0.15, 0.68, 1, 1);
    this._cloudColor = new Color4(1, 1, 1, 1);
    this._amplitude = 1;
    this._numOctaves = 4;
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setColor4("skyColor", this._skyColor);
    this.setColor4("cloudColor", this._cloudColor);
    this.setFloat("amplitude", this._amplitude);
    this.setInt("numOctaves", this._numOctaves);
  }
  get skyColor() {
    return this._skyColor;
  }
  set skyColor(value) {
    this._skyColor = value;
    this.updateShaderUniforms();
  }
  get cloudColor() {
    return this._cloudColor;
  }
  set cloudColor(value) {
    this._cloudColor = value;
    this.updateShaderUniforms();
  }
  get amplitude() {
    return this._amplitude;
  }
  set amplitude(value) {
    this._amplitude = value;
    this.updateShaderUniforms();
  }
  get numOctaves() {
    return this._numOctaves;
  }
  set numOctaves(value) {
    this._numOctaves = value;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this cloud procedural texture
   * @returns a serialized cloud procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.CloudProceduralTexture";
    return serializationObject;
  }
  /**
   * Creates a Cloud Procedural Texture from parsed cloud procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing cloud procedural texture information
   * @returns a parsed Cloud Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _CloudProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    return texture;
  }
};
__decorate([
  serializeAsColor4()
], CloudProceduralTexture.prototype, "skyColor", null);
__decorate([
  serializeAsColor4()
], CloudProceduralTexture.prototype, "cloudColor", null);
__decorate([
  serialize()
], CloudProceduralTexture.prototype, "amplitude", null);
__decorate([
  serialize()
], CloudProceduralTexture.prototype, "numOctaves", null);
RegisterClass("BABYLON.CloudProceduralTexture", CloudProceduralTexture);

// node_modules/@babylonjs/procedural-textures/fire/fireProceduralTexture.fragment.js
var name3 = "fireProceduralTexturePixelShader";
var shader3 = `precision highp float;uniform float time;uniform vec3 c1;uniform vec3 c2;uniform vec3 c3;uniform vec3 c4;uniform vec3 c5;uniform vec3 c6;uniform vec2 speed;uniform float shift;uniform float alphaThreshold;varying vec2 vUV;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}
float noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}
float fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}
return total;}
void main() {vec2 p=vUV*8.0;float q=fbm(p-time*0.1);vec2 r=vec2(fbm(p+q+time*speed.x-p.x-p.y),fbm(p+q-time*speed.y));vec3 c=mix(c1,c2,fbm(p+r))+mix(c3,c4,r.x)-mix(c5,c6,r.y);vec3 color=c*cos(shift*vUV.y);float luminance=dot(color.rgb,vec3(0.3,0.59,0.11));gl_FragColor=vec4(color,luminance*alphaThreshold+(1.0-alphaThreshold));}`;
if (!ShaderStore.ShadersStore[name3]) {
  ShaderStore.ShadersStore[name3] = shader3;
}

// node_modules/@babylonjs/procedural-textures/fire/fireProceduralTexture.js
var FireProceduralTexture = class _FireProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "fireProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this._time = 0;
    this._speed = new Vector2(0.5, 0.3);
    this._autoGenerateTime = true;
    this._alphaThreshold = 0.5;
    this._fireColors = _FireProceduralTexture.RedFireColors;
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setFloat("time", this._time);
    this.setVector2("speed", this._speed);
    this.setColor3("c1", this._fireColors[0]);
    this.setColor3("c2", this._fireColors[1]);
    this.setColor3("c3", this._fireColors[2]);
    this.setColor3("c4", this._fireColors[3]);
    this.setColor3("c5", this._fireColors[4]);
    this.setColor3("c6", this._fireColors[5]);
    this.setFloat("alphaThreshold", this._alphaThreshold);
  }
  render(useCameraPostProcess) {
    const scene = this.getScene();
    if (this._autoGenerateTime && scene) {
      this._time += scene.getAnimationRatio() * 0.03;
      this.updateShaderUniforms();
    }
    super.render(useCameraPostProcess);
  }
  static get PurpleFireColors() {
    return [new Color3(0.5, 0, 1), new Color3(0.9, 0, 1), new Color3(0.2, 0, 1), new Color3(1, 0.9, 1), new Color3(0.1, 0.1, 1), new Color3(0.9, 0.9, 1)];
  }
  static get GreenFireColors() {
    return [new Color3(0.5, 1, 0), new Color3(0.5, 1, 0), new Color3(0.3, 0.4, 0), new Color3(0.5, 1, 0), new Color3(0.2, 0, 0), new Color3(0.5, 1, 0)];
  }
  static get RedFireColors() {
    return [new Color3(0.5, 0, 0.1), new Color3(0.9, 0, 0), new Color3(0.2, 0, 0), new Color3(1, 0.9, 0), new Color3(0.1, 0.1, 0.1), new Color3(0.9, 0.9, 0.9)];
  }
  static get BlueFireColors() {
    return [new Color3(0.1, 0, 0.5), new Color3(0, 0, 0.5), new Color3(0.1, 0, 0.2), new Color3(0, 0, 1), new Color3(0.1, 0.2, 0.3), new Color3(0, 0.2, 0.9)];
  }
  get autoGenerateTime() {
    return this._autoGenerateTime;
  }
  set autoGenerateTime(value) {
    this._autoGenerateTime = value;
  }
  get fireColors() {
    return this._fireColors;
  }
  set fireColors(value) {
    this._fireColors = value;
    this.updateShaderUniforms();
  }
  get time() {
    return this._time;
  }
  set time(value) {
    this._time = value;
    this.updateShaderUniforms();
  }
  get speed() {
    return this._speed;
  }
  set speed(value) {
    this._speed = value;
    this.updateShaderUniforms();
  }
  get alphaThreshold() {
    return this._alphaThreshold;
  }
  set alphaThreshold(value) {
    this._alphaThreshold = value;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this fire procedural texture
   * @returns a serialized fire procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.FireProceduralTexture";
    serializationObject.fireColors = [];
    for (let i = 0; i < this._fireColors.length; i++) {
      serializationObject.fireColors.push(this._fireColors[i].asArray());
    }
    return serializationObject;
  }
  /**
   * Creates a Fire Procedural Texture from parsed fire procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing fire procedural texture information
   * @returns a parsed Fire Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _FireProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    const colors = [];
    for (let i = 0; i < parsedTexture.fireColors.length; i++) {
      colors.push(Color3.FromArray(parsedTexture.fireColors[i]));
    }
    texture.fireColors = colors;
    return texture;
  }
};
__decorate([
  serialize()
], FireProceduralTexture.prototype, "autoGenerateTime", null);
__decorate([
  serialize()
], FireProceduralTexture.prototype, "time", null);
__decorate([
  serializeAsVector2()
], FireProceduralTexture.prototype, "speed", null);
__decorate([
  serialize()
], FireProceduralTexture.prototype, "alphaThreshold", null);
RegisterClass("BABYLON.FireProceduralTexture", FireProceduralTexture);

// node_modules/@babylonjs/procedural-textures/grass/grassProceduralTexture.fragment.js
var name4 = "grassProceduralTexturePixelShader";
var shader4 = `precision highp float;varying vec2 vPosition;varying vec2 vUV;uniform vec3 herb1Color;uniform vec3 herb2Color;uniform vec3 herb3Color;uniform vec3 groundColor;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}
float noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}
float fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}
return total;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec3 color=mix(groundColor,herb1Color,rand(gl_FragCoord.xy*4.0));color=mix(color,herb2Color,rand(gl_FragCoord.xy*8.0));color=mix(color,herb3Color,rand(gl_FragCoord.xy));color=mix(color,herb1Color,fbm(gl_FragCoord.xy*16.0));gl_FragColor=vec4(color,1.0);
#define CUSTOM_FRAGMENT_MAIN_END
}`;
if (!ShaderStore.ShadersStore[name4]) {
  ShaderStore.ShadersStore[name4] = shader4;
}

// node_modules/@babylonjs/procedural-textures/grass/grassProceduralTexture.js
var GrassProceduralTexture = class _GrassProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "grassProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this._groundColor = new Color3(1, 1, 1);
    this._grassColors = [new Color3(0.29, 0.38, 0.02), new Color3(0.36, 0.49, 0.09), new Color3(0.51, 0.6, 0.28)];
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setColor3("herb1Color", this._grassColors[0]);
    this.setColor3("herb2Color", this._grassColors[1]);
    this.setColor3("herb3Color", this._grassColors[2]);
    this.setColor3("groundColor", this._groundColor);
  }
  get grassColors() {
    return this._grassColors;
  }
  set grassColors(value) {
    this._grassColors = value;
    this.updateShaderUniforms();
  }
  get groundColor() {
    return this._groundColor;
  }
  set groundColor(value) {
    this._groundColor = value;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this grass procedural texture
   * @returns a serialized grass procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.GrassProceduralTexture";
    serializationObject.grassColors = [];
    for (let i = 0; i < this._grassColors.length; i++) {
      serializationObject.grassColors.push(this._grassColors[i].asArray());
    }
    return serializationObject;
  }
  /**
   * Creates a Grass Procedural Texture from parsed grass procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing grass procedural texture information
   * @returns a parsed Grass Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _GrassProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    const colors = [];
    for (let i = 0; i < parsedTexture.grassColors.length; i++) {
      colors.push(Color3.FromArray(parsedTexture.grassColors[i]));
    }
    texture.grassColors = colors;
    return texture;
  }
};
__decorate([
  serializeAsColor3()
], GrassProceduralTexture.prototype, "groundColor", null);
RegisterClass("BABYLON.GrassProceduralTexture", GrassProceduralTexture);

// node_modules/@babylonjs/procedural-textures/marble/marbleProceduralTexture.fragment.js
var name5 = "marbleProceduralTexturePixelShader";
var shader5 = `precision highp float;varying vec2 vPosition;varying vec2 vUV;uniform float numberOfTilesHeight;uniform float numberOfTilesWidth;uniform float amplitude;uniform vec3 marbleColor;uniform vec3 jointColor;const vec3 tileSize=vec3(1.1,1.0,1.1);const vec3 tilePct=vec3(0.98,1.0,0.98);float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}
float noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}
float turbulence(vec2 P)
{float val=0.0;float freq=1.0;for (int i=0; i<4; i++)
{val+=abs(noise(P*freq)/freq);freq*=2.07;}
return val;}
float roundF(float number){return sign(number)*floor(abs(number)+0.5);}
vec3 marble_color(float x)
{vec3 col;x=0.5*(x+1.);x=sqrt(x); 
x=sqrt(x);x=sqrt(x);col=vec3(.2+.75*x); 
col.b*=0.95; 
return col;}
void main()
{float brickW=1.0/numberOfTilesWidth;float brickH=1.0/numberOfTilesHeight;float jointWPercentage=0.01;float jointHPercentage=0.01;vec3 color=marbleColor;float yi=vUV.y/brickH;float nyi=roundF(yi);float xi=vUV.x/brickW;if (mod(floor(yi),2.0)==0.0){xi=xi-0.5;}
float nxi=roundF(xi);vec2 brickvUV=vec2((xi-floor(xi))/brickH,(yi-floor(yi))/brickW);if (yi<nyi+jointHPercentage && yi>nyi-jointHPercentage){color=mix(jointColor,vec3(0.37,0.25,0.25),(yi-nyi)/jointHPercentage+0.2);}
else if (xi<nxi+jointWPercentage && xi>nxi-jointWPercentage){color=mix(jointColor,vec3(0.44,0.44,0.44),(xi-nxi)/jointWPercentage+0.2);}
else {float t=6.28*brickvUV.x/(tileSize.x+noise(vec2(vUV)*6.0));t+=amplitude*turbulence(brickvUV.xy);t=sin(t);color=marble_color(t);}
gl_FragColor=vec4(color,0.0);}`;
if (!ShaderStore.ShadersStore[name5]) {
  ShaderStore.ShadersStore[name5] = shader5;
}

// node_modules/@babylonjs/procedural-textures/marble/marbleProceduralTexture.js
var MarbleProceduralTexture = class _MarbleProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "marbleProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this._numberOfTilesHeight = 3;
    this._numberOfTilesWidth = 3;
    this._amplitude = 9;
    this._jointColor = new Color3(0.72, 0.72, 0.72);
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setFloat("numberOfTilesHeight", this._numberOfTilesHeight);
    this.setFloat("numberOfTilesWidth", this._numberOfTilesWidth);
    this.setFloat("amplitude", this._amplitude);
    this.setColor3("jointColor", this._jointColor);
  }
  get numberOfTilesHeight() {
    return this._numberOfTilesHeight;
  }
  set numberOfTilesHeight(value) {
    this._numberOfTilesHeight = value;
    this.updateShaderUniforms();
  }
  get amplitude() {
    return this._amplitude;
  }
  set amplitude(value) {
    this._amplitude = value;
    this.updateShaderUniforms();
  }
  get numberOfTilesWidth() {
    return this._numberOfTilesWidth;
  }
  set numberOfTilesWidth(value) {
    this._numberOfTilesWidth = value;
    this.updateShaderUniforms();
  }
  get jointColor() {
    return this._jointColor;
  }
  set jointColor(value) {
    this._jointColor = value;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this marble procedural texture
   * @returns a serialized marble procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.MarbleProceduralTexture";
    return serializationObject;
  }
  /**
   * Creates a Marble Procedural Texture from parsed marble procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing marble procedural texture information
   * @returns a parsed Marble Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _MarbleProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    return texture;
  }
};
__decorate([
  serialize()
], MarbleProceduralTexture.prototype, "numberOfTilesHeight", null);
__decorate([
  serialize()
], MarbleProceduralTexture.prototype, "amplitude", null);
__decorate([
  serialize()
], MarbleProceduralTexture.prototype, "numberOfTilesWidth", null);
__decorate([
  serialize()
], MarbleProceduralTexture.prototype, "jointColor", null);
RegisterClass("BABYLON.MarbleProceduralTexture", MarbleProceduralTexture);

// node_modules/@babylonjs/procedural-textures/normalMap/normalMapProceduralTexture.fragment.js
var name6 = "normalMapProceduralTexturePixelShader";
var shader6 = `precision highp float;uniform sampler2D baseSampler;uniform float size;varying vec2 vUV;const vec3 LUMA_COEFFICIENT=vec3(0.2126,0.7152,0.0722);float lumaAtCoord(vec2 coord)
{vec3 pixel=texture2D(baseSampler,coord).rgb;float luma=dot(pixel,LUMA_COEFFICIENT);return luma;}
void main()
{float lumaU0=lumaAtCoord(vUV+vec2(-1.0, 0.0)/size);float lumaU1=lumaAtCoord(vUV+vec2( 1.0, 0.0)/size);float lumaV0=lumaAtCoord(vUV+vec2( 0.0,-1.0)/size);float lumaV1=lumaAtCoord(vUV+vec2( 0.0, 1.0)/size);vec2 slope=(vec2(lumaU0-lumaU1,lumaV0-lumaV1)+1.0)*0.5;gl_FragColor=vec4(slope,1.0,1.0);}
`;
if (!ShaderStore.ShadersStore[name6]) {
  ShaderStore.ShadersStore[name6] = shader6;
}

// node_modules/@babylonjs/procedural-textures/normalMap/normalMapProceduralTexture.js
var NormalMapProceduralTexture = class _NormalMapProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "normalMapProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setTexture("baseSampler", this._baseTexture);
    this.setFloat("size", this.getRenderSize());
  }
  render(useCameraPostProcess) {
    super.render(useCameraPostProcess);
  }
  resize(size, generateMipMaps) {
    super.resize(size, generateMipMaps);
    this.updateShaderUniforms();
  }
  isReady() {
    if (!this._baseTexture || !this._baseTexture.isReady()) {
      return false;
    }
    return super.isReady();
  }
  get baseTexture() {
    return this._baseTexture;
  }
  set baseTexture(texture) {
    this._baseTexture = texture;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this normal map procedural texture
   * @returns a serialized normal map procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.NormalMapProceduralTexture";
    return serializationObject;
  }
  /**
   * Creates a Normal Map Procedural Texture from parsed normal map procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing normal map procedural texture information
   * @returns a parsed Normal Map Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _NormalMapProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    return texture;
  }
};
__decorate([
  serializeAsTexture()
], NormalMapProceduralTexture.prototype, "baseTexture", null);
RegisterClass("BABYLON.NormalMapProceduralTexture", NormalMapProceduralTexture);

// node_modules/@babylonjs/procedural-textures/perlinNoise/perlinNoiseProceduralTexture.fragment.js
var name7 = "perlinNoiseProceduralTexturePixelShader";
var shader7 = `precision highp float;uniform float size;uniform float time;uniform float translationSpeed;varying vec2 vUV;float r(float n)
{return fract(cos(n*89.42)*343.42);}
vec2 r(vec2 n)
{return vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); }
float worley(vec2 n,float s)
{float dis=1.0;for(int x=-1; x<=1; x++)
{for(int y=-1; y<=1; y++)
{vec2 p=floor(n/s)+vec2(x,y);float d=length(r(p)+vec2(x,y)-fract(n/s));if (dis>d)
dis=d;}}
return 1.0-dis;}
vec3 hash33(vec3 p3)
{p3=fract(p3*vec3(0.1031,0.11369,0.13787));p3+=dot(p3,p3.yxz+19.19);return -1.0+2.0*fract(vec3((p3.x+p3.y)*p3.z,(p3.x+p3.z)*p3.y,(p3.y+p3.z)*p3.x));}
float perlinNoise(vec3 p)
{vec3 pi=floor(p);vec3 pf=p-pi;vec3 w=pf*pf*(3.0-2.0*pf);return mix(
mix(
mix(
dot(pf-vec3(0,0,0),hash33(pi+vec3(0,0,0))),
dot(pf-vec3(1,0,0),hash33(pi+vec3(1,0,0))),
w.x
),
mix(
dot(pf-vec3(0,0,1),hash33(pi+vec3(0,0,1))),
dot(pf-vec3(1,0,1),hash33(pi+vec3(1,0,1))),
w.x
),
w.z
),
mix(
mix(
dot(pf-vec3(0,1,0),hash33(pi+vec3(0,1,0))),
dot(pf-vec3(1,1,0),hash33(pi+vec3(1,1,0))),
w.x
),
mix(
dot(pf-vec3(0,1,1),hash33(pi+vec3(0,1,1))),
dot(pf-vec3(1,1,1),hash33(pi+vec3(1,1,1))),
w.x
),
w.z
),
w.y
);}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec2 uv=gl_FragCoord.xy+translationSpeed;float dis=(
1.0+perlinNoise(vec3(uv/vec2(size,size),time*0.05)*8.0))
* (1.0+(worley(uv,32.0)+ 0.5*worley(2.0*uv,32.0)+0.25*worley(4.0*uv,32.0))
);gl_FragColor=vec4(vec3(dis/4.0),1.0);}
`;
if (!ShaderStore.ShadersStore[name7]) {
  ShaderStore.ShadersStore[name7] = shader7;
}

// node_modules/@babylonjs/procedural-textures/perlinNoise/perlinNoiseProceduralTexture.js
var PerlinNoiseProceduralTexture = class _PerlinNoiseProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "perlinNoiseProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this.time = 0;
    this.timeScale = 1;
    this.translationSpeed = 1;
    this._currentTranslation = 0;
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setFloat("size", this.getRenderSize());
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const deltaTime = scene.getEngine().getDeltaTime();
    this.time += deltaTime;
    this.setFloat("time", this.time * this.timeScale / 1e3);
    this._currentTranslation += deltaTime * this.translationSpeed / 1e3;
    this.setFloat("translationSpeed", this._currentTranslation);
  }
  render(useCameraPostProcess) {
    this.updateShaderUniforms();
    super.render(useCameraPostProcess);
  }
  resize(size, generateMipMaps) {
    super.resize(size, generateMipMaps);
  }
  /**
   * Serializes this perlin noise procedural texture
   * @returns a serialized perlin noise procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.PerlinNoiseProceduralTexture";
    return serializationObject;
  }
  /**
   * Creates a Perlin Noise Procedural Texture from parsed perlin noise procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing perlin noise procedural texture information
   * @returns a parsed Perlin Noise Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _PerlinNoiseProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    return texture;
  }
};
__decorate([
  serialize()
], PerlinNoiseProceduralTexture.prototype, "time", void 0);
__decorate([
  serialize()
], PerlinNoiseProceduralTexture.prototype, "timeScale", void 0);
__decorate([
  serialize()
], PerlinNoiseProceduralTexture.prototype, "translationSpeed", void 0);
RegisterClass("BABYLON.PerlinNoiseProceduralTexture", PerlinNoiseProceduralTexture);

// node_modules/@babylonjs/procedural-textures/road/roadProceduralTexture.fragment.js
var name8 = "roadProceduralTexturePixelShader";
var shader8 = `precision highp float;varying vec2 vUV; 
uniform vec3 roadColor;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}
float noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}
float fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}
return total;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
float ratioy=mod(gl_FragCoord.y*100.0 ,fbm(vUV*2.0));vec3 color=roadColor*ratioy;gl_FragColor=vec4(color,1.0);
#define CUSTOM_FRAGMENT_MAIN_END
}`;
if (!ShaderStore.ShadersStore[name8]) {
  ShaderStore.ShadersStore[name8] = shader8;
}

// node_modules/@babylonjs/procedural-textures/road/roadProceduralTexture.js
var RoadProceduralTexture = class _RoadProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "roadProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this._roadColor = new Color3(0.53, 0.53, 0.53);
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setColor3("roadColor", this._roadColor);
  }
  get roadColor() {
    return this._roadColor;
  }
  set roadColor(value) {
    this._roadColor = value;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this road procedural texture
   * @returns a serialized road procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.RoadProceduralTexture";
    return serializationObject;
  }
  /**
   * Creates a Road Procedural Texture from parsed road procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing road procedural texture information
   * @returns a parsed Road Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _RoadProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    return texture;
  }
};
__decorate([
  serializeAsColor3()
], RoadProceduralTexture.prototype, "roadColor", null);
RegisterClass("BABYLON.RoadProceduralTexture", RoadProceduralTexture);

// node_modules/@babylonjs/procedural-textures/starfield/starfieldProceduralTexture.fragment.js
var name9 = "starfieldProceduralTexturePixelShader";
var shader9 = `precision highp float;
#define volsteps 20
#define iterations 15
varying vec2 vPosition;varying vec2 vUV;uniform float time;uniform float alpha;uniform float beta;uniform float zoom;uniform float formuparam;uniform float stepsize;uniform float tile;uniform float brightness;uniform float darkmatter;uniform float distfading;uniform float saturation;void main()
{vec3 dir=vec3(vUV*zoom,1.);float localTime=time*0.0001;mat2 rot1=mat2(cos(alpha),sin(alpha),-sin(alpha),cos(alpha));mat2 rot2=mat2(cos(beta),sin(beta),-sin(beta),cos(beta));dir.xz*=rot1;dir.xy*=rot2;vec3 from_=vec3(1.,.5,0.5);from_+=vec3(-2.,localTime*2.,localTime);from_.xz*=rot1;from_.xy*=rot2;float s=0.1,fade=1.;vec3 v=vec3(0.);for (int r=0; r<volsteps; r++) {vec3 p=from_+s*dir*.5;p=abs(vec3(tile)-mod(p,vec3(tile*2.))); 
float pa,a=pa=0.;for (int i=0; i<iterations; i++) {p=abs(p)/dot(p,p)-formuparam; 
a+=abs(length(p)-pa); 
pa=length(p);}
float dm=max(0.,darkmatter-a*a*.001); 
a*=a*a; 
if (r>6) fade*=1.-dm; 
v+=fade;v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; 
fade*=distfading; 
s+=stepsize;}
v=mix(vec3(length(v)),v,saturation); 
gl_FragColor=vec4(v*.01,1.);}`;
if (!ShaderStore.ShadersStore[name9]) {
  ShaderStore.ShadersStore[name9] = shader9;
}

// node_modules/@babylonjs/procedural-textures/starfield/starfieldProceduralTexture.js
var StarfieldProceduralTexture = class _StarfieldProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "starfieldProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this._time = 1;
    this._alpha = 0.5;
    this._beta = 0.8;
    this._zoom = 0.8;
    this._formuparam = 0.53;
    this._stepsize = 0.1;
    this._tile = 0.85;
    this._brightness = 15e-4;
    this._darkmatter = 0.4;
    this._distfading = 0.73;
    this._saturation = 0.85;
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setFloat("time", this._time);
    this.setFloat("alpha", this._alpha);
    this.setFloat("beta", this._beta);
    this.setFloat("zoom", this._zoom);
    this.setFloat("formuparam", this._formuparam);
    this.setFloat("stepsize", this._stepsize);
    this.setFloat("tile", this._tile);
    this.setFloat("brightness", this._brightness);
    this.setFloat("darkmatter", this._darkmatter);
    this.setFloat("distfading", this._distfading);
    this.setFloat("saturation", this._saturation);
  }
  get time() {
    return this._time;
  }
  set time(value) {
    this._time = value;
    this.updateShaderUniforms();
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(value) {
    this._alpha = value;
    this.updateShaderUniforms();
  }
  get beta() {
    return this._beta;
  }
  set beta(value) {
    this._beta = value;
    this.updateShaderUniforms();
  }
  get formuparam() {
    return this._formuparam;
  }
  set formuparam(value) {
    this._formuparam = value;
    this.updateShaderUniforms();
  }
  get stepsize() {
    return this._stepsize;
  }
  set stepsize(value) {
    this._stepsize = value;
    this.updateShaderUniforms();
  }
  get zoom() {
    return this._zoom;
  }
  set zoom(value) {
    this._zoom = value;
    this.updateShaderUniforms();
  }
  get tile() {
    return this._tile;
  }
  set tile(value) {
    this._tile = value;
    this.updateShaderUniforms();
  }
  get brightness() {
    return this._brightness;
  }
  set brightness(value) {
    this._brightness = value;
    this.updateShaderUniforms();
  }
  get darkmatter() {
    return this._darkmatter;
  }
  set darkmatter(value) {
    this._darkmatter = value;
    this.updateShaderUniforms();
  }
  get distfading() {
    return this._distfading;
  }
  set distfading(value) {
    this._distfading = value;
    this.updateShaderUniforms();
  }
  get saturation() {
    return this._saturation;
  }
  set saturation(value) {
    this._saturation = value;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this starfield procedural texture
   * @returns a serialized starfield procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.StarfieldProceduralTexture";
    return serializationObject;
  }
  /**
   * Creates a Starfield Procedural Texture from parsed startfield procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing startfield procedural texture information
   * @returns a parsed Starfield Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _StarfieldProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    return texture;
  }
};
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "time", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "alpha", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "beta", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "formuparam", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "stepsize", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "zoom", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "tile", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "brightness", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "darkmatter", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "distfading", null);
__decorate([
  serialize()
], StarfieldProceduralTexture.prototype, "saturation", null);
RegisterClass("BABYLON.StarfieldProceduralTexture", StarfieldProceduralTexture);

// node_modules/@babylonjs/procedural-textures/wood/woodProceduralTexture.fragment.js
var name10 = "woodProceduralTexturePixelShader";
var shader10 = `precision highp float;varying vec2 vPosition;varying vec2 vUV;uniform float ampScale;uniform vec3 woodColor;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}
float noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}
float fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}
return total;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
float ratioy=mod(vUV.x*ampScale,2.0+fbm(vUV*0.8));vec3 wood=woodColor*ratioy;gl_FragColor=vec4(wood,1.0);
#define CUSTOM_FRAGMENT_MAIN_END
}`;
if (!ShaderStore.ShadersStore[name10]) {
  ShaderStore.ShadersStore[name10] = shader10;
}

// node_modules/@babylonjs/procedural-textures/wood/woodProceduralTexture.js
var WoodProceduralTexture = class _WoodProceduralTexture extends ProceduralTexture {
  constructor(name11, size, scene = null, fallbackTexture, generateMipMaps) {
    super(name11, size, "woodProceduralTexture", scene, fallbackTexture, generateMipMaps);
    this._ampScale = 100;
    this._woodColor = new Color3(0.32, 0.17, 0.09);
    this.updateShaderUniforms();
  }
  updateShaderUniforms() {
    this.setFloat("ampScale", this._ampScale);
    this.setColor3("woodColor", this._woodColor);
  }
  get ampScale() {
    return this._ampScale;
  }
  set ampScale(value) {
    this._ampScale = value;
    this.updateShaderUniforms();
  }
  get woodColor() {
    return this._woodColor;
  }
  set woodColor(value) {
    this._woodColor = value;
    this.updateShaderUniforms();
  }
  /**
   * Serializes this wood procedural texture
   * @returns a serialized wood procedural texture object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this, super.serialize());
    serializationObject.customType = "BABYLON.WoodProceduralTexture";
    return serializationObject;
  }
  /**
   * Creates a Wood Procedural Texture from parsed wood procedural texture data
   * @param parsedTexture defines parsed texture data
   * @param scene defines the current scene
   * @param rootUrl defines the root URL containing wood procedural texture information
   * @returns a parsed Wood Procedural Texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => new _WoodProceduralTexture(parsedTexture.name, parsedTexture._size, scene, void 0, parsedTexture._generateMipMaps), parsedTexture, scene, rootUrl);
    return texture;
  }
};
__decorate([
  serialize()
], WoodProceduralTexture.prototype, "ampScale", null);
__decorate([
  serializeAsColor3()
], WoodProceduralTexture.prototype, "woodColor", null);
RegisterClass("BABYLON.WoodProceduralTexture", WoodProceduralTexture);
export {
  BrickProceduralTexture,
  CloudProceduralTexture,
  FireProceduralTexture,
  GrassProceduralTexture,
  MarbleProceduralTexture,
  NormalMapProceduralTexture,
  PerlinNoiseProceduralTexture,
  RoadProceduralTexture,
  StarfieldProceduralTexture,
  WoodProceduralTexture
};
//# sourceMappingURL=@babylonjs_procedural-textures.js.map
