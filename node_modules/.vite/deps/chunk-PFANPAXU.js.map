{
  "version": 3,
  "sources": ["../../../dev/core/src/PostProcesses/postProcessManager.ts", "../../../dev/core/src/Rendering/renderingGroup.ts", "../../../dev/core/src/Rendering/renderingManager.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * PostProcessManager is used to manage one or more post processes or post process pipelines\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\r\n */\r\nexport class PostProcessManager {\r\n    private _scene: Scene;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param scene The scene that the post process is associated with.\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _prepareBuffers(): void {\r\n        if (this._vertexBuffers[VertexBuffer.PositionKind]) {\r\n            return;\r\n        }\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    private _buildIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    public onBeforeRenderObservable = new Observable<PostProcessManager>();\r\n\r\n    /**\r\n     * Rebuilds the vertex buffers of the manager.\r\n     * @internal\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (!vb) {\r\n            return;\r\n        }\r\n        vb._rebuild();\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Prepares a frame to be run through a post process.\r\n     * @param sourceTexture The input texture to the post processes. (default: null)\r\n     * @param postProcesses An array of post processes to be run. (default: null)\r\n     * @returns True if the post processes were able to be run.\r\n     * @internal\r\n     */\r\n    public _prepareFrame(sourceTexture: Nullable<InternalTexture> = null, postProcesses: Nullable<PostProcess[]> = null): boolean {\r\n        const camera = this._scene.activeCamera;\r\n        if (!camera) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses = postProcesses || <Nullable<PostProcess[]>>camera._postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n\r\n        if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== undefined);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Manually render a set of post processes to a texture.\r\n     * Please note, the frame buffer won't be unbound after the call in case you have more render to do.\r\n     * @param postProcesses An array of post processes to be run.\r\n     * @param targetTexture The render target wrapper to render to.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight\r\n     * @param faceIndex defines the face to render to if a cubemap is defined as the target\r\n     * @param lodLevel defines which lod of the texture to render to\r\n     * @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously\r\n     */\r\n    public directRender(\r\n        postProcesses: PostProcess[],\r\n        targetTexture: Nullable<RenderTargetWrapper> = null,\r\n        forceFullscreenViewport = false,\r\n        faceIndex = 0,\r\n        lodLevel = 0,\r\n        doNotBindFrambuffer = false\r\n    ): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let index = 0; index < postProcesses.length; index++) {\r\n            if (index < postProcesses.length - 1) {\r\n                postProcesses[index + 1].activate(this._scene.activeCamera || this._scene, targetTexture?.texture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport, lodLevel);\r\n                } else if (!doNotBindFrambuffer) {\r\n                    engine.restoreDefaultFramebuffer();\r\n                }\r\n                engine._debugInsertMarker?.(`post process ${postProcesses[index].name} output`);\r\n            }\r\n\r\n            const pp = postProcesses[index];\r\n            const effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore depth buffer\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    /**\r\n     * Finalize the result of the output of the postprocesses.\r\n     * @param doNotPresent If true the result will not be displayed to the screen.\r\n     * @param targetTexture The render target wrapper to render to.\r\n     * @param faceIndex The index of the face to bind the target texture to.\r\n     * @param postProcesses The array of post processes to render.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)\r\n     * @internal\r\n     */\r\n    public _finalizeFrame(\r\n        doNotPresent?: boolean,\r\n        targetTexture?: RenderTargetWrapper,\r\n        faceIndex?: number,\r\n        postProcesses?: Array<PostProcess>,\r\n        forceFullscreenViewport = false\r\n    ): void {\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        postProcesses = postProcesses || <Array<PostProcess>>camera._postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n        if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return;\r\n        }\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let index = 0, len = postProcesses.length; index < len; index++) {\r\n            const pp = postProcesses[index];\r\n\r\n            if (index < len - 1) {\r\n                pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture?.texture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport);\r\n                    pp._outputTexture = targetTexture;\r\n                } else {\r\n                    engine.restoreDefaultFramebuffer();\r\n                    pp._outputTexture = null;\r\n                }\r\n                engine._debugInsertMarker?.(`post process ${postProcesses[index].name} output`);\r\n            }\r\n\r\n            if (doNotPresent) {\r\n                break;\r\n            }\r\n\r\n            const effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore states\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the post process manager.\r\n     */\r\n    public dispose(): void {\r\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n    }\r\n}\r\n", "import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable, DeepImmutable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { IEdgesRenderer } from \"./edgesRenderer\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * This represents the object necessary to create a rendering group.\r\n * This is exclusively used and created by the rendering manager.\r\n * To modify the behavior, you use the available helpers in your scene or meshes.\r\n * @internal\r\n */\r\nexport class RenderingGroup {\r\n    private static _ZeroVector: DeepImmutable<Vector3> = Vector3.Zero();\r\n    private _scene: Scene;\r\n    private _opaqueSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _transparentSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _alphaTestSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _depthOnlySubMeshes = new SmartArray<SubMesh>(256);\r\n    private _particleSystems = new SmartArray<IParticleSystem>(256);\r\n    private _spriteManagers = new SmartArray<ISpriteManager>(256);\r\n\r\n    private _opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _transparentSortCompareFn: (a: SubMesh, b: SubMesh) => number;\r\n\r\n    private _renderOpaque: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderAlphaTest: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderTransparent: (subMeshes: SmartArray<SubMesh>) => void;\r\n\r\n    /** @internal */\r\n    public _empty = true;\r\n\r\n    /** @internal */\r\n    public _edgesRenderers = new SmartArrayNoDuplicate<IEdgesRenderer>(16);\r\n\r\n    public onBeforeTransparentRendering: () => void;\r\n\r\n    /**\r\n     * Set the opaque sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set opaqueSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._opaqueSortCompareFn = value;\r\n        } else {\r\n            this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderOpaque = this._renderOpaqueSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the alpha test sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set alphaTestSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._alphaTestSortCompareFn = value;\r\n        } else {\r\n            this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderAlphaTest = this._renderAlphaTestSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the transparent sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set transparentSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._transparentSortCompareFn = value;\r\n        } else {\r\n            this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\r\n        }\r\n        this._renderTransparent = this._renderTransparentSorted;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rendering group.\r\n     * @param index The rendering group index\r\n     * @param scene\r\n     * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\r\n     * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\r\n     * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\r\n     */\r\n    constructor(\r\n        public index: number,\r\n        scene: Scene,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        this.opaqueSortCompareFn = opaqueSortCompareFn;\r\n        this.alphaTestSortCompareFn = alphaTestSortCompareFn;\r\n        this.transparentSortCompareFn = transparentSortCompareFn;\r\n    }\r\n\r\n    /**\r\n     * Render all the sub meshes contained in the group.\r\n     * @param customRenderFunction Used to override the default render behaviour of the group.\r\n     * @param renderSprites\r\n     * @param renderParticles\r\n     * @param activeMeshes\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        renderSprites: boolean,\r\n        renderParticles: boolean,\r\n        activeMeshes: Nullable<AbstractMesh[]>\r\n    ): void {\r\n        if (customRenderFunction) {\r\n            customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Depth only\r\n        if (this._depthOnlySubMeshes.length !== 0) {\r\n            engine.setColorWrite(false);\r\n            this._renderAlphaTest(this._depthOnlySubMeshes);\r\n            engine.setColorWrite(true);\r\n        }\r\n\r\n        // Opaque\r\n        if (this._opaqueSubMeshes.length !== 0) {\r\n            this._renderOpaque(this._opaqueSubMeshes);\r\n        }\r\n\r\n        // Alpha test\r\n        if (this._alphaTestSubMeshes.length !== 0) {\r\n            this._renderAlphaTest(this._alphaTestSubMeshes);\r\n        }\r\n\r\n        const stencilState = engine.getStencilBuffer();\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Sprites\r\n        if (renderSprites) {\r\n            this._renderSprites();\r\n        }\r\n\r\n        // Particles\r\n        if (renderParticles) {\r\n            this._renderParticles(activeMeshes);\r\n        }\r\n\r\n        if (this.onBeforeTransparentRendering) {\r\n            this.onBeforeTransparentRendering();\r\n        }\r\n\r\n        // Transparent\r\n        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\r\n            engine.setStencilBuffer(stencilState);\r\n            if (this._scene.useOrderIndependentTransparency) {\r\n                const excludedMeshes = this._scene.depthPeelingRenderer!.render(this._transparentSubMeshes);\r\n                if (excludedMeshes.length) {\r\n                    // Render leftover meshes that could not be processed by depth peeling\r\n                    this._renderTransparent(excludedMeshes);\r\n                }\r\n            } else {\r\n                this._renderTransparent(this._transparentSubMeshes);\r\n            }\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Set back stencil to false in case it changes before the edge renderer.\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Edges\r\n        if (this._edgesRenderers.length) {\r\n            for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\r\n                this._edgesRenderers.data[edgesRendererIndex].render();\r\n            }\r\n\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Stencil state.\r\n        engine.setStencilBuffer(stencilState);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderOpaqueSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderAlphaTestSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the transparentSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderTransparentSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\r\n    }\r\n\r\n    /**\r\n     * Renders the submeshes in a specified order.\r\n     * @param subMeshes The submeshes to sort before render\r\n     * @param sortCompareFn The comparison function use to sort\r\n     * @param camera The camera position use to preprocess the submeshes to help sorting\r\n     * @param transparent Specifies to activate blending if true\r\n     */\r\n    private static _RenderSorted(\r\n        subMeshes: SmartArray<SubMesh>,\r\n        sortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>,\r\n        camera: Nullable<Camera>,\r\n        transparent: boolean\r\n    ): void {\r\n        let subIndex = 0;\r\n        let subMesh: SubMesh;\r\n        const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\r\n\r\n        if (transparent) {\r\n            for (; subIndex < subMeshes.length; subIndex++) {\r\n                subMesh = subMeshes.data[subIndex];\r\n                subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\r\n                subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\r\n            }\r\n        }\r\n\r\n        const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\r\n\r\n        if (sortCompareFn) {\r\n            sortedArray.sort(sortCompareFn);\r\n        }\r\n\r\n        const scene = sortedArray[0].getMesh().getScene();\r\n        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\r\n            subMesh = sortedArray[subIndex];\r\n\r\n            if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\r\n                continue;\r\n            }\r\n\r\n            if (transparent) {\r\n                const material = subMesh.getMaterial();\r\n\r\n                if (material && material.needDepthPrePass) {\r\n                    const engine = material.getScene().getEngine();\r\n                    engine.setColorWrite(false);\r\n                    engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n                    subMesh.render(false);\r\n                    engine.setColorWrite(true);\r\n                }\r\n            }\r\n\r\n            subMesh.render(transparent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front if in the same alpha index.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static defaultTransparentSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Alpha index first\r\n        if (a._alphaIndex > b._alphaIndex) {\r\n            return 1;\r\n        }\r\n        if (a._alphaIndex < b._alphaIndex) {\r\n            return -1;\r\n        }\r\n\r\n        // Then distance to camera\r\n        return RenderingGroup.backToFrontSortCompare(a, b);\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static backToFrontSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered front to back (prevent overdraw).\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static frontToBackSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are grouped by material then geometry.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    public static PainterSortCompare(a: SubMesh, b: SubMesh): number {\r\n        const meshA = a.getMesh();\r\n        const meshB = b.getMesh();\r\n\r\n        if (meshA.material && meshB.material) {\r\n            return meshA.material.uniqueId - meshB.material.uniqueId;\r\n        }\r\n\r\n        return meshA.uniqueId - meshB.uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of submeshes to prepare a new frame.\r\n     */\r\n    public prepare(): void {\r\n        this._opaqueSubMeshes.reset();\r\n        this._transparentSubMeshes.reset();\r\n        this._alphaTestSubMeshes.reset();\r\n        this._depthOnlySubMeshes.reset();\r\n        this._particleSystems.reset();\r\n        this.prepareSprites();\r\n        this._edgesRenderers.reset();\r\n        this._empty = true;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of sprites to prepare a new frame.\r\n     */\r\n    public prepareSprites(): void {\r\n        this._spriteManagers.reset();\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._opaqueSubMeshes.dispose();\r\n        this._transparentSubMeshes.dispose();\r\n        this._alphaTestSubMeshes.dispose();\r\n        this._depthOnlySubMeshes.dispose();\r\n        this._particleSystems.dispose();\r\n        this._spriteManagers.dispose();\r\n        this._edgesRenderers.dispose();\r\n    }\r\n\r\n    /**\r\n     * Inserts the submesh in its correct queue depending on its material.\r\n     * @param subMesh The submesh to dispatch\r\n     * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        // Get mesh and materials if not provided\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (material === undefined) {\r\n            material = subMesh.getMaterial();\r\n        }\r\n\r\n        if (material === null || material === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (material.needAlphaBlendingForMesh(mesh)) {\r\n            // Transparent\r\n            this._transparentSubMeshes.push(subMesh);\r\n        } else if (material.needAlphaTestingForMesh(mesh)) {\r\n            // Alpha test\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._alphaTestSubMeshes.push(subMesh);\r\n        } else {\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._opaqueSubMeshes.push(subMesh); // Opaque\r\n        }\r\n\r\n        mesh._renderingGroup = this;\r\n\r\n        if (mesh._edgesRenderer && mesh.isEnabled() && mesh.isVisible && mesh._edgesRenderer.isEnabled) {\r\n            this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\r\n        }\r\n\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        this._spriteManagers.push(spriteManager);\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        this._particleSystems.push(particleSystem);\r\n        this._empty = false;\r\n    }\r\n\r\n    private _renderParticles(activeMeshes: Nullable<AbstractMesh[]>): void {\r\n        if (this._particleSystems.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Particles\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\r\n        for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\r\n            const particleSystem = this._particleSystems.data[particleIndex];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\r\n                continue;\r\n            }\r\n\r\n            const emitter: any = particleSystem.emitter;\r\n            if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\r\n                this._scene._activeParticles.addCount(particleSystem.render(), false);\r\n            }\r\n        }\r\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n\r\n    private _renderSprites(): void {\r\n        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Sprites\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\r\n        for (let id = 0; id < this._spriteManagers.length; id++) {\r\n            const spriteManager = this._spriteManagers.data[id];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\r\n                spriteManager.render();\r\n            }\r\n        }\r\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RenderingGroup } from \"./renderingGroup\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * Interface describing the different options available in the rendering manager\r\n * regarding Auto Clear between groups.\r\n */\r\nexport interface IRenderingManagerAutoClearSetup {\r\n    /**\r\n     * Defines whether or not autoclear is enable.\r\n     */\r\n    autoClear: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the depth buffer.\r\n     */\r\n    depth: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the stencil buffer.\r\n     */\r\n    stencil: boolean;\r\n}\r\n\r\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\r\nexport class RenderingGroupInfo {\r\n    /**\r\n     * The Scene that being rendered\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * The camera currently used for the rendering pass\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The ID of the renderingGroup being processed\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The rendering manager\r\n     */\r\n    renderingManager: RenderingManager;\r\n}\r\n\r\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\r\nexport class RenderingManager {\r\n    /**\r\n     * The max id used for rendering groups (not included)\r\n     */\r\n    public static MAX_RENDERINGGROUPS = 4;\r\n\r\n    /**\r\n     * The min id used for rendering groups (included)\r\n     */\r\n    public static MIN_RENDERINGGROUPS = 0;\r\n\r\n    /**\r\n     * Used to globally prevent autoclearing scenes.\r\n     */\r\n    public static AUTOCLEAR = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _useSceneAutoClearSetup = false;\r\n\r\n    private _scene: Scene;\r\n    private _renderingGroups = new Array<RenderingGroup>();\r\n    private _depthStencilBufferAlreadyCleaned: boolean;\r\n\r\n    private _autoClearDepthStencil: { [id: number]: IRenderingManagerAutoClearSetup } = {};\r\n    private _customOpaqueSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customAlphaTestSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customTransparentSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _renderingGroupInfo: Nullable<RenderingGroupInfo> = new RenderingGroupInfo();\r\n\r\n    private _maintainStateBetweenFrames = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the manager will not reset between frames.\r\n     * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.\r\n     * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).\r\n     * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.\r\n     */\r\n    public get maintainStateBetweenFrames() {\r\n        return this._maintainStateBetweenFrames;\r\n    }\r\n\r\n    public set maintainStateBetweenFrames(value: boolean) {\r\n        if (value === this._maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        this._maintainStateBetweenFrames = value;\r\n        if (!this._maintainStateBetweenFrames) {\r\n            this.restoreDispachedFlags();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore wasDispatched flags on the lists of elements to render.\r\n     */\r\n    public restoreDispachedFlags() {\r\n        for (const mesh of this._scene.meshes) {\r\n            if (mesh.subMeshes) {\r\n                for (const subMesh of mesh.subMeshes) {\r\n                    subMesh._wasDispatched = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._scene.spriteManagers) {\r\n            for (const spriteManager of this._scene.spriteManagers) {\r\n                spriteManager._wasDispatched = false;\r\n            }\r\n        }\r\n\r\n        for (const particleSystem of this._scene.particleSystems) {\r\n            particleSystem._wasDispatched = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new rendering group for a particular scene\r\n     * @param scene Defines the scene the groups belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n\r\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\r\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the rendering group with the specified id.\r\n     * @param id the id of the rendering group (0 by default)\r\n     */\r\n    public getRenderingGroup(id: number): RenderingGroup {\r\n        const renderingGroupId = id || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        return this._renderingGroups[renderingGroupId];\r\n    }\r\n\r\n    private _clearDepthStencilBuffer(depth = true, stencil = true): void {\r\n        if (this._depthStencilBufferAlreadyCleaned) {\r\n            return;\r\n        }\r\n\r\n        this._scene.getEngine().clear(null, false, depth, stencil);\r\n        this._depthStencilBufferAlreadyCleaned = true;\r\n    }\r\n\r\n    /**\r\n     * Renders the entire managed groups. This is used by the scene or the different render targets.\r\n     * @internal\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        activeMeshes: Nullable<AbstractMesh[]>,\r\n        renderParticles: boolean,\r\n        renderSprites: boolean\r\n    ): void {\r\n        // Update the observable context (not null as it only goes away on dispose)\r\n        const info = this._renderingGroupInfo!;\r\n        info.scene = this._scene;\r\n        info.camera = this._scene.activeCamera;\r\n        info.renderingManager = this;\r\n\r\n        // Dispatch sprites\r\n        if (this._scene.spriteManagers && renderSprites) {\r\n            for (let index = 0; index < this._scene.spriteManagers.length; index++) {\r\n                const manager = this._scene.spriteManagers[index];\r\n                this.dispatchSprites(manager);\r\n            }\r\n        }\r\n\r\n        // Render\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (!renderingGroup || renderingGroup._empty) {\r\n                continue;\r\n            }\r\n\r\n            const renderingGroupMask = 1 << index;\r\n            info.renderingGroupId = index;\r\n\r\n            // Before Observable\r\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n\r\n            // Clear depth/stencil if needed\r\n            if (RenderingManager.AUTOCLEAR) {\r\n                const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\r\n\r\n                if (autoClear && autoClear.autoClear) {\r\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\r\n                }\r\n            }\r\n\r\n            // Render\r\n            for (const step of this._scene._beforeRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\r\n            for (const step of this._scene._afterRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n\r\n            // After Observable\r\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the different information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public reset(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepare();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the sprites information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public resetSprites(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepareSprites();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the group and its associated resources.\r\n     * @internal\r\n     */\r\n    public dispose(): void {\r\n        this.freeRenderingGroups();\r\n        this._renderingGroups.length = 0;\r\n        this._renderingGroupInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _prepareRenderingGroup(renderingGroupId: number): void {\r\n        if (this._renderingGroups[renderingGroupId] === undefined) {\r\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(\r\n                renderingGroupId,\r\n                this._scene,\r\n                this._customOpaqueSortCompareFn[renderingGroupId],\r\n                this._customAlphaTestSortCompareFn[renderingGroupId],\r\n                this._customTransparentSortCompareFn[renderingGroupId]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a sprite manager to the rendering manager in order to render it this frame.\r\n     * @param spriteManager Define the sprite manager to render\r\n     */\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {\r\n            return;\r\n        }\r\n        spriteManager._wasDispatched = true;\r\n        this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);\r\n    }\r\n\r\n    /**\r\n     * Add a particle system to the rendering manager in order to render it this frame.\r\n     * @param particleSystem Define the particle system to render\r\n     */\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {\r\n            return;\r\n        }\r\n        particleSystem._wasDispatched = true;\r\n        this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);\r\n    }\r\n\r\n    /**\r\n     * Add a submesh to the manager in order to render it this frame\r\n     * @param subMesh The submesh to dispatch\r\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {\r\n            return;\r\n        }\r\n        subMesh._wasDispatched = true;\r\n        this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\r\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\r\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\r\n\r\n        if (this._renderingGroups[renderingGroupId]) {\r\n            const group = this._renderingGroups[renderingGroupId];\r\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\r\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\r\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._autoClearDepthStencil[renderingGroupId] = {\r\n            autoClear: autoClearDepthStencil,\r\n            depth: depth,\r\n            stencil: stencil,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._autoClearDepthStencil[index];\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
