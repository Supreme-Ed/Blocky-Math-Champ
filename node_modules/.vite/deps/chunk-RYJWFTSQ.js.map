{
  "version": 3,
  "sources": ["../../../dev/core/src/Lights/light.ts"],
  "sourcesContent": ["import { serialize, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Light type const id of the area light.\r\n     */\r\n    public static readonly LIGHTTYPEID_RECT_AREALIGHT = LightConstants.LIGHTTYPEID_RECT_AREALIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getViewMatrix(_faceIndex?: number): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param _viewMatrix The view transform matrix of the light (optional).\r\n     * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getProjectionMatrix(_viewMatrix?: Matrix, _renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Shadow generators associated to the light.\r\n     * @internal Internal use only.\r\n     */\r\n    public _shadowGenerators: Nullable<Map<Nullable<Camera>, IShadowGenerator>> = null;\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene, false);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = [] as AbstractMesh[];\r\n        this.excludedMeshes = [] as AbstractMesh[];\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public override toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public override setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\r\n     * @returns the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(camera: Nullable<Camera> = null): Nullable<IShadowGenerator> {\r\n        if (this._shadowGenerators === null) {\r\n            return null;\r\n        }\r\n\r\n        return this._shadowGenerators.get(camera) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Returns all the shadow generators associated to this light\r\n     * @returns\r\n     */\r\n    public getShadowGenerators(): Nullable<Map<Nullable<Camera>, IShadowGenerator>> {\r\n        return this._shadowGenerators;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @returns true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.dispose();\r\n            }\r\n            this._shadowGenerators = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        if (parsedLight.parentInstanceIndex !== undefined) {\r\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @internal Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * @returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @internal Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isReady() {\r\n        return true;\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqBsB;;;;AArBtB;AAIA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AAMM,IAAgB,QAAhB,MAAgB,eAAc,KAAI;;;;;MAoIpC,IAAW,QAAK;AACZ,eAAO,KAAK;MAChB;;;;;MAKA,IAAW,MAAM,OAAa;AAC1B,aAAK,SAAS;AACd,aAAK,uBAAuB,KAAO,KAAK,QAAQ,KAAK;MACzD;;;;;MAcA,IAAW,gBAAa;AACpB,eAAO,KAAK;MAChB;;;;;MAKA,IAAW,cAAc,OAAa;AAClC,aAAK,iBAAiB;AACtB,aAAK,yBAAwB;MACjC;;;;MAOA,IAAW,SAAM;AACb,eAAO,KAAK;MAChB;;;;MAIA,IAAW,OAAO,OAAa;AAC3B,aAAK,UAAU;AACf,aAAK,yBAAwB;MACjC;;;;;MAiBA,IAAW,gBAAa;AACpB,eAAO,KAAK;MAChB;;;;;MAKA,IAAW,cAAc,OAAc;AACnC,YAAI,KAAK,mBAAmB,OAAO;AAC/B;QACJ;AAEA,aAAK,iBAAiB;AACtB,aAAK,wBAAuB;MAChC;;;;MAMA,IAAW,qBAAkB;AACzB,eAAO,KAAK;MAChB;;;;MAIA,IAAW,mBAAmB,OAAqB;AAC/C,aAAK,sBAAsB;AAC3B,aAAK,0BAA0B,KAAK;MACxC;;;;MAMA,IAAW,iBAAc;AACrB,eAAO,KAAK;MAChB;;;;MAIA,IAAW,eAAe,OAAqB;AAC3C,aAAK,kBAAkB;AACvB,aAAK,sBAAsB,KAAK;MACpC;;;;;MAQA,IAAW,uBAAoB;AAC3B,eAAO,KAAK;MAChB;;;;;MAKA,IAAW,qBAAqB,OAAa;AACzC,aAAK,wBAAwB;AAC7B,aAAK,cAAa;MACtB;;;;;MAQA,IAAW,2BAAwB;AAC/B,eAAO,KAAK;MAChB;;;;;MAKA,IAAW,yBAAyB,OAAa;AAC7C,aAAK,4BAA4B;AACjC,aAAK,cAAa;MACtB;;;;MAOA,IAAW,eAAY;AACnB,eAAO,KAAK;MAChB;;;;MAIA,IAAW,aAAa,OAAa;AACjC,YAAI,KAAK,kBAAkB,OAAO;AAC9B;QACJ;AAEA,aAAK,gBAAgB;AACrB,aAAK,wBAAuB;MAChC;;;;;;MAOO,cAAc,YAAmB;AACpC,eAAO;MACX;;;;;;;;MASO,oBAAoB,aAAsB,aAAiC;AAC9E,eAAO;MACX;;;;;;;MAmCA,YAAY,MAAc,OAAa;AACnC,cAAM,MAAM,OAAO,KAAK;AAnQrB,aAAA,UAAU,IAAI,OAAO,GAAK,GAAK,CAAG;AAOlC,aAAA,WAAW,IAAI,OAAO,GAAK,GAAK,CAAG;AAWnC,aAAA,cAAc,OAAM;AAQpB,aAAA,YAAY;AAEX,aAAA,SAAS,OAAO;AACd,aAAA,uBAAuB;AAuBzB,aAAA,oBAAoB;AAEpB,aAAA,iBAAyB,OAAM;AAkB/B,aAAA,UAAU;AAuBX,aAAA,iBAAyB;AAGxB,aAAA,iBAA0B;AAoD1B,aAAA,wBAAwB;AAkBxB,aAAA,4BAA4B;AAkB5B,aAAA,gBAAgB;AA2CjB,aAAA,oBAAuE;AAKvE,aAAA,qBAAqB,IAAI,MAAK;AAK9B,aAAA,yBAAyB,IAAI,MAAK;AAwHzB,aAAA,WAAW;AAnGvB,aAAK,SAAQ,EAAG,SAAS,IAAI;AAC7B,aAAK,iBAAiB,IAAI,cAAc,KAAK,SAAQ,EAAG,UAAS,GAAI,QAAW,QAAW,IAAI;AAC/F,aAAK,oBAAmB;AAExB,aAAK,qBAAqB,CAAA;AAC1B,aAAK,iBAAiB,CAAA;AAEtB,aAAK,cAAa;MACtB;;;;;;;;MAmBO,yBAAyB,QAAgB,YAAkB;AAE9D,eAAO;MACX;;;;;;;;;MAUO,WAAW,YAAoB,OAAc,QAAgB,aAAsB,iBAAiB,MAAI;AAC3G,cAAM,YAAY,WAAW,SAAQ;AACrC,YAAI,aAAa;AAEjB,aAAK,eAAe,aAAa,QAAQ,UAAU,SAAS;AAE5D,YAAI,KAAK,cAAc,MAAM,YAAW,KAAM,KAAK,qBAAqB,eAAe,CAAC,KAAK,eAAe,QAAQ;AAChH,eAAK,YAAY,MAAM,YAAW;AAClC,eAAK,mBAAmB;AAExB,gBAAM,kBAAkB,KAAK,mBAAkB;AAE/C,eAAK,iBAAiB,QAAQ,SAAS;AAEvC,eAAK,QAAQ,WAAW,iBAAiB,UAAU,OAAO,CAAC,CAAC;AAC5D,eAAK,eAAe,aAAa,iBAAiB,UAAU,OAAO,CAAC,GAAG,KAAK,OAAO,SAAS;AAC5F,cAAI,aAAa;AACb,iBAAK,SAAS,WAAW,iBAAiB,UAAU,OAAO,CAAC,CAAC;AAC7D,iBAAK,eAAe,aAAa,kBAAkB,UAAU,OAAO,CAAC,GAAG,KAAK,QAAQ,SAAS;UAClG;AACA,uBAAa;QACjB;AAGA,aAAK,yBAAyB,QAAQ,SAAS;AAG/C,YAAI,MAAM,kBAAkB,KAAK,iBAAiB,gBAAgB;AAC9D,gBAAM,kBAAkB,KAAK,mBAAmB,MAAM,YAAY,KAAK,KAAK,mBAAkB;AAC9F,cAAI,iBAAiB;AACjB,4BAAgB,gBAAgB,WAAW,MAAM;AACjD,yBAAa;UACjB;QACJ;AAEA,YAAI,YAAY;AACZ,eAAK,eAAe,OAAM;QAC9B,OAAO;AACH,eAAK,eAAe,kBAAiB;QACzC;MACJ;;;;;MAcgB,eAAY;AACxB,eAAO;MACX;;;;;;MAUgB,SAAS,aAAqB;AAC1C,YAAI,MAAM,WAAW,KAAK;AAC1B,eAAO,aAAa,CAAC,SAAS,eAAe,QAAQ,aAAa,EAAE,KAAK,UAAS,CAAE;AACpF,YAAI,KAAK,YAAY;AACjB,mBAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,KAAK;AAC7C,mBAAO,qBAAqB,KAAK,WAAW,CAAC,EAAE,SAAS,WAAW;UACvE;QACJ;AACA,eAAO;MACX;;MAGmB,0BAAuB;AACtC,cAAM,wBAAuB;AAC7B,YAAI,CAAC,KAAK,WAAU,GAAI;AACpB,eAAK,cAAa;QACtB;MACJ;;;;;MAMgB,WAAW,OAAc;AACrC,cAAM,WAAW,KAAK;AAEtB,aAAK,cAAa;MACtB;;;;;;MAOO,mBAAmB,SAA2B,MAAI;AACrD,YAAI,KAAK,sBAAsB,MAAM;AACjC,iBAAO;QACX;AAEA,eAAO,KAAK,kBAAkB,IAAI,MAAM,KAAK;MACjD;;;;;MAMO,sBAAmB;AACtB,eAAO,KAAK;MAChB;;;;;MAMO,sBAAmB;AACtB,eAAO,QAAQ,KAAI;MACvB;;;;;;MAOO,cAAc,MAAkB;AACnC,YAAI,CAAC,MAAM;AACP,iBAAO;QACX;AAEA,YAAI,KAAK,sBAAsB,KAAK,mBAAmB,SAAS,KAAK,KAAK,mBAAmB,QAAQ,IAAI,MAAM,IAAI;AAC/G,iBAAO;QACX;AAEA,YAAI,KAAK,kBAAkB,KAAK,eAAe,SAAS,KAAK,KAAK,eAAe,QAAQ,IAAI,MAAM,IAAI;AACnG,iBAAO;QACX;AAEA,YAAI,KAAK,6BAA6B,MAAM,KAAK,2BAA2B,KAAK,eAAe,GAAG;AAC/F,iBAAO;QACX;AAEA,YAAI,KAAK,yBAAyB,KAAK,KAAK,uBAAuB,KAAK,WAAW;AAC/E,iBAAO;QACX;AAEA,eAAO;MACX;;;;;;MAOgB,QAAQ,cAAwB,6BAA6B,OAAK;AAC9E,YAAI,KAAK,mBAAmB;AACxB,gBAAM,WAAW,KAAK,kBAAkB,OAAM;AAC9C,mBAAS,MAAM,SAAS,KAAI,GAAI,IAAI,SAAS,MAAM,MAAM,SAAS,KAAI,GAAI;AACtE,kBAAM,kBAAkB,IAAI;AAC5B,4BAAgB,QAAO;UAC3B;AACA,eAAK,oBAAoB;QAC7B;AAGA,aAAK,SAAQ,EAAG,cAAc,IAAI;AAElC,YAAI,KAAK,kBAAkB;AACvB,gBAAM,QAAQ,KAAK,iBAAiB,OAAO,QAAQ,IAAI;AACvD,cAAI,QAAQ,IAAI;AACZ,iBAAK,iBAAiB,OAAO,OAAO,OAAO,CAAC;UAChD;AACA,eAAK,mBAAmB;QAC5B;AAGA,mBAAW,QAAQ,KAAK,SAAQ,EAAG,QAAQ;AACvC,eAAK,mBAAmB,MAAM,IAAI;QACtC;AAEA,aAAK,eAAe,QAAO;AAG3B,aAAK,SAAQ,EAAG,YAAY,IAAI;AAChC,cAAM,QAAQ,cAAc,0BAA0B;MAC1D;;;;;MAMO,YAAS;AACZ,eAAO;MACX;;;;;MAMO,qBAAkB;AACrB,eAAO,KAAK,oBAAoB,KAAK;MACzC;;;;;;;MAQgB,MAAM,MAAc,YAA4B,MAAI;AAChE,cAAM,cAAc,OAAM,uBAAuB,KAAK,UAAS,GAAI,MAAM,KAAK,SAAQ,CAAE;AAExF,YAAI,CAAC,aAAa;AACd,iBAAO;QACX;AACA,cAAM,cAAc,oBAAoB,MAAM,aAAa,IAAI;AAC/D,YAAI,MAAM;AACN,sBAAY,OAAO;QACvB;AACA,YAAI,WAAW;AACX,sBAAY,SAAS;QACzB;AACA,oBAAY,WAAW,KAAK,UAAS,CAAE;AAEvC,aAAK,mBAAmB,gBAAgB,WAAW;AAEnD,eAAO;MACX;;;;;MAMO,YAAS;AACZ,cAAM,sBAAsB,oBAAoB,UAAU,IAAI;AAC9D,4BAAoB,WAAW,KAAK;AAGpC,4BAAoB,OAAO,KAAK,UAAS;AAGzC,YAAI,KAAK,QAAQ;AACb,eAAK,OAAO,mBAAmB,mBAAmB;QACtD;AAGA,YAAI,KAAK,eAAe,SAAS,GAAG;AAChC,8BAAoB,oBAAoB,CAAA;AACxC,eAAK,eAAe,QAAQ,CAAC,SAAsB;AAC/C,gCAAoB,kBAAkB,KAAK,KAAK,EAAE;UACtD,CAAC;QACL;AAEA,YAAI,KAAK,mBAAmB,SAAS,GAAG;AACpC,8BAAoB,wBAAwB,CAAA;AAC5C,eAAK,mBAAmB,QAAQ,CAAC,SAAsB;AACnD,gCAAoB,sBAAsB,KAAK,KAAK,EAAE;UAC1D,CAAC;QACL;AAGA,4BAAoB,2BAA2B,MAAM,mBAAmB;AACxE,4BAAoB,SAAS,KAAK,yBAAwB;AAE1D,4BAAoB,YAAY,KAAK,UAAS;AAE9C,eAAO;MACX;;;;;;;;;MAUA,OAAO,uBAAuB,MAAc,MAAc,OAAY;AAClE,cAAM,kBAAkB,KAAK,UAAU,gBAAgB,MAAM,MAAM,KAAK;AAExE,YAAI,iBAAiB;AACjB,iBAAoB;QACxB;AAGA,eAAO;MACX;;;;;;;MAQO,OAAO,MAAM,aAAkB,OAAY;AAC9C,cAAM,cAAc,OAAM,uBAAuB,YAAY,MAAM,YAAY,MAAM,KAAK;AAE1F,YAAI,CAAC,aAAa;AACd,iBAAO;QACX;AAEA,cAAM,QAAQ,oBAAoB,MAAM,aAAa,aAAa,KAAK;AAGvE,YAAI,YAAY,mBAAmB;AAC/B,gBAAM,qBAAqB,YAAY;QAC3C;AAEA,YAAI,YAAY,uBAAuB;AACnC,gBAAM,yBAAyB,YAAY;QAC/C;AAGA,YAAI,YAAY,aAAa,QAAW;AACpC,gBAAM,mBAAmB,YAAY;QACzC;AAEA,YAAI,YAAY,wBAAwB,QAAW;AAC/C,gBAAM,8BAA8B,YAAY;QACpD;AAGA,YAAI,YAAY,gBAAgB,QAAW;AACvC,gBAAM,cAAc,YAAY;QACpC;AAGA,YAAI,YAAY,iBAAiB,QAAW;AACxC,gBAAM,eAAe,YAAY;QACrC;AAGA,YAAI,YAAY,YAAY;AACxB,mBAAS,iBAAiB,GAAG,iBAAiB,YAAY,WAAW,QAAQ,kBAAkB;AAC3F,kBAAM,kBAAkB,YAAY,WAAW,cAAc;AAC7D,kBAAM,gBAAgB,SAAS,mBAAmB;AAClD,gBAAI,eAAe;AACf,oBAAM,WAAW,KAAK,cAAc,MAAM,eAAe,CAAC;YAC9D;UACJ;AACA,eAAK,qBAAqB,OAAO,aAAa,KAAK;QACvD;AAEA,YAAI,YAAY,aAAa;AACzB,gBAAM,eAAe,OAAO,YAAY,iBAAiB,YAAY,eAAe,YAAY,iBAAiB,YAAY,oBAAoB,CAAG;QACxJ;AAGA,YAAI,YAAY,cAAc,QAAW;AACrC,gBAAM,WAAW,YAAY,SAAS;QAC1C;AAEA,eAAO;MACX;MAEQ,sBAAsB,OAAqB;AAC/C,cAAM,UAAU,MAAM;AACtB,cAAM,OAAO,IAAI,UAAyB;AACtC,gBAAM,SAAS,QAAQ,MAAM,OAAO,KAAK;AAEzC,qBAAW,QAAQ,OAAO;AACtB,iBAAK,mBAAmB,IAAI;UAChC;AAEA,iBAAO;QACX;AAEA,cAAM,YAAY,MAAM;AACxB,cAAM,SAAS,CAAC,OAAe,gBAAwB;AACnD,gBAAM,UAAU,UAAU,MAAM,OAAO,CAAC,OAAO,WAAW,CAAC;AAE3D,qBAAW,QAAQ,SAAS;AACxB,iBAAK,mBAAmB,IAAI;UAChC;AAEA,iBAAO;QACX;AAEA,mBAAW,QAAQ,OAAO;AACtB,eAAK,mBAAmB,IAAI;QAChC;MACJ;MAEQ,0BAA0B,OAAqB;AACnD,cAAM,UAAU,MAAM;AACtB,cAAM,OAAO,IAAI,UAAyB;AACtC,gBAAM,SAAS,QAAQ,MAAM,OAAO,KAAK;AAEzC,eAAK,cAAa;AAElB,iBAAO;QACX;AAEA,cAAM,YAAY,MAAM;AACxB,cAAM,SAAS,CAAC,OAAe,gBAAwB;AACnD,gBAAM,UAAU,UAAU,MAAM,OAAO,CAAC,OAAO,WAAW,CAAC;AAE3D,eAAK,cAAa;AAElB,iBAAO;QACX;AAEA,aAAK,cAAa;MACtB;MAEQ,gBAAa;AACjB,mBAAW,QAAQ,KAAK,SAAQ,EAAG,QAAQ;AACvC,eAAK,mBAAmB,IAAI;QAChC;MACJ;;;;;MAMO,0BAAuB;AAC1B,mBAAW,QAAQ,KAAK,SAAQ,EAAG,QAAQ;AACvC,cAAI,KAAK,aAAa,QAAQ,IAAI,MAAM,IAAI;AACxC,iBAAK,2BAA0B;UACnC;QACJ;MACJ;;;;MAKQ,2BAAwB;AAC5B,aAAK,oBAAoB,KAAK,qBAAoB;AAClD,aAAK,SAAQ,EAAG,oBAAmB;MACvC;;;;MAKQ,uBAAoB;AACxB,YAAI,mBAAmB;AACvB,cAAM,cAAc,KAAK,UAAS;AAGlC,YAAI,kBAAkB,KAAK;AAC3B,YAAI,oBAAoB,OAAM,yBAAyB;AACnD,cAAI,gBAAgB,OAAM,8BAA8B;AACpD,8BAAkB,OAAM;UAC5B,OAAO;AACH,8BAAkB,OAAM;UAC5B;QACJ;AAGA,gBAAQ,aAAa;UACjB,KAAK,OAAM;UACX,KAAK,OAAM;AACP,oBAAQ,iBAAiB;cACrB,KAAK,OAAM;AACP,mCAAmB,KAAO,IAAM,KAAK;AACrC;cACJ,KAAK,OAAM;AACP,mCAAmB;AACnB;cACJ,KAAK,OAAM;AACP,mCAAmB,KAAK,SAAS,KAAK;AACtC;YACR;AACA;UAEJ,KAAK,OAAM;AACP,oBAAQ,iBAAiB;cACrB,KAAK,OAAM;AACP,mCAAmB;AACnB;cACJ,KAAK,OAAM,yBAAyB;AAGhC,oBAAI,mBAAmB,KAAK;AAE5B,mCAAmB,KAAK,IAAI,kBAAkB,IAAK;AACnD,sBAAM,aAAa,IAAM,KAAK,MAAM,IAAM,KAAK,IAAI,gBAAgB;AACnE,mCAAmB;AACnB;cACJ;YACJ;AACA;UAEJ,KAAK,OAAM;AAEP,+BAAmB;AACnB;QACR;AACA,eAAO;MACX;;;;;MAMO,wBAAqB;AACxB,cAAM,QAAQ,KAAK,SAAQ;AAC3B,YAAI,KAAK,mBAAmB,GAAG;AAC3B,gBAAM,sBAAsB;QAChC;AACA,aAAK,SAAQ,EAAG,qBAAoB;MACxC;;;;MAYO,WAAQ;AACX,eAAO;MACX;;AA94BuB,UAAA,kBAAkB,eAAe;AAKjC,UAAA,mBAAmB,eAAe;AAMlC,UAAA,eAAe,eAAe;AAM9B,UAAA,mBAAmB,eAAe;AASlC,UAAA,mBAAmB,eAAe;AAMlC,UAAA,oBAAoB,eAAe;AAMnC,UAAA,uBAAuB,eAAe;AAQtC,UAAA,0BAA0B,eAAe;AAIzC,UAAA,8BAA8B,eAAe;AAI7C,UAAA,kCAAkC,eAAe;AAIjD,UAAA,4BAA4B,eAAe;AAI3C,UAAA,0BAA0B,eAAe;AAMzC,UAAA,yBAAyB,eAAe;AAIxC,UAAA,+BAA+B,eAAe;AAI9C,UAAA,wBAAwB,eAAe;AAIvC,UAAA,+BAA+B,eAAe;AAK9C,UAAA,6BAA6B,eAAe;AAM5D,eAAA;MADN,kBAAiB;;AAQX,eAAA;MADN,kBAAiB;;AAYX,eAAA;MADN,UAAS;;AASH,eAAA;MADN,UAAS;;AAWV,eAAA;MADC,UAAS;;AAyBV,eAAA;MADC,UAAS;;AAkBV,eAAA;MADC,UAAS;;AAaF,eAAA;MADP,UAAS;;AAOH,eAAA;MADN,iBAAiB,uBAAuB;;AAIjC,eAAA;MADP,UAAU,eAAe;;AAqDlB,eAAA;MADP,UAAU,sBAAsB;;AAmBzB,eAAA;MADP,UAAU,0BAA0B;;AAmB7B,eAAA;MADP,UAAU,cAAc;;;;",
  "names": []
}
