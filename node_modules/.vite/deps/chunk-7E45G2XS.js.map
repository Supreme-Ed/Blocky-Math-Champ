{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/Animation/flowGraphInterpolationBlock.ts"],
  "sourcesContent": ["import type { EasingFunction } from \"core/Animations/easing\";\nimport { Constants } from \"core/Engines/constants\";\nimport { FlowGraphBlock, type IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport type { FlowGraphTypes } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { getRichTypeByAnimationType, getRichTypeByFlowGraphType, RichTypeAny, RichTypeNumber } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { Animation } from \"core/Animations/animation\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\n\n/**\n * Configuration for the interpolation block.\n */\nexport interface IFlowGraphInterpolationBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The number of keyframes to interpolate between.\n     * Will default to 1 if not provided (i.e. from currentValue to a provided value in the time provided)\n     */\n    keyFramesCount?: number;\n\n    /**\n     * The duration of the interpolation.\n     */\n    duration?: number;\n\n    /**\n     * The name of the property that will be interpolated.\n     */\n    propertyName?: string | string[];\n\n    /**\n     * The type of the animation to create.\n     * Default is ANIMATIONTYPE_FLOAT\n     * This cannot be changed after construction, so make sure to pass the right value.\n     */\n    animationType?: number | FlowGraphTypes;\n}\n\n/**\n * This block is responsible for interpolating between two values.\n * The babylon concept used is Animation, and it is the output of this block.\n *\n * Note that values will be parsed when the in connection is triggered. until then changing the value will not trigger a new interpolation.\n *\n * Internally this block uses the Animation class.\n *\n * Note that if the interpolation is already running a signal will be sent to stop the animation group running it.\n */\nexport class FlowGraphInterpolationBlock<T> extends FlowGraphBlock {\n    /**\n     * Input connection: The value to interpolate from.\n     * Optional. If not provided, the current value will be used.\n     * Note that if provided, every time the animation is created this value will be used!\n     */\n    public readonly initialValue: FlowGraphDataConnection<T>;\n\n    /**\n     * Input connection: The value to interpolate to.\n     * Optional. This can also be set using the KeyFrames input!\n     * If provided it will be set to the last keyframe value.\n     */\n    public readonly endValue: FlowGraphDataConnection<T>;\n\n    /**\n     * output connection: The animation that will be created when in is triggered.\n     */\n    public readonly animation: FlowGraphDataConnection<Animation | Animation[]>;\n\n    /**\n     * Input connection: An optional easing function to use for the interpolation.\n     */\n    public readonly easingFunction: FlowGraphDataConnection<EasingFunction>;\n\n    /**\n     * Input connection: The name of the property that will be set\n     */\n    public readonly propertyName: FlowGraphDataConnection<string | string[]>;\n\n    /**\n     * If provided, this function will be used to create the animation object(s).\n     */\n    public readonly customBuildAnimation: FlowGraphDataConnection<\n        (target: any, propertname: any, context: FlowGraphContext) => (keys: any[], fps: number, animationType: number, easingFunction?: EasingFunction) => Animation | Animation[]\n    >;\n\n    /**\n     * The keyframes to interpolate between.\n     * Each keyframe has a duration input and a value input.\n     */\n    public readonly keyFrames: {\n        duration: FlowGraphDataConnection<number>;\n        value: FlowGraphDataConnection<T>;\n    }[] = [];\n\n    constructor(config: IFlowGraphInterpolationBlockConfiguration = {}) {\n        super(config);\n        const type =\n            typeof config?.animationType === \"string\"\n                ? getRichTypeByFlowGraphType(config.animationType)\n                : getRichTypeByAnimationType(config?.animationType ?? Constants.ANIMATIONTYPE_FLOAT);\n\n        const numberOfKeyFrames = config?.keyFramesCount ?? 1;\n        const duration = this.registerDataInput(`duration_0`, RichTypeNumber, 0);\n        const value = this.registerDataInput(`value_0`, type);\n        this.keyFrames.push({ duration, value });\n        for (let i = 1; i < numberOfKeyFrames + 1; i++) {\n            const duration = this.registerDataInput(`duration_${i}`, RichTypeNumber, i === numberOfKeyFrames ? config.duration : undefined);\n            const value = this.registerDataInput(`value_${i}`, type);\n            this.keyFrames.push({ duration, value });\n        }\n        this.initialValue = this.keyFrames[0].value;\n        this.endValue = this.keyFrames[numberOfKeyFrames].value;\n        this.easingFunction = this.registerDataInput(\"easingFunction\", RichTypeAny);\n        this.animation = this.registerDataOutput(\"animation\", RichTypeAny);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config?.propertyName);\n        this.customBuildAnimation = this.registerDataInput(\"customBuildAnimation\", RichTypeAny);\n    }\n\n    public override _updateOutputs(context: FlowGraphContext): void {\n        const interpolationAnimations = context._getGlobalContextVariable(\"interpolationAnimations\", []) as number[];\n        const propertyName = this.propertyName.getValue(context);\n        const easingFunction = this.easingFunction.getValue(context);\n        const animation = this._createAnimation(context, propertyName, easingFunction);\n        // If an old animation exists, it will be ignored here.\n        // This is because if the animation is running and they both have the same target, the old will be stopped.\n        // This doesn't happen here, it happens in the play animation block.\n        this.animation.setValue(animation, context);\n        // to make sure no 2 interpolations are running on the same target, we will mark the animation in the context\n        if (Array.isArray(animation)) {\n            for (const anim of animation) {\n                interpolationAnimations.push(anim.uniqueId);\n            }\n        } else {\n            interpolationAnimations.push(animation.uniqueId);\n        }\n        context._setGlobalContextVariable(\"interpolationAnimations\", interpolationAnimations);\n    }\n\n    private _createAnimation(context: FlowGraphContext, propertyName: string | string[], easingFunction: EasingFunction): Animation | Animation[] {\n        const type = this.initialValue.richType;\n        const keys: { frame: number; value: T }[] = [];\n        // add initial value\n        const currentValue = this.initialValue.getValue(context) || type.defaultValue;\n        keys.push({ frame: 0, value: currentValue });\n        const numberOfKeyFrames = this.config?.numberOfKeyFrames ?? 1;\n        for (let i = 1; i < numberOfKeyFrames + 1; i++) {\n            const duration = this.keyFrames[i].duration?.getValue(context);\n            let value = this.keyFrames[i].value?.getValue(context);\n            if (i === numberOfKeyFrames - 1) {\n                value = value || type.defaultValue;\n            }\n            if (duration !== undefined && value) {\n                // convert duration to frames, based on 60 fps\n                keys.push({ frame: duration * 60, value });\n            }\n        }\n        const customBuildAnimation = this.customBuildAnimation.getValue(context);\n        if (customBuildAnimation) {\n            return customBuildAnimation(null, null, context)(keys, 60, type.animationType, easingFunction);\n        }\n        if (typeof propertyName === \"string\") {\n            const animation = Animation.CreateAnimation(propertyName, type.animationType, 60, easingFunction);\n            animation.setKeys(keys);\n            return [animation];\n        } else {\n            const animations = propertyName.map((name) => {\n                const animation = Animation.CreateAnimation(name, type.animationType, 60, easingFunction);\n                animation.setKeys(keys);\n                return animation;\n            });\n            return animations;\n        }\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.ValueInterpolation;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.ValueInterpolation, FlowGraphInterpolationBlock);\n\n// #L54P2C\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;AACA,IAgDa;AAhDb;;AACA;AAIA;AACA;AACA;AAyCM,IAAO,8BAAP,cAA8C,eAAc;MA8C9D,YAAY,SAAoD,CAAA,GAAE;AAC9D,cAAM,MAAM;AANA,aAAA,YAGV,CAAA;AAIF,cAAM,OACF,QAAO,iCAAQ,mBAAkB,WAC3B,2BAA2B,OAAO,aAAa,IAC/C,4BAA2B,iCAAQ,kBAAiB,CAAA;AAE9D,cAAM,qBAAoB,iCAAQ,mBAAkB;AACpD,cAAM,WAAW,KAAK,kBAAkB,cAAc,gBAAgB,CAAC;AACvE,cAAM,QAAQ,KAAK,kBAAkB,WAAW,IAAI;AACpD,aAAK,UAAU,KAAK,EAAE,UAAU,MAAK,CAAE;AACvC,iBAAS,IAAI,GAAG,IAAI,oBAAoB,GAAG,KAAK;AAC5C,gBAAMA,YAAW,KAAK,kBAAkB,YAAY,CAAC,IAAI,gBAAgB,MAAM,oBAAoB,OAAO,WAAW,MAAS;AAC9H,gBAAMC,SAAQ,KAAK,kBAAkB,SAAS,CAAC,IAAI,IAAI;AACvD,eAAK,UAAU,KAAK,EAAE,UAAAD,WAAU,OAAAC,OAAK,CAAE;QAC3C;AACA,aAAK,eAAe,KAAK,UAAU,CAAC,EAAE;AACtC,aAAK,WAAW,KAAK,UAAU,iBAAiB,EAAE;AAClD,aAAK,iBAAiB,KAAK,kBAAkB,kBAAkB,WAAW;AAC1E,aAAK,YAAY,KAAK,mBAAmB,aAAa,WAAW;AACjE,aAAK,eAAe,KAAK,kBAAkB,gBAAgB,aAAa,iCAAQ,YAAY;AAC5F,aAAK,uBAAuB,KAAK,kBAAkB,wBAAwB,WAAW;MAC1F;MAEgB,eAAe,SAAyB;AACpD,cAAM,0BAA0B,QAAQ,0BAA0B,2BAA2B,CAAA,CAAE;AAC/F,cAAM,eAAe,KAAK,aAAa,SAAS,OAAO;AACvD,cAAM,iBAAiB,KAAK,eAAe,SAAS,OAAO;AAC3D,cAAM,YAAY,KAAK,iBAAiB,SAAS,cAAc,cAAc;AAI7E,aAAK,UAAU,SAAS,WAAW,OAAO;AAE1C,YAAI,MAAM,QAAQ,SAAS,GAAG;AAC1B,qBAAW,QAAQ,WAAW;AAC1B,oCAAwB,KAAK,KAAK,QAAQ;UAC9C;QACJ,OAAO;AACH,kCAAwB,KAAK,UAAU,QAAQ;QACnD;AACA,gBAAQ,0BAA0B,2BAA2B,uBAAuB;MACxF;MAEQ,iBAAiB,SAA2B,cAAiC,gBAA8B;AA1IvH;AA2IQ,cAAM,OAAO,KAAK,aAAa;AAC/B,cAAM,OAAsC,CAAA;AAE5C,cAAM,eAAe,KAAK,aAAa,SAAS,OAAO,KAAK,KAAK;AACjE,aAAK,KAAK,EAAE,OAAO,GAAG,OAAO,aAAY,CAAE;AAC3C,cAAM,sBAAoB,UAAK,WAAL,mBAAa,sBAAqB;AAC5D,iBAAS,IAAI,GAAG,IAAI,oBAAoB,GAAG,KAAK;AAC5C,gBAAM,YAAW,UAAK,UAAU,CAAC,EAAE,aAAlB,mBAA4B,SAAS;AACtD,cAAI,SAAQ,UAAK,UAAU,CAAC,EAAE,UAAlB,mBAAyB,SAAS;AAC9C,cAAI,MAAM,oBAAoB,GAAG;AAC7B,oBAAQ,SAAS,KAAK;UAC1B;AACA,cAAI,aAAa,UAAa,OAAO;AAEjC,iBAAK,KAAK,EAAE,OAAO,WAAW,IAAI,MAAK,CAAE;UAC7C;QACJ;AACA,cAAM,uBAAuB,KAAK,qBAAqB,SAAS,OAAO;AACvE,YAAI,sBAAsB;AACtB,iBAAO,qBAAqB,MAAM,MAAM,OAAO,EAAE,MAAM,IAAI,KAAK,eAAe,cAAc;QACjG;AACA,YAAI,OAAO,iBAAiB,UAAU;AAClC,gBAAM,YAAY,UAAU,gBAAgB,cAAc,KAAK,eAAe,IAAI,cAAc;AAChG,oBAAU,QAAQ,IAAI;AACtB,iBAAO,CAAC,SAAS;QACrB,OAAO;AACH,gBAAM,aAAa,aAAa,IAAI,CAAC,SAAQ;AACzC,kBAAM,YAAY,UAAU,gBAAgB,MAAM,KAAK,eAAe,IAAI,cAAc;AACxF,sBAAU,QAAQ,IAAI;AACtB,mBAAO;UACX,CAAC;AACD,iBAAO;QACX;MACJ;MAEgB,eAAY;AACxB,eAAA;MACJ;;AAGJ,kBAAa,+BAAyC,2BAA2B;;;",
  "names": ["duration", "value"]
}
