import {
  init_helperFunctions
} from "./chunk-JUBEOR2P.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-IU6YKOYY.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/Shaders/iblCdfy.fragment.js
var name, shader, iblCdfyPixelShader;
var init_iblCdfy_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/iblCdfy.fragment.js"() {
    init_shaderStore();
    init_helperFunctions();
    name = "iblCdfyPixelShader";
    shader = `precision highp sampler2D;precision highp samplerCube;
#include<helperFunctions>
#define PI 3.1415927
varying vec2 vUV;
#ifdef IBL_USE_CUBE_MAP
uniform samplerCube iblSource;
#else
uniform sampler2D iblSource;
#endif
uniform int iblHeight;
#ifdef IBL_USE_CUBE_MAP
float fetchCube(vec2 uv) {vec3 direction=equirectangularToCubemapDirection(uv);return sin(PI*uv.y)*dot(textureCubeLodEXT(iblSource,direction,0.0).rgb,LuminanceEncodeApprox);}
#else
float fetchPanoramic(ivec2 Coords,float envmapHeight) {return sin(PI*(float(Coords.y)+0.5)/envmapHeight) *
dot(texelFetch(iblSource,Coords,0).rgb,LuminanceEncodeApprox);}
#endif
void main(void) {ivec2 coords=ivec2(gl_FragCoord.x,gl_FragCoord.y);float cdfy=0.0;for (int y=1; y<=coords.y; y++) {
#ifdef IBL_USE_CUBE_MAP
vec2 uv=vec2(vUV.x,(float(y-1)+0.5)/float(iblHeight));cdfy+=fetchCube(uv);
#else
cdfy+=fetchPanoramic(ivec2(coords.x,y-1),float(iblHeight));
#endif
}
gl_FragColor=vec4(cdfy,0.0,0.0,1.0);}`;
    if (!ShaderStore.ShadersStore[name]) {
      ShaderStore.ShadersStore[name] = shader;
    }
    iblCdfyPixelShader = { name, shader };
  }
});

export {
  iblCdfyPixelShader,
  init_iblCdfy_fragment
};
//# sourceMappingURL=chunk-U3LGWWVT.js.map
