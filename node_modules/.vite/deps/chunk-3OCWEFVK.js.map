{
  "version": 3,
  "sources": ["../../../dev/core/src/Loading/Plugins/babylonFileParser.function.ts"],
  "sourcesContent": ["import type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Stores the list of available parsers in the application.\r\n */\r\nconst _BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n/**\r\n * Stores the list of available individual parsers in the application.\r\n */\r\nconst _IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n/**\r\n * Adds a parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddParser(name: string, parser: BabylonFileParser): void {\r\n    _BabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets a general parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetParser(name: string): Nullable<BabylonFileParser> {\r\n    if (_BabylonFileParsers[name]) {\r\n        return _BabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Adds n individual parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n    _IndividualBabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets an individual parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n    if (_IndividualBabylonFileParsers[name]) {\r\n        return _IndividualBabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Parser json data and populate both a scene and its associated container object\r\n * @param jsonData Defines the data to parse\r\n * @param scene Defines the scene to parse the data for\r\n * @param container Defines the container attached to the parsing sequence\r\n * @param rootUrl Defines the root url of the data\r\n */\r\nexport function Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n    for (const parserName in _BabylonFileParsers) {\r\n        if (Object.prototype.hasOwnProperty.call(_BabylonFileParsers, parserName)) {\r\n            _BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;AA+BM,SAAU,UAAU,MAAc,QAAyB;AAC7D,sBAAoB,IAAI,IAAI;AAChC;AAOM,SAAU,UAAU,MAAY;AAClC,MAAI,oBAAoB,IAAI,GAAG;AAC3B,WAAO,oBAAoB,IAAI;EACnC;AAEA,SAAO;AACX;AAOM,SAAU,oBAAoB,MAAc,QAAmC;AACjF,gCAA8B,IAAI,IAAI;AAC1C;AAOM,SAAU,oBAAoB,MAAY;AAC5C,MAAI,8BAA8B,IAAI,GAAG;AACrC,WAAO,8BAA8B,IAAI;EAC7C;AAEA,SAAO;AACX;AASM,SAAU,MAAM,UAAe,OAAc,WAA2B,SAAe;AACzF,aAAW,cAAc,qBAAqB;AAC1C,QAAI,OAAO,UAAU,eAAe,KAAK,qBAAqB,UAAU,GAAG;AACvE,0BAAoB,UAAU,EAAE,UAAU,OAAO,WAAW,OAAO;IACvE;EACJ;AACJ;AAnEA,IAGM,qBAKA;AARN;;AAGA,IAAM,sBAA4D,CAAA;AAKlE,IAAM,gCAAgF,CAAA;;;",
  "names": []
}
