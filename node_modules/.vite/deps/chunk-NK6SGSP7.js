import {
  FlowGraphExecutionBlockWithOutSignal,
  init_flowGraphExecutionBlockWithOutSignal
} from "./chunk-AZ5WND6M.js";
import {
  RichTypeAny,
  init_flowGraphRichTypes
} from "./chunk-I4L6YYX4.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-D6A73UHJ.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/flowGraphSetVariableBlock.js
var FlowGraphSetVariableBlock;
var init_flowGraphSetVariableBlock = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/flowGraphSetVariableBlock.js"() {
    init_typeStore();
    init_flowGraphExecutionBlockWithOutSignal();
    init_flowGraphRichTypes();
    FlowGraphSetVariableBlock = class extends FlowGraphExecutionBlockWithOutSignal {
      constructor(config) {
        super(config);
        if (!config.variable && !config.variables) {
          throw new Error("FlowGraphSetVariableBlock: variable/variables is not defined");
        }
        if (config.variables && config.variable) {
          throw new Error("FlowGraphSetVariableBlock: variable and variables are both defined");
        }
        if (config.variables) {
          for (const variable of config.variables) {
            this.registerDataInput(variable, RichTypeAny);
          }
        } else {
          this.registerDataInput("value", RichTypeAny);
        }
      }
      _execute(context, _callingSignal) {
        var _a, _b;
        if ((_a = this.config) == null ? void 0 : _a.variables) {
          for (const variable of this.config.variables) {
            this._saveVariable(context, variable);
          }
        } else {
          this._saveVariable(context, (_b = this.config) == null ? void 0 : _b.variable, "value");
        }
        this.out._activateSignal(context);
      }
      _saveVariable(context, variableName, inputName) {
        var _a;
        const currentlyRunningAnimationGroups = context._getGlobalContextVariable("currentlyRunningAnimationGroups", []);
        for (const animationUniqueId of currentlyRunningAnimationGroups) {
          const animation = context.assetsContext.animationGroups[animationUniqueId];
          for (const targetAnimation of animation.targetedAnimations) {
            if (targetAnimation.target === context) {
              if (targetAnimation.target === context) {
                if (targetAnimation.animation.targetProperty === variableName) {
                  animation.stop();
                  const index = currentlyRunningAnimationGroups.indexOf(animationUniqueId);
                  if (index > -1) {
                    currentlyRunningAnimationGroups.splice(index, 1);
                  }
                  context._setGlobalContextVariable("currentlyRunningAnimationGroups", currentlyRunningAnimationGroups);
                  break;
                }
              }
            }
          }
        }
        const value = (_a = this.getDataInput(inputName || variableName)) == null ? void 0 : _a.getValue(context);
        context.setVariable(variableName, value);
      }
      getClassName() {
        return "FlowGraphSetVariableBlock";
      }
      serialize(serializationObject) {
        var _a;
        super.serialize(serializationObject);
        serializationObject.config.variable = (_a = this.config) == null ? void 0 : _a.variable;
      }
    };
    RegisterClass("FlowGraphSetVariableBlock", FlowGraphSetVariableBlock);
  }
});

export {
  FlowGraphSetVariableBlock,
  init_flowGraphSetVariableBlock
};
//# sourceMappingURL=chunk-NK6SGSP7.js.map
