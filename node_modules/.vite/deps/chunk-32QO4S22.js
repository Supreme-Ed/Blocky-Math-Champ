import {
  MaterialDefines,
  MaterialFlags,
  PushMaterial,
  init_materialDefines,
  init_materialFlags,
  init_pushMaterial
} from "./chunk-XUMTXD4I.js";
import {
  ImageProcessingConfiguration,
  init_imageProcessingConfiguration
} from "./chunk-MWHX2QIB.js";
import {
  EffectFallbacks,
  init_effectFallbacks
} from "./chunk-MTXAMDYK.js";
import {
  Texture,
  init_texture
} from "./chunk-OM2XJLAR.js";
import {
  BindBonesParameters,
  BindFogParameters,
  BindLights,
  BindLogDepth,
  BindTextureMatrix,
  HandleFallbacksForShadows,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForLights,
  PrepareDefinesForMergedUV,
  PrepareDefinesForMisc,
  PrepareDefinesForMultiview,
  PrepareUniformsAndSamplersList,
  addClipPlaneUniforms,
  bindClipPlane,
  init_clipPlaneMaterialHelper,
  init_materialHelper_functions
} from "./chunk-LIM4KBOY.js";
import {
  VertexBuffer,
  init_buffer
} from "./chunk-V4TBJFFE.js";
import {
  SmartArray,
  init_smartArray
} from "./chunk-KLV56W3Y.js";
import {
  SerializationHelper,
  init_decorators_serialization
} from "./chunk-5WVONG5F.js";
import {
  __decorate,
  expandToProperty,
  init_decorators,
  init_tslib_es6,
  serialize,
  serializeAsColor3,
  serializeAsImageProcessingConfiguration,
  serializeAsTexture,
  serializeAsVector3
} from "./chunk-IZLWPSPC.js";
import {
  Vector3,
  Vector4,
  init_math_vector
} from "./chunk-3KKXJTKL.js";
import {
  Logger,
  init_logger
} from "./chunk-CLHHKTPI.js";
import {
  Color3,
  init_math_color
} from "./chunk-FBNFE7ZR.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-D6A73UHJ.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/Materials/Background/backgroundMaterial.js
var BackgroundMaterialDefines, BackgroundMaterial;
var init_backgroundMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/Background/backgroundMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_smartArray();
    init_logger();
    init_math_vector();
    init_buffer();
    init_materialDefines();
    init_pushMaterial();
    init_imageProcessingConfiguration();
    init_texture();
    init_typeStore();
    init_materialFlags();
    init_math_color();
    init_effectFallbacks();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_decorators_serialization();
    BackgroundMaterialDefines = class extends MaterialDefines {
      /**
       * Constructor of the defines.
       */
      constructor() {
        super();
        this.DIFFUSE = false;
        this.DIFFUSEDIRECTUV = 0;
        this.GAMMADIFFUSE = false;
        this.DIFFUSEHASALPHA = false;
        this.OPACITYFRESNEL = false;
        this.REFLECTIONBLUR = false;
        this.REFLECTIONFRESNEL = false;
        this.REFLECTIONFALLOFF = false;
        this.TEXTURELODSUPPORT = false;
        this.PREMULTIPLYALPHA = false;
        this.USERGBCOLOR = false;
        this.USEHIGHLIGHTANDSHADOWCOLORS = false;
        this.BACKMAT_SHADOWONLY = false;
        this.NOISE = false;
        this.REFLECTIONBGR = false;
        this.PROJECTED_GROUND = false;
        this.IMAGEPROCESSING = false;
        this.VIGNETTE = false;
        this.VIGNETTEBLENDMODEMULTIPLY = false;
        this.VIGNETTEBLENDMODEOPAQUE = false;
        this.TONEMAPPING = 0;
        this.CONTRAST = false;
        this.COLORCURVES = false;
        this.COLORGRADING = false;
        this.COLORGRADING3D = false;
        this.SAMPLER3DGREENDEPTH = false;
        this.SAMPLER3DBGRMAP = false;
        this.DITHER = false;
        this.IMAGEPROCESSINGPOSTPROCESS = false;
        this.SKIPFINALCOLORCLAMP = false;
        this.EXPOSURE = false;
        this.MULTIVIEW = false;
        this.REFLECTION = false;
        this.REFLECTIONMAP_3D = false;
        this.REFLECTIONMAP_SPHERICAL = false;
        this.REFLECTIONMAP_PLANAR = false;
        this.REFLECTIONMAP_CUBIC = false;
        this.REFLECTIONMAP_PROJECTION = false;
        this.REFLECTIONMAP_SKYBOX = false;
        this.REFLECTIONMAP_EXPLICIT = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        this.INVERTCUBICMAP = false;
        this.REFLECTIONMAP_OPPOSITEZ = false;
        this.LODINREFLECTIONALPHA = false;
        this.GAMMAREFLECTION = false;
        this.RGBDREFLECTION = false;
        this.EQUIRECTANGULAR_RELFECTION_FOV = false;
        this.MAINUV1 = false;
        this.MAINUV2 = false;
        this.UV1 = false;
        this.UV2 = false;
        this.CLIPPLANE = false;
        this.CLIPPLANE2 = false;
        this.CLIPPLANE3 = false;
        this.CLIPPLANE4 = false;
        this.CLIPPLANE5 = false;
        this.CLIPPLANE6 = false;
        this.POINTSIZE = false;
        this.FOG = false;
        this.NORMAL = false;
        this.NUM_BONE_INFLUENCERS = 0;
        this.BonesPerMesh = 0;
        this.INSTANCES = false;
        this.SHADOWFLOAT = false;
        this.LOGARITHMICDEPTH = false;
        this.NONUNIFORMSCALING = false;
        this.ALPHATEST = false;
        this.rebuild();
      }
    };
    BackgroundMaterial = class _BackgroundMaterial extends PushMaterial {
      /**
       * Experimental Internal Use Only.
       *
       * Key light Color in "perceptual value" meaning the color you would like to see on screen.
       * This acts as a helper to set the primary color to a more "human friendly" value.
       * Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the
       * output color as close as possible from the chosen value.
       * (This does not account for contrast color grading and color curves as they are considered post effect and not directly
       * part of lighting setup.)
       */
      get _perceptualColor() {
        return this.__perceptualColor;
      }
      set _perceptualColor(value) {
        this.__perceptualColor = value;
        this._computePrimaryColorFromPerceptualColor();
        this._markAllSubMeshesAsLightsDirty();
      }
      /**
       * Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.
       * The color opposite to the primary color is used at the level chosen to define what the black area would look.
       */
      get primaryColorShadowLevel() {
        return this._primaryColorShadowLevel;
      }
      set primaryColorShadowLevel(value) {
        this._primaryColorShadowLevel = value;
        this._computePrimaryColors();
        this._markAllSubMeshesAsLightsDirty();
      }
      /**
       * Defines the level of the highlights (highlight area of the reflection map) in order to help scaling the colors.
       * The primary color is used at the level chosen to define what the white area would look.
       */
      get primaryColorHighlightLevel() {
        return this._primaryColorHighlightLevel;
      }
      set primaryColorHighlightLevel(value) {
        this._primaryColorHighlightLevel = value;
        this._computePrimaryColors();
        this._markAllSubMeshesAsLightsDirty();
      }
      /**
       * Sets the reflection reflectance fresnel values according to the default standard
       * empirically know to work well :-)
       */
      set reflectionStandardFresnelWeight(value) {
        let reflectionWeight = value;
        if (reflectionWeight < 0.5) {
          reflectionWeight = reflectionWeight * 2;
          this.reflectionReflectance0 = _BackgroundMaterial.StandardReflectance0 * reflectionWeight;
          this.reflectionReflectance90 = _BackgroundMaterial.StandardReflectance90 * reflectionWeight;
        } else {
          reflectionWeight = reflectionWeight * 2 - 1;
          this.reflectionReflectance0 = _BackgroundMaterial.StandardReflectance0 + (1 - _BackgroundMaterial.StandardReflectance0) * reflectionWeight;
          this.reflectionReflectance90 = _BackgroundMaterial.StandardReflectance90 + (1 - _BackgroundMaterial.StandardReflectance90) * reflectionWeight;
        }
      }
      /**
       * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
       * Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.
       * Recommended to be keep at 1.0 except for special cases.
       */
      get fovMultiplier() {
        return this._fovMultiplier;
      }
      set fovMultiplier(value) {
        if (isNaN(value)) {
          value = 1;
        }
        this._fovMultiplier = Math.max(0, Math.min(2, value));
      }
      /**
       * Attaches a new image processing configuration to the PBR Material.
       * @param configuration (if null the scene configuration will be use)
       */
      _attachImageProcessingConfiguration(configuration) {
        if (configuration === this._imageProcessingConfiguration) {
          return;
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (!configuration) {
          this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
        } else {
          this._imageProcessingConfiguration = configuration;
        }
        if (this._imageProcessingConfiguration) {
          this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
            this._computePrimaryColorFromPerceptualColor();
            this._markAllSubMeshesAsImageProcessingDirty();
          });
        }
      }
      /**
       * Gets the image processing configuration used either in this material.
       */
      get imageProcessingConfiguration() {
        return this._imageProcessingConfiguration;
      }
      /**
       * Sets the Default image processing configuration used either in the this material.
       *
       * If sets to null, the scene one is in use.
       */
      set imageProcessingConfiguration(value) {
        this._attachImageProcessingConfiguration(value);
        this._markAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets whether the color curves effect is enabled.
       */
      get cameraColorCurvesEnabled() {
        return this.imageProcessingConfiguration.colorCurvesEnabled;
      }
      /**
       * Sets whether the color curves effect is enabled.
       */
      set cameraColorCurvesEnabled(value) {
        this.imageProcessingConfiguration.colorCurvesEnabled = value;
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      get cameraColorGradingEnabled() {
        return this.imageProcessingConfiguration.colorGradingEnabled;
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      set cameraColorGradingEnabled(value) {
        this.imageProcessingConfiguration.colorGradingEnabled = value;
      }
      /**
       * Gets whether tonemapping is enabled or not.
       */
      get cameraToneMappingEnabled() {
        return this._imageProcessingConfiguration.toneMappingEnabled;
      }
      /**
       * Sets whether tonemapping is enabled or not
       */
      set cameraToneMappingEnabled(value) {
        this._imageProcessingConfiguration.toneMappingEnabled = value;
      }
      /**
       * The camera exposure used on this material.
       * This property is here and not in the camera to allow controlling exposure without full screen post process.
       * This corresponds to a photographic exposure.
       */
      get cameraExposure() {
        return this._imageProcessingConfiguration.exposure;
      }
      /**
       * The camera exposure used on this material.
       * This property is here and not in the camera to allow controlling exposure without full screen post process.
       * This corresponds to a photographic exposure.
       */
      set cameraExposure(value) {
        this._imageProcessingConfiguration.exposure = value;
      }
      /**
       * Gets The camera contrast used on this material.
       */
      get cameraContrast() {
        return this._imageProcessingConfiguration.contrast;
      }
      /**
       * Sets The camera contrast used on this material.
       */
      set cameraContrast(value) {
        this._imageProcessingConfiguration.contrast = value;
      }
      /**
       * Gets the Color Grading 2D Lookup Texture.
       */
      get cameraColorGradingTexture() {
        return this._imageProcessingConfiguration.colorGradingTexture;
      }
      /**
       * Sets the Color Grading 2D Lookup Texture.
       */
      set cameraColorGradingTexture(value) {
        this.imageProcessingConfiguration.colorGradingTexture = value;
      }
      /**
       * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
       * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
       * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
       * corresponding to low luminance, medium luminance, and high luminance areas respectively.
       */
      get cameraColorCurves() {
        return this.imageProcessingConfiguration.colorCurves;
      }
      /**
       * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
       * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
       * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
       * corresponding to low luminance, medium luminance, and high luminance areas respectively.
       */
      set cameraColorCurves(value) {
        this.imageProcessingConfiguration.colorCurves = value;
      }
      /**
       * Instantiates a Background Material in the given scene
       * @param name The friendly name of the material
       * @param scene The scene to add the material to
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       */
      constructor(name, scene, forceGLSL = false) {
        super(name, scene, void 0, forceGLSL);
        this.primaryColor = Color3.White();
        this._primaryColorShadowLevel = 0;
        this._primaryColorHighlightLevel = 0;
        this.reflectionTexture = null;
        this.reflectionBlur = 0;
        this.diffuseTexture = null;
        this._shadowLights = null;
        this.shadowLights = null;
        this.shadowLevel = 0;
        this.sceneCenter = Vector3.Zero();
        this.opacityFresnel = true;
        this.reflectionFresnel = false;
        this.reflectionFalloffDistance = 0;
        this.reflectionAmount = 1;
        this.reflectionReflectance0 = 0.05;
        this.reflectionReflectance90 = 0.5;
        this.useRGBColor = true;
        this.enableNoise = false;
        this._fovMultiplier = 1;
        this.useEquirectangularFOV = false;
        this._maxSimultaneousLights = 4;
        this.maxSimultaneousLights = 4;
        this._shadowOnly = false;
        this.shadowOnly = false;
        this._imageProcessingObserver = null;
        this.switchToBGR = false;
        this._enableGroundProjection = false;
        this.enableGroundProjection = false;
        this.projectedGroundRadius = 1e3;
        this.projectedGroundHeight = 10;
        this._renderTargets = new SmartArray(16);
        this._reflectionControls = Vector4.Zero();
        this._white = Color3.White();
        this._primaryShadowColor = Color3.Black();
        this._primaryHighlightColor = Color3.Black();
        this._shadersLoaded = false;
        this._attachImageProcessingConfiguration(null);
        this.getRenderTargetTextures = () => {
          this._renderTargets.reset();
          if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
            this._renderTargets.push(this._diffuseTexture);
          }
          if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            this._renderTargets.push(this._reflectionTexture);
          }
          return this._renderTargets;
        };
      }
      /**
       * Gets a boolean indicating that current material needs to register RTT
       */
      get hasRenderTargetTextures() {
        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
          return true;
        }
        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
          return true;
        }
        return false;
      }
      /**
       * The entire material has been created in order to prevent overdraw.
       * @returns false
       */
      needAlphaTesting() {
        return true;
      }
      /**
       * The entire material has been created in order to prevent overdraw.
       * @returns true if blending is enable
       */
      needAlphaBlending() {
        return this.alpha < 1 || this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._shadowOnly;
      }
      /**
       * Checks whether the material is ready to be rendered for a given mesh.
       * @param mesh The mesh to render
       * @param subMesh The submesh to check against
       * @param useInstances Specify wether or not the material is used with instances
       * @returns true if all the dependencies are ready (Textures, Effects...)
       */
      isReadyForSubMesh(mesh, subMesh, useInstances = false) {
        const drawWrapper = subMesh._drawWrapper;
        if (drawWrapper.effect && this.isFrozen) {
          if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          subMesh.materialDefines = new BackgroundMaterialDefines();
        }
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        const engine = scene.getEngine();
        PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights);
        defines._needNormals = true;
        PrepareDefinesForMultiview(scene, defines);
        if (defines._areTexturesDirty) {
          defines._needUVs = false;
          if (scene.texturesEnabled) {
            if (scene.getEngine().getCaps().textureLOD) {
              defines.TEXTURELODSUPPORT = true;
            }
            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
              if (!this._diffuseTexture.isReadyOrNotBlocking()) {
                return false;
              }
              PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
              defines.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha;
              defines.GAMMADIFFUSE = this._diffuseTexture.gammaSpace;
              defines.OPACITYFRESNEL = this._opacityFresnel;
            } else {
              defines.DIFFUSE = false;
              defines.DIFFUSEDIRECTUV = 0;
              defines.DIFFUSEHASALPHA = false;
              defines.GAMMADIFFUSE = false;
              defines.OPACITYFRESNEL = false;
            }
            const reflectionTexture = this._reflectionTexture;
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!reflectionTexture.isReadyOrNotBlocking()) {
                return false;
              }
              defines.REFLECTION = true;
              defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
              defines.RGBDREFLECTION = reflectionTexture.isRGBD;
              defines.REFLECTIONBLUR = this._reflectionBlur > 0;
              defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
              defines.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV;
              defines.REFLECTIONBGR = this.switchToBGR;
              if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {
                defines.INVERTCUBICMAP = true;
              }
              defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
              defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
              switch (reflectionTexture.coordinatesMode) {
                case Texture.EXPLICIT_MODE:
                  defines.REFLECTIONMAP_EXPLICIT = true;
                  break;
                case Texture.PLANAR_MODE:
                  defines.REFLECTIONMAP_PLANAR = true;
                  break;
                case Texture.PROJECTION_MODE:
                  defines.REFLECTIONMAP_PROJECTION = true;
                  break;
                case Texture.SKYBOX_MODE:
                  defines.REFLECTIONMAP_SKYBOX = true;
                  break;
                case Texture.SPHERICAL_MODE:
                  defines.REFLECTIONMAP_SPHERICAL = true;
                  break;
                case Texture.EQUIRECTANGULAR_MODE:
                  defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
                  break;
                case Texture.FIXED_EQUIRECTANGULAR_MODE:
                  defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
                  break;
                case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                  defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
                  break;
                case Texture.CUBIC_MODE:
                case Texture.INVCUBIC_MODE:
                default:
                  defines.REFLECTIONMAP_CUBIC = true;
                  break;
              }
              if (this.reflectionFresnel) {
                defines.REFLECTIONFRESNEL = true;
                defines.REFLECTIONFALLOFF = this.reflectionFalloffDistance > 0;
                this._reflectionControls.x = this.reflectionAmount;
                this._reflectionControls.y = this.reflectionReflectance0;
                this._reflectionControls.z = this.reflectionReflectance90;
                this._reflectionControls.w = 1 / this.reflectionFalloffDistance;
              } else {
                defines.REFLECTIONFRESNEL = false;
                defines.REFLECTIONFALLOFF = false;
              }
            } else {
              defines.REFLECTION = false;
              defines.REFLECTIONFRESNEL = false;
              defines.REFLECTIONFALLOFF = false;
              defines.REFLECTIONBLUR = false;
              defines.REFLECTIONMAP_3D = false;
              defines.REFLECTIONMAP_SPHERICAL = false;
              defines.REFLECTIONMAP_PLANAR = false;
              defines.REFLECTIONMAP_CUBIC = false;
              defines.REFLECTIONMAP_PROJECTION = false;
              defines.REFLECTIONMAP_SKYBOX = false;
              defines.REFLECTIONMAP_EXPLICIT = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
              defines.INVERTCUBICMAP = false;
              defines.REFLECTIONMAP_OPPOSITEZ = false;
              defines.LODINREFLECTIONALPHA = false;
              defines.GAMMAREFLECTION = false;
              defines.RGBDREFLECTION = false;
            }
          }
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.USERGBCOLOR = this._useRGBColor;
          defines.NOISE = this._enableNoise;
        }
        if (defines._areLightsDirty) {
          defines.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (this._primaryColorShadowLevel !== 0 || this._primaryColorHighlightLevel !== 0);
          defines.BACKMAT_SHADOWONLY = this._shadowOnly;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
          this._imageProcessingConfiguration.prepareDefines(defines);
        }
        if (defines._areMiscDirty) {
          if (defines.REFLECTIONMAP_3D && this._enableGroundProjection) {
            defines.PROJECTED_GROUND = true;
            defines.REFLECTIONMAP_SKYBOX = true;
          } else {
            defines.PROJECTED_GROUND = false;
          }
        }
        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);
        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
        if (PrepareDefinesForAttributes(mesh, defines, false, true, false)) {
          if (mesh) {
            if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
              mesh.createNormals(true);
              Logger.Warn("BackgroundMaterial: Normals have been created for the mesh: " + mesh.name);
            }
          }
        }
        if (defines.isDirty) {
          defines.markAsProcessed();
          scene.resetCachedMaterial();
          const fallbacks = new EffectFallbacks();
          if (defines.FOG) {
            fallbacks.addFallback(0, "FOG");
          }
          if (defines.POINTSIZE) {
            fallbacks.addFallback(1, "POINTSIZE");
          }
          if (defines.MULTIVIEW) {
            fallbacks.addFallback(0, "MULTIVIEW");
          }
          HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
          const attribs = [VertexBuffer.PositionKind];
          if (defines.NORMAL) {
            attribs.push(VertexBuffer.NormalKind);
          }
          if (defines.UV1) {
            attribs.push(VertexBuffer.UVKind);
          }
          if (defines.UV2) {
            attribs.push(VertexBuffer.UV2Kind);
          }
          PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
          PrepareAttributesForInstances(attribs, defines);
          const uniforms = [
            "world",
            "view",
            "viewProjection",
            "vEyePosition",
            "vLightsType",
            "vFogInfos",
            "vFogColor",
            "pointSize",
            "mBones",
            "vPrimaryColor",
            "vPrimaryColorShadow",
            "vReflectionInfos",
            "reflectionMatrix",
            "vReflectionMicrosurfaceInfos",
            "fFovMultiplier",
            "shadowLevel",
            "alpha",
            "vBackgroundCenter",
            "vReflectionControl",
            "vDiffuseInfos",
            "diffuseMatrix",
            "projectedGroundInfos",
            "logarithmicDepthConstant"
          ];
          addClipPlaneUniforms(uniforms);
          const samplers = ["diffuseSampler", "reflectionSampler", "reflectionSamplerLow", "reflectionSamplerHigh"];
          const uniformBuffers = ["Material", "Scene"];
          if (ImageProcessingConfiguration) {
            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
          }
          PrepareUniformsAndSamplersList({
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines,
            maxSimultaneousLights: this._maxSimultaneousLights
          });
          const join = defines.toString();
          const effect = scene.getEngine().createEffect("background", {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines: join,
            fallbacks,
            onCompiled: this.onCompiled,
            onError: this.onError,
            indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights },
            shaderLanguage: this._shaderLanguage,
            extraInitializationsAsync: this._shadersLoaded ? void 0 : async () => {
              if (this.shaderLanguage === 1) {
                await Promise.all([import("./background.vertex-WQQVQCJE.js"), import("./background.fragment-KBXT5VUA.js")]);
              } else {
                await Promise.all([import("./background.vertex-BQL4FLU2.js"), import("./background.fragment-C3E7EJTA.js")]);
              }
              this._shadersLoaded = true;
            }
          }, engine);
          subMesh.setEffect(effect, defines, this._materialContext);
          this.buildUniformLayout();
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        drawWrapper._wasPreviouslyReady = true;
        drawWrapper._wasPreviouslyUsingInstances = useInstances;
        this._checkScenePerformancePriority();
        return true;
      }
      /**
       * Compute the primary color according to the chosen perceptual color.
       */
      _computePrimaryColorFromPerceptualColor() {
        if (!this.__perceptualColor) {
          return;
        }
        this._primaryColor.copyFrom(this.__perceptualColor);
        this._primaryColor.toLinearSpaceToRef(this._primaryColor, this.getScene().getEngine().useExactSrgbConversions);
        if (this._imageProcessingConfiguration) {
          this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor);
        }
        this._computePrimaryColors();
      }
      /**
       * Compute the highlights and shadow colors according to their chosen levels.
       */
      _computePrimaryColors() {
        if (this._primaryColorShadowLevel === 0 && this._primaryColorHighlightLevel === 0) {
          return;
        }
        this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor);
        this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor);
        this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor);
        this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor);
        this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor);
      }
      /**
       * Build the uniform buffer used in the material.
       */
      buildUniformLayout() {
        this._uniformBuffer.addUniform("vPrimaryColor", 4);
        this._uniformBuffer.addUniform("vPrimaryColorShadow", 4);
        this._uniformBuffer.addUniform("vDiffuseInfos", 2);
        this._uniformBuffer.addUniform("vReflectionInfos", 2);
        this._uniformBuffer.addUniform("diffuseMatrix", 16);
        this._uniformBuffer.addUniform("reflectionMatrix", 16);
        this._uniformBuffer.addUniform("vReflectionMicrosurfaceInfos", 3);
        this._uniformBuffer.addUniform("fFovMultiplier", 1);
        this._uniformBuffer.addUniform("pointSize", 1);
        this._uniformBuffer.addUniform("shadowLevel", 1);
        this._uniformBuffer.addUniform("alpha", 1);
        this._uniformBuffer.addUniform("vBackgroundCenter", 3);
        this._uniformBuffer.addUniform("vReflectionControl", 4);
        this._uniformBuffer.addUniform("projectedGroundInfos", 2);
        this._uniformBuffer.create();
      }
      /**
       * Unbind the material.
       */
      unbind() {
        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {
          this._uniformBuffer.setTexture("diffuseSampler", null);
        }
        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
          this._uniformBuffer.setTexture("reflectionSampler", null);
        }
        super.unbind();
      }
      /**
       * Bind only the world matrix to the material.
       * @param world The world matrix to bind.
       */
      bindOnlyWorldMatrix(world) {
        this._activeEffect.setMatrix("world", world);
      }
      /**
       * Bind the material for a dedicated submesh (every used meshes will be considered opaque).
       * @param world The world matrix to bind.
       * @param mesh the mesh to bind for.
       * @param subMesh The submesh to bind for.
       */
      bindForSubMesh(world, mesh, subMesh) {
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        this.bindOnlyWorldMatrix(world);
        BindBonesParameters(mesh, this._activeEffect);
        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
        if (mustRebind) {
          this._uniformBuffer.bindToEffect(effect, "Material");
          this.bindViewProjection(effect);
          const reflectionTexture = this._reflectionTexture;
          if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
            if (scene.texturesEnabled) {
              if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
                this._uniformBuffer.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
                BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, "diffuse");
              }
              if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
                this._uniformBuffer.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
                this._uniformBuffer.updateFloat2("vReflectionInfos", reflectionTexture.level, this._reflectionBlur);
                this._uniformBuffer.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
              }
            }
            if (this.shadowLevel > 0) {
              this._uniformBuffer.updateFloat("shadowLevel", this.shadowLevel);
            }
            this._uniformBuffer.updateFloat("alpha", this.alpha);
            if (this.pointsCloud) {
              this._uniformBuffer.updateFloat("pointSize", this.pointSize);
            }
            if (defines.USEHIGHLIGHTANDSHADOWCOLORS) {
              this._uniformBuffer.updateColor4("vPrimaryColor", this._primaryHighlightColor, 1);
              this._uniformBuffer.updateColor4("vPrimaryColorShadow", this._primaryShadowColor, 1);
            } else {
              this._uniformBuffer.updateColor4("vPrimaryColor", this._primaryColor, 1);
            }
          }
          this._uniformBuffer.updateFloat("fFovMultiplier", this._fovMultiplier);
          if (scene.texturesEnabled) {
            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
              this._uniformBuffer.setTexture("diffuseSampler", this._diffuseTexture);
            }
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (defines.REFLECTIONBLUR && defines.TEXTURELODSUPPORT) {
                this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture);
              } else if (!defines.REFLECTIONBLUR) {
                this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture);
              } else {
                this._uniformBuffer.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
                this._uniformBuffer.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
                this._uniformBuffer.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
              }
              if (defines.REFLECTIONFRESNEL) {
                this._uniformBuffer.updateFloat3("vBackgroundCenter", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z);
                this._uniformBuffer.updateFloat4("vReflectionControl", this._reflectionControls.x, this._reflectionControls.y, this._reflectionControls.z, this._reflectionControls.w);
              }
            }
            if (defines.PROJECTED_GROUND) {
              this._uniformBuffer.updateFloat2("projectedGroundInfos", this.projectedGroundRadius, this.projectedGroundHeight);
            }
          }
          bindClipPlane(this._activeEffect, this, scene);
          scene.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._uniformBuffer.bindToEffect(effect, "Material");
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled) {
            BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
          }
          this.bindView(effect);
          BindFogParameters(scene, mesh, this._activeEffect, true);
          if (this._useLogarithmicDepth) {
            BindLogDepth(defines, effect, scene);
          }
          if (this._imageProcessingConfiguration) {
            this._imageProcessingConfiguration.bind(this._activeEffect);
          }
        }
        this._afterBind(mesh, this._activeEffect, subMesh);
        this._uniformBuffer.update();
      }
      /**
       * Checks to see if a texture is used in the material.
       * @param texture - Base texture to use.
       * @returns - Boolean specifying if a texture is used in the material.
       */
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        if (this._reflectionTexture === texture) {
          return true;
        }
        if (this._diffuseTexture === texture) {
          return true;
        }
        return false;
      }
      /**
       * Dispose the material.
       * @param forceDisposeEffect Force disposal of the associated effect.
       * @param forceDisposeTextures Force disposal of the associated textures.
       */
      dispose(forceDisposeEffect = false, forceDisposeTextures = false) {
        if (forceDisposeTextures) {
          if (this.diffuseTexture) {
            this.diffuseTexture.dispose();
          }
          if (this.reflectionTexture) {
            this.reflectionTexture.dispose();
          }
        }
        this._renderTargets.dispose();
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        super.dispose(forceDisposeEffect);
      }
      /**
       * Clones the material.
       * @param name The cloned name.
       * @returns The cloned material.
       */
      clone(name) {
        return SerializationHelper.Clone(() => new _BackgroundMaterial(name, this.getScene()), this);
      }
      /**
       * Serializes the current material to its JSON representation.
       * @returns The JSON representation.
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.customType = "BABYLON.BackgroundMaterial";
        return serializationObject;
      }
      /**
       * Gets the class name of the material
       * @returns "BackgroundMaterial"
       */
      getClassName() {
        return "BackgroundMaterial";
      }
      /**
       * Parse a JSON input to create back a background material.
       * @param source The JSON data to parse
       * @param scene The scene to create the parsed material in
       * @param rootUrl The root url of the assets the material depends upon
       * @returns the instantiated BackgroundMaterial.
       */
      static Parse(source, scene, rootUrl) {
        return SerializationHelper.Parse(() => new _BackgroundMaterial(source.name, scene), source, scene, rootUrl);
      }
    };
    BackgroundMaterial.StandardReflectance0 = 0.05;
    BackgroundMaterial.StandardReflectance90 = 0.5;
    __decorate([
      serializeAsColor3()
    ], BackgroundMaterial.prototype, "_primaryColor", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], BackgroundMaterial.prototype, "primaryColor", void 0);
    __decorate([
      serializeAsColor3()
    ], BackgroundMaterial.prototype, "__perceptualColor", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_primaryColorShadowLevel", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_primaryColorHighlightLevel", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], BackgroundMaterial.prototype, "primaryColorHighlightLevel", null);
    __decorate([
      serializeAsTexture()
    ], BackgroundMaterial.prototype, "_reflectionTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionTexture", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_reflectionBlur", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionBlur", void 0);
    __decorate([
      serializeAsTexture()
    ], BackgroundMaterial.prototype, "_diffuseTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "diffuseTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "shadowLights", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_shadowLevel", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "shadowLevel", void 0);
    __decorate([
      serializeAsVector3()
    ], BackgroundMaterial.prototype, "_sceneCenter", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "sceneCenter", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_opacityFresnel", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "opacityFresnel", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_reflectionFresnel", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionFresnel", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_reflectionFalloffDistance", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionFalloffDistance", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_reflectionAmount", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionAmount", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_reflectionReflectance0", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionReflectance0", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_reflectionReflectance90", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "reflectionReflectance90", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_useRGBColor", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "useRGBColor", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_enableNoise", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "enableNoise", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_maxSimultaneousLights", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], BackgroundMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "_shadowOnly", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], BackgroundMaterial.prototype, "shadowOnly", void 0);
    __decorate([
      serializeAsImageProcessingConfiguration()
    ], BackgroundMaterial.prototype, "_imageProcessingConfiguration", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], BackgroundMaterial.prototype, "enableGroundProjection", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "projectedGroundRadius", void 0);
    __decorate([
      serialize()
    ], BackgroundMaterial.prototype, "projectedGroundHeight", void 0);
    RegisterClass("BABYLON.BackgroundMaterial", BackgroundMaterial);
  }
});

export {
  BackgroundMaterial,
  init_backgroundMaterial
};
//# sourceMappingURL=chunk-32QO4S22.js.map
