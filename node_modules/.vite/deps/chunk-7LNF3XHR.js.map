{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts", "../../../dev/core/src/Materials/Textures/Procedurals/proceduralTexture.ts"],
  "sourcesContent": ["import { Tools } from \"../../../Misc/tools\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { ISceneComponent } from \"../../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector4, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../../../Engines/abstractEngine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { RenderTargetTextureOptions } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\n\r\n/**\r\n * Options to create a procedural texture\r\n */\r\nexport interface IProceduralTextureCreationOptions extends RenderTargetTextureOptions {\r\n    /**\r\n     * Defines a fallback texture in case there were issues to create the custom texture\r\n     */\r\n    fallbackTexture?: Nullable<Texture>;\r\n    /**\r\n     * The shader language of the shader. (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n    /**\r\n     * Additional async code to run before preparing the effect\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Define the list of custom preprocessor defines used in the shader\r\n     */\r\n    public defines: string = \"\";\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: ThinTexture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    /** @internal */\r\n    private _shaderLanguage: ShaderLanguage;\r\n\r\n    /**\r\n     * Gets the shader language type used to generate vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _vectors4: { [key: string]: Vector4 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: AbstractEngine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n    private _options: IProceduralTextureCreationOptions;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\r\n     *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\r\n     *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> | IProceduralTextureCreationOptions = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {\r\n            this._options = fallbackTexture;\r\n            this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;\r\n        } else {\r\n            this._options = {};\r\n            this._fallbackTexture = fallbackTexture;\r\n        }\r\n\r\n        this._shaderLanguage = this._options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            if (this._rtWrapper.is3D) {\r\n                this.setFloat(\"layer\", 0);\r\n                this.setInt(\"layerNum\", 0);\r\n            }\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n        this._drawWrapper.effect = null;\r\n        this._cachedDefines = null;\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return this.defines;\r\n    }\r\n\r\n    /**\r\n     * Executes a function when the texture will be ready to be drawn.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenReady(func: (texture: ProceduralTexture) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        const effect = this.getEffect();\r\n        if (effect) {\r\n            effect.executeWhenCompiled(() => {\r\n                func(this);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public override isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        const shaders = {\r\n            vertex: \"procedural\",\r\n            fragmentElement: this._fragment.fragmentElement,\r\n            fragmentSource: this._fragment.fragmentSource,\r\n            fragment: typeof this._fragment === \"string\" ? this._fragment : undefined,\r\n        };\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(\r\n                shaders,\r\n                [VertexBuffer.PositionKind],\r\n                this._uniforms,\r\n                this._samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                () => {\r\n                    this._rtWrapper?.dispose();\r\n                    this._rtWrapper = this._texture = null;\r\n\r\n                    if (this._fallbackTexture) {\r\n                        this._texture = this._fallbackTexture._texture;\r\n\r\n                        if (this._texture) {\r\n                            this._texture.incrementReferences();\r\n                        }\r\n                    }\r\n\r\n                    this._fallbackTextureUsed = true;\r\n                },\r\n                undefined,\r\n                this._shaderLanguage,\r\n                async () => {\r\n                    if (this._options.extraInitializationsAsync) {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../../ShadersWGSL/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../../Shaders/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        }\r\n                    } else {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await import(\"../../../ShadersWGSL/procedural.vertex\");\r\n                        } else {\r\n                            await import(\"../../../Shaders/procedural.vertex\");\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: ThinTexture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (const name in this._vectors4) {\r\n                this._drawWrapper.effect!.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, true);\r\n            }\r\n        } else {\r\n            let numLayers = 1;\r\n            if (this._rtWrapper.is3D) {\r\n                numLayers = this._rtWrapper.depth;\r\n            } else if (this._rtWrapper.is2DArray) {\r\n                numLayers = this._rtWrapper.layers;\r\n            }\r\n            for (let layer = 0; layer < numLayers; layer++) {\r\n                engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true, 0, layer);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {\r\n                    this._drawWrapper.effect?.setFloat(\"layer\", numLayers !== 1 ? layer / (numLayers - 1) : 0);\r\n                    this._drawWrapper.effect?.setInt(\"layerNum\", layer);\r\n                    for (const name in this._textures) {\r\n                        this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n                    }\r\n                }\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);\r\n            }\r\n        }\r\n\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture, true);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n"],
  "mappings": "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",
  "names": []
}
