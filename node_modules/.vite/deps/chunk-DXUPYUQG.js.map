{
  "version": 3,
  "sources": ["../../../dev/core/src/PostProcesses/thinBlurPostProcess.ts", "../../../dev/core/src/PostProcesses/blurPostProcess.ts", "../../../dev/core/src/Lights/Shadows/shadowGenerator.ts", "../../../dev/core/src/Rendering/depthRenderer.ts", "../../../dev/core/src/Shaders/minmaxRedux.fragment.ts", "../../../dev/core/src/Misc/minMaxReducer.ts", "../../../dev/core/src/Misc/depthReducer.ts", "../../../dev/core/src/Lights/Shadows/cascadedShadowGenerator.ts"],
  "sourcesContent": ["// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, AbstractEngine, EffectWrapperCreationOptions, Vector2, Effect } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Post process used to apply a blur effect\r\n */\r\nexport class ThinBlurPostProcess extends EffectWrapper {\r\n    /**\r\n     * The vertex shader url\r\n     */\r\n    public static readonly VertexUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"delta\", \"direction\"];\r\n\r\n    /**\r\n     * The list of samplers used by the effect\r\n     */\r\n    public static readonly Samplers = [\"circleOfConfusionSampler\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/kernelBlur.fragment\"), import(\"../ShadersWGSL/kernelBlur.vertex\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/kernelBlur.fragment\"), import(\"../Shaders/kernelBlur.vertex\")]));\r\n        }\r\n    }\r\n\r\n    protected _kernel: number;\r\n    protected _idealKernel: number;\r\n    protected _packedFloat: boolean = false;\r\n    private _staticDefines: string = \"\";\r\n\r\n    /**\r\n     * Constructs a new blur post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param direction Direction in which to apply the blur\r\n     * @param kernel Kernel size of the blur\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, direction?: Vector2, kernel?: number, options?: EffectWrapperCreationOptions) {\r\n        const blockCompilationFinal = !!options?.blockCompilation;\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinBlurPostProcess.FragmentUrl,\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            blockCompilation: true,\r\n        });\r\n\r\n        this._staticDefines = options ? (Array.isArray(options.defines) ? options.defines.join(\"\\n\") : options.defines || \"\") : \"\";\r\n\r\n        this.options.blockCompilation = blockCompilationFinal;\r\n\r\n        if (direction !== undefined) {\r\n            this.direction = direction;\r\n        }\r\n        if (kernel !== undefined) {\r\n            this.kernel = kernel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Width of the texture to apply the blur on\r\n     */\r\n    public textureWidth: number = 0;\r\n\r\n    /**\r\n     * Height of the texture to apply the blur on\r\n     */\r\n    public textureHeight: number = 0;\r\n\r\n    /** The direction in which to blur the image. */\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    public set kernel(v: number) {\r\n        if (this._idealKernel === v) {\r\n            return;\r\n        }\r\n\r\n        v = Math.max(v, 1);\r\n        this._idealKernel = v;\r\n        this._kernel = this._nearestBestKernel(v);\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._idealKernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    public set packedFloat(v: boolean) {\r\n        if (this._packedFloat === v) {\r\n            return;\r\n        }\r\n        this._packedFloat = v;\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._packedFloat;\r\n    }\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n        this._drawWrapper.effect!.setFloat2(\"delta\", (1 / this.textureWidth) * this.direction.x, (1 / this.textureHeight) * this.direction.y);\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void {\r\n        // Generate sampling offsets and weights\r\n        const N = this._kernel;\r\n        const centerIndex = (N - 1) / 2;\r\n\r\n        // Generate Gaussian sampling weights over kernel\r\n        let offsets = [];\r\n        let weights = [];\r\n        let totalWeight = 0;\r\n        for (let i = 0; i < N; i++) {\r\n            const u = i / (N - 1);\r\n            const w = this._gaussianWeight(u * 2.0 - 1);\r\n            offsets[i] = i - centerIndex;\r\n            weights[i] = w;\r\n            totalWeight += w;\r\n        }\r\n\r\n        // Normalize weights\r\n        for (let i = 0; i < weights.length; i++) {\r\n            weights[i] /= totalWeight;\r\n        }\r\n\r\n        // Optimize: combine samples to take advantage of hardware linear sampling\r\n        // Walk from left to center, combining pairs (symmetrically)\r\n        const linearSamplingWeights = [];\r\n        const linearSamplingOffsets = [];\r\n\r\n        const linearSamplingMap = [];\r\n\r\n        for (let i = 0; i <= centerIndex; i += 2) {\r\n            const j = Math.min(i + 1, Math.floor(centerIndex));\r\n\r\n            const singleCenterSample = i === j;\r\n\r\n            if (singleCenterSample) {\r\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n            } else {\r\n                const sharedCell = j === centerIndex;\r\n\r\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\r\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\r\n\r\n                if (offsetLinear === 0) {\r\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\r\n                } else {\r\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\r\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < linearSamplingMap.length; i++) {\r\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\r\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\r\n        }\r\n\r\n        // Replace with optimized\r\n        offsets = linearSamplingOffsets;\r\n        weights = linearSamplingWeights;\r\n\r\n        // Generate shaders\r\n        const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === ShaderLanguage.WGSL ? 1 : 0); // Because of the additional builtins\r\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\r\n\r\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\r\n\r\n        let defines = \"\";\r\n        defines += this._staticDefines;\r\n\r\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\r\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\r\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\n`;\r\n            varyingCount--;\r\n        }\r\n\r\n        for (let i = 0; i < varyingCount; i++) {\r\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\n`;\r\n        }\r\n\r\n        let depCount = 0;\r\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\r\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\n`;\r\n            depCount++;\r\n        }\r\n\r\n        if (this.packedFloat) {\r\n            defines += `#define PACKEDFLOAT 1`;\r\n        }\r\n\r\n        this.options.blockCompilation = false;\r\n\r\n        this.updateEffect(\r\n            defines,\r\n            null,\r\n            null,\r\n            {\r\n                varyingCount: varyingCount,\r\n                depCount: depCount,\r\n            },\r\n            onCompiled,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\r\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\r\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\r\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\r\n     * The gaps between physical kernels are compensated for in the weighting of the samples\r\n     * @param idealKernel Ideal blur kernel.\r\n     * @returns Nearest best kernel.\r\n     */\r\n    protected _nearestBestKernel(idealKernel: number): number {\r\n        const v = Math.round(idealKernel);\r\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\r\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\r\n                return Math.max(k, 3);\r\n            }\r\n        }\r\n        return Math.max(v, 3);\r\n    }\r\n\r\n    /**\r\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\r\n     * @param x The point on the Gaussian distribution to sample.\r\n     * @returns the value of the Gaussian function at x.\r\n     */\r\n    protected _gaussianWeight(x: number): number {\r\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\r\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\r\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\r\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\r\n        // truncated at around 1.3% of peak strength.\r\n\r\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\r\n        const sigma = 1 / 3;\r\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\r\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\r\n        const weight = (1.0 / denominator) * Math.exp(exponent);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Generates a string that can be used as a floating point number in GLSL.\r\n     * @param x Value to print.\r\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\r\n     * @returns GLSL float string.\r\n     */\r\n    protected _glslFloat(x: number, decimalFigures = 8) {\r\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\r\n    }\r\n}\r\n", "import type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, serializeAsVector2 } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { ThinBlurPostProcess } from \"./thinBlurPostProcess\";\r\n\r\n/**\r\n * The Blur Post Process which blurs an image based on a kernel and direction.\r\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\r\n */\r\nexport class BlurPostProcess extends PostProcess {\r\n    /** The direction in which to blur the image. */\r\n    @serializeAsVector2()\r\n    public get direction() {\r\n        return this._effectWrapper.direction;\r\n    }\r\n\r\n    public set direction(value: Vector2) {\r\n        this._effectWrapper.direction = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    @serialize()\r\n    public set kernel(v: number) {\r\n        this._effectWrapper.kernel = v;\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._effectWrapper.kernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    @serialize()\r\n    public set packedFloat(v: boolean) {\r\n        this._effectWrapper.packedFloat = v;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._effectWrapper.packedFloat;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BlurPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BlurPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinBlurPostProcess;\r\n\r\n    /**\r\n     * Creates a new instance BlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param direction The direction in which to blur the image.\r\n     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param defines\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        defines = \"\",\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        const blockCompilationFinal = typeof options === \"number\" ? blockCompilation : !!options.blockCompilation;\r\n        const localOptions = {\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            indexParameters: { varyingCount: 0, depCount: 0 },\r\n            textureFormat,\r\n            defines,\r\n            ...(options as PostProcessOptions),\r\n            blockCompilation: true,\r\n        };\r\n\r\n        super(name, ThinBlurPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinBlurPostProcess(name, engine, undefined, undefined, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this._effectWrapper.options.blockCompilation = blockCompilationFinal;\r\n\r\n        this.direction = direction;\r\n        this.onApplyObservable.add(() => {\r\n            this._effectWrapper.textureWidth = this._outputTexture ? this._outputTexture.width : this.width;\r\n            this._effectWrapper.textureHeight = this._outputTexture ? this._outputTexture.height : this.height;\r\n        });\r\n\r\n        this.kernel = kernel;\r\n    }\r\n\r\n    public override updateEffect(\r\n        _defines: Nullable<string> = null,\r\n        _uniforms: Nullable<string[]> = null,\r\n        _samplers: Nullable<string[]> = null,\r\n        _indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        this._effectWrapper._updateParameters(onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new BlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.direction,\r\n                    parsedPostProcess.kernel,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    undefined,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\r\n", "import type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\n\r\nimport type { IShadowLight } from \"../../Lights/shadowLight\";\r\nimport { Light } from \"../../Lights/light\";\r\nimport type { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\n\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { BlurPostProcess } from \"../../PostProcesses/blurPostProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { EffectFallbacks } from \"../../Materials/effectFallbacks\";\r\nimport { RenderingManager } from \"../../Rendering/renderingManager\";\r\nimport { DrawWrapper } from \"../../Materials/drawWrapper\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\n\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../../Materials/clipPlaneMaterialHelper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport {\r\n    BindMorphTargetParameters,\r\n    BindSceneUniformBuffer,\r\n    PrepareDefinesAndAttributesForMorphTargets,\r\n    PushAttributesForInstances,\r\n} from \"../../Materials/materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Defines the options associated with the creation of a custom shader for a shadow generator.\r\n */\r\nexport interface ICustomShaderOptions {\r\n    /**\r\n     * Gets or sets the custom shader name to use\r\n     */\r\n    shaderName: string;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes?: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms?: string[];\r\n\r\n    /**\r\n     * The list of sampler names used in the shader\r\n     */\r\n    samplers?: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines?: string[];\r\n}\r\n\r\n/**\r\n * Interface to implement to create a shadow generator compatible with BJS.\r\n */\r\nexport interface IShadowGenerator {\r\n    /** Gets or set the id of the shadow generator. It will be the one from the light if not defined */\r\n    id: string;\r\n\r\n    /**\r\n     * Specifies if the `ShadowGenerator` should be serialized, `true` to skip serialization.\r\n     * Note a `ShadowGenerator` will not be serialized if its light has `doNotSerialize=true`\r\n     */\r\n    doNotSerialize?: boolean;\r\n\r\n    /**\r\n     * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).\r\n     * @returns The render target texture if present otherwise, null\r\n     */\r\n    getShadowMap(): Nullable<RenderTargetTexture>;\r\n\r\n    /**\r\n     * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).\r\n     * @param subMesh The submesh we want to render in the shadow map\r\n     * @param useInstances Defines whether will draw in the map using instances\r\n     * @param isTransparent Indicates that isReady is called for a transparent subMesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    isReady(subMesh: SubMesh, useInstances: boolean, isTransparent: boolean): boolean;\r\n\r\n    /**\r\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\r\n     * @param defines Defines of the material we want to update\r\n     * @param lightIndex Index of the light in the enabled light list of the material\r\n     */\r\n    prepareDefines(defines: MaterialDefines, lightIndex: number): void;\r\n    /**\r\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\r\n     * defined in the generator but impacting the effect).\r\n     * It implies the uniforms available on the materials are the standard BJS ones.\r\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\r\n     * @param effect The effect we are binding the information for\r\n     */\r\n    bindShadowLight(lightIndex: string, effect: Effect): void;\r\n    /**\r\n     * Gets the transformation matrix used to project the meshes into the map from the light point of view.\r\n     * (eq to shadow projection matrix * light transform matrix)\r\n     * @returns The transform matrix used to create the shadow map\r\n     */\r\n    getTransformMatrix(): Matrix;\r\n\r\n    /**\r\n     * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between\r\n     * Cube and 2D textures for instance.\r\n     */\r\n    recreateShadowMap(): void;\r\n\r\n    /**\r\n     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.\r\n     * @param onCompiled Callback triggered at the and of the effects compilation\r\n     * @param options Sets of optional options forcing the compilation with different modes\r\n     */\r\n    forceCompilation(onCompiled?: (generator: IShadowGenerator) => void, options?: Partial<{ useInstances: boolean }>): void;\r\n\r\n    /**\r\n     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.\r\n     * @param options Sets of optional options forcing the compilation with different modes\r\n     * @returns A promise that resolves when the compilation completes\r\n     */\r\n    forceCompilationAsync(options?: Partial<{ useInstances: boolean }>): Promise<void>;\r\n\r\n    /**\r\n     * Serializes the shadow generator setup to a json object.\r\n     * @returns The serialized JSON object\r\n     */\r\n    serialize(): any;\r\n\r\n    /**\r\n     * Disposes the Shadow map and related Textures and effects.\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * Default implementation IShadowGenerator.\r\n * This is the main object responsible of generating shadows in the framework.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\r\n * @see [WebGL](https://playground.babylonjs.com/#IFYDRS#0)\r\n * @see [WebGPU](https://playground.babylonjs.com/#IFYDRS#835)\r\n */\r\nexport class ShadowGenerator implements IShadowGenerator {\r\n    /**\r\n     * Name of the shadow generator class\r\n     */\r\n    public static CLASSNAME = \"ShadowGenerator\";\r\n\r\n    /**\r\n     * Force all the shadow generators to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Shadow generator mode None: no filtering applied.\r\n     */\r\n    public static readonly FILTER_NONE = 0;\r\n    /**\r\n     * Shadow generator mode ESM: Exponential Shadow Mapping.\r\n     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\r\n     */\r\n    public static readonly FILTER_EXPONENTIALSHADOWMAP = 1;\r\n    /**\r\n     * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.\r\n     * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)\r\n     */\r\n    public static readonly FILTER_POISSONSAMPLING = 2;\r\n    /**\r\n     * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.\r\n     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\r\n     */\r\n    public static readonly FILTER_BLUREXPONENTIALSHADOWMAP = 3;\r\n    /**\r\n     * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing\r\n     * edge artifacts on steep falloff.\r\n     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\r\n     */\r\n    public static readonly FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;\r\n    /**\r\n     * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing\r\n     * edge artifacts on steep falloff.\r\n     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)\r\n     */\r\n    public static readonly FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;\r\n    /**\r\n     * Shadow generator mode PCF: Percentage Closer Filtering\r\n     * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1\r\n     * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)\r\n     */\r\n    public static readonly FILTER_PCF = 6;\r\n    /**\r\n     * Shadow generator mode PCSS: Percentage Closering Soft Shadow.\r\n     * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1\r\n     * Contact Hardening\r\n     */\r\n    public static readonly FILTER_PCSS = 7;\r\n\r\n    /**\r\n     * Reserved for PCF and PCSS\r\n     * Highest Quality.\r\n     *\r\n     * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.\r\n     *\r\n     * Execute PCSS with 32 taps blocker search and 64 taps PCF.\r\n     */\r\n    public static readonly QUALITY_HIGH = 0;\r\n    /**\r\n     * Reserved for PCF and PCSS\r\n     * Good tradeoff for quality/perf cross devices\r\n     *\r\n     * Execute PCF on a 3*3 kernel.\r\n     *\r\n     * Execute PCSS with 16 taps blocker search and 32 taps PCF.\r\n     */\r\n    public static readonly QUALITY_MEDIUM = 1;\r\n    /**\r\n     * Reserved for PCF and PCSS\r\n     * The lowest quality but the fastest.\r\n     *\r\n     * Execute PCF on a 1*1 kernel.\r\n     *\r\n     * Execute PCSS with 16 taps blocker search and 16 taps PCF.\r\n     */\r\n    public static readonly QUALITY_LOW = 2;\r\n\r\n    /**\r\n     * Defines the default alpha cutoff value used for transparent alpha tested materials.\r\n     */\r\n    public static DEFAULT_ALPHA_CUTOFF = 0.5;\r\n\r\n    /** Gets or set the id of the shadow generator. It will be the one from the light if not defined */\r\n    public id: string;\r\n\r\n    /** Gets or sets the custom shader name to use */\r\n    public customShaderOptions: ICustomShaderOptions;\r\n\r\n    /** Gets or sets a custom function to allow/disallow rendering a sub mesh in the shadow map */\r\n    public customAllowRendering: (subMesh: SubMesh) => boolean;\r\n\r\n    /**\r\n     * Observable triggered before the shadow is rendered. Can be used to update internal effect state\r\n     */\r\n    public onBeforeShadowMapRenderObservable = new Observable<Effect>();\r\n\r\n    /**\r\n     * Observable triggered after the shadow is rendered. Can be used to restore internal effect state\r\n     */\r\n    public onAfterShadowMapRenderObservable = new Observable<Effect>();\r\n\r\n    /**\r\n     * Observable triggered before a mesh is rendered in the shadow map.\r\n     * Can be used to update internal effect state (that you can get from the onBeforeShadowMapRenderObservable)\r\n     */\r\n    public onBeforeShadowMapRenderMeshObservable = new Observable<Mesh>();\r\n\r\n    /**\r\n     * Observable triggered after a mesh is rendered in the shadow map.\r\n     * Can be used to update internal effect state (that you can get from the onAfterShadowMapRenderObservable)\r\n     */\r\n    public onAfterShadowMapRenderMeshObservable = new Observable<Mesh>();\r\n\r\n    /**\r\n     * Specifies if the `ShadowGenerator` should be serialized, `true` to skip serialization.\r\n     * Note a `ShadowGenerator` will not be serialized if its light has `doNotSerialize=true`\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    protected _bias = 0.00005;\r\n    /**\r\n     * Gets the bias: offset applied on the depth preventing acnea (in light direction).\r\n     */\r\n    public get bias(): number {\r\n        return this._bias;\r\n    }\r\n    /**\r\n     * Sets the bias: offset applied on the depth preventing acnea (in light direction).\r\n     */\r\n    public set bias(bias: number) {\r\n        this._bias = bias;\r\n    }\r\n\r\n    protected _normalBias = 0;\r\n    /**\r\n     * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).\r\n     */\r\n    public get normalBias(): number {\r\n        return this._normalBias;\r\n    }\r\n    /**\r\n     * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).\r\n     */\r\n    public set normalBias(normalBias: number) {\r\n        this._normalBias = normalBias;\r\n    }\r\n\r\n    protected _blurBoxOffset = 1;\r\n    /**\r\n     * Gets the blur box offset: offset applied during the blur pass.\r\n     * Only useful if useKernelBlur = false\r\n     */\r\n    public get blurBoxOffset(): number {\r\n        return this._blurBoxOffset;\r\n    }\r\n    /**\r\n     * Sets the blur box offset: offset applied during the blur pass.\r\n     * Only useful if useKernelBlur = false\r\n     */\r\n    public set blurBoxOffset(value: number) {\r\n        if (this._blurBoxOffset === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurBoxOffset = value;\r\n        this._disposeBlurPostProcesses();\r\n    }\r\n\r\n    protected _blurScale = 2;\r\n    /**\r\n     * Gets the blur scale: scale of the blurred texture compared to the main shadow map.\r\n     * 2 means half of the size.\r\n     */\r\n    public get blurScale(): number {\r\n        return this._blurScale;\r\n    }\r\n    /**\r\n     * Sets the blur scale: scale of the blurred texture compared to the main shadow map.\r\n     * 2 means half of the size.\r\n     */\r\n    public set blurScale(value: number) {\r\n        if (this._blurScale === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurScale = value;\r\n        this._disposeBlurPostProcesses();\r\n    }\r\n\r\n    protected _blurKernel = 1;\r\n    /**\r\n     * Gets the blur kernel: kernel size of the blur pass.\r\n     * Only useful if useKernelBlur = true\r\n     */\r\n    public get blurKernel(): number {\r\n        return this._blurKernel;\r\n    }\r\n    /**\r\n     * Sets the blur kernel: kernel size of the blur pass.\r\n     * Only useful if useKernelBlur = true\r\n     */\r\n    public set blurKernel(value: number) {\r\n        if (this._blurKernel === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurKernel = value;\r\n        this._disposeBlurPostProcesses();\r\n    }\r\n\r\n    protected _useKernelBlur = false;\r\n    /**\r\n     * Gets whether the blur pass is a kernel blur (if true) or box blur.\r\n     * Only useful in filtered mode (useBlurExponentialShadowMap...)\r\n     */\r\n    public get useKernelBlur(): boolean {\r\n        return this._useKernelBlur;\r\n    }\r\n    /**\r\n     * Sets whether the blur pass is a kernel blur (if true) or box blur.\r\n     * Only useful in filtered mode (useBlurExponentialShadowMap...)\r\n     */\r\n    public set useKernelBlur(value: boolean) {\r\n        if (this._useKernelBlur === value) {\r\n            return;\r\n        }\r\n\r\n        this._useKernelBlur = value;\r\n        this._disposeBlurPostProcesses();\r\n    }\r\n\r\n    protected _depthScale: number;\r\n    /**\r\n     * Gets the depth scale used in ESM mode.\r\n     */\r\n    public get depthScale(): number {\r\n        return this._depthScale !== undefined ? this._depthScale : this._light.getDepthScale();\r\n    }\r\n    /**\r\n     * Sets the depth scale used in ESM mode.\r\n     * This can override the scale stored on the light.\r\n     */\r\n    public set depthScale(value: number) {\r\n        this._depthScale = value;\r\n    }\r\n\r\n    protected _validateFilter(filter: number): number {\r\n        return filter;\r\n    }\r\n\r\n    protected _filter = ShadowGenerator.FILTER_NONE;\r\n    /**\r\n     * Gets the current mode of the shadow generator (normal, PCF, ESM...).\r\n     * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE\r\n     */\r\n    public get filter(): number {\r\n        return this._filter;\r\n    }\r\n    /**\r\n     * Sets the current mode of the shadow generator (normal, PCF, ESM...).\r\n     * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE\r\n     */\r\n    public set filter(value: number) {\r\n        value = this._validateFilter(value);\r\n\r\n        // Blurring the cubemap is going to be too expensive. Reverting to unblurred version\r\n        if (this._light.needCube()) {\r\n            if (value === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {\r\n                this.useExponentialShadowMap = true;\r\n                return;\r\n            } else if (value === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {\r\n                this.useCloseExponentialShadowMap = true;\r\n                return;\r\n            }\r\n            // PCF on cubemap would also be expensive\r\n            else if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {\r\n                this.usePoissonSampling = true;\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Weblg1 fallback for PCF.\r\n        if (value === ShadowGenerator.FILTER_PCF || value === ShadowGenerator.FILTER_PCSS) {\r\n            if (!this._scene.getEngine()._features.supportShadowSamplers) {\r\n                this.usePoissonSampling = true;\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (this._filter === value) {\r\n            return;\r\n        }\r\n\r\n        this._filter = value;\r\n        this._disposeBlurPostProcesses();\r\n        this._applyFilterValues();\r\n        this._light._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets if the current filter is set to Poisson Sampling.\r\n     */\r\n    public get usePoissonSampling(): boolean {\r\n        return this.filter === ShadowGenerator.FILTER_POISSONSAMPLING;\r\n    }\r\n    /**\r\n     * Sets the current filter to Poisson Sampling.\r\n     */\r\n    public set usePoissonSampling(value: boolean) {\r\n        const filter = this._validateFilter(ShadowGenerator.FILTER_POISSONSAMPLING);\r\n\r\n        if (!value && this.filter !== ShadowGenerator.FILTER_POISSONSAMPLING) {\r\n            return;\r\n        }\r\n\r\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets if the current filter is set to ESM.\r\n     */\r\n    public get useExponentialShadowMap(): boolean {\r\n        return this.filter === ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;\r\n    }\r\n    /**\r\n     * Sets the current filter is to ESM.\r\n     */\r\n    public set useExponentialShadowMap(value: boolean) {\r\n        const filter = this._validateFilter(ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);\r\n\r\n        if (!value && this.filter !== ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {\r\n            return;\r\n        }\r\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets if the current filter is set to filtered ESM.\r\n     */\r\n    public get useBlurExponentialShadowMap(): boolean {\r\n        return this.filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;\r\n    }\r\n    /**\r\n     * Gets if the current filter is set to filtered  ESM.\r\n     */\r\n    public set useBlurExponentialShadowMap(value: boolean) {\r\n        const filter = this._validateFilter(ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);\r\n\r\n        if (!value && this.filter !== ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {\r\n            return;\r\n        }\r\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets if the current filter is set to \"close ESM\" (using the inverse of the\r\n     * exponential to prevent steep falloff artifacts).\r\n     */\r\n    public get useCloseExponentialShadowMap(): boolean {\r\n        return this.filter === ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;\r\n    }\r\n    /**\r\n     * Sets the current filter to \"close ESM\" (using the inverse of the\r\n     * exponential to prevent steep falloff artifacts).\r\n     */\r\n    public set useCloseExponentialShadowMap(value: boolean) {\r\n        const filter = this._validateFilter(ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);\r\n\r\n        if (!value && this.filter !== ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {\r\n            return;\r\n        }\r\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets if the current filter is set to filtered \"close ESM\" (using the inverse of the\r\n     * exponential to prevent steep falloff artifacts).\r\n     */\r\n    public get useBlurCloseExponentialShadowMap(): boolean {\r\n        return this.filter === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;\r\n    }\r\n    /**\r\n     * Sets the current filter to filtered \"close ESM\" (using the inverse of the\r\n     * exponential to prevent steep falloff artifacts).\r\n     */\r\n    public set useBlurCloseExponentialShadowMap(value: boolean) {\r\n        const filter = this._validateFilter(ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);\r\n\r\n        if (!value && this.filter !== ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {\r\n            return;\r\n        }\r\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets if the current filter is set to \"PCF\" (percentage closer filtering).\r\n     */\r\n    public get usePercentageCloserFiltering(): boolean {\r\n        return this.filter === ShadowGenerator.FILTER_PCF;\r\n    }\r\n    /**\r\n     * Sets the current filter to \"PCF\" (percentage closer filtering).\r\n     */\r\n    public set usePercentageCloserFiltering(value: boolean) {\r\n        const filter = this._validateFilter(ShadowGenerator.FILTER_PCF);\r\n\r\n        if (!value && this.filter !== ShadowGenerator.FILTER_PCF) {\r\n            return;\r\n        }\r\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    protected _filteringQuality = ShadowGenerator.QUALITY_HIGH;\r\n    /**\r\n     * Gets the PCF or PCSS Quality.\r\n     * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.\r\n     */\r\n    public get filteringQuality(): number {\r\n        return this._filteringQuality;\r\n    }\r\n    /**\r\n     * Sets the PCF or PCSS Quality.\r\n     * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.\r\n     */\r\n    public set filteringQuality(filteringQuality: number) {\r\n        if (this._filteringQuality === filteringQuality) {\r\n            return;\r\n        }\r\n\r\n        this._filteringQuality = filteringQuality;\r\n\r\n        this._disposeBlurPostProcesses();\r\n        this._applyFilterValues();\r\n        this._light._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets if the current filter is set to \"PCSS\" (contact hardening).\r\n     */\r\n    public get useContactHardeningShadow(): boolean {\r\n        return this.filter === ShadowGenerator.FILTER_PCSS;\r\n    }\r\n    /**\r\n     * Sets the current filter to \"PCSS\" (contact hardening).\r\n     */\r\n    public set useContactHardeningShadow(value: boolean) {\r\n        const filter = this._validateFilter(ShadowGenerator.FILTER_PCSS);\r\n\r\n        if (!value && this.filter !== ShadowGenerator.FILTER_PCSS) {\r\n            return;\r\n        }\r\n        this.filter = value ? filter : ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    protected _contactHardeningLightSizeUVRatio = 0.1;\r\n    /**\r\n     * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.\r\n     * Using a ratio helps keeping shape stability independently of the map size.\r\n     *\r\n     * It does not account for the light projection as it was having too much\r\n     * instability during the light setup or during light position changes.\r\n     *\r\n     * Only valid if useContactHardeningShadow is true.\r\n     */\r\n    public get contactHardeningLightSizeUVRatio(): number {\r\n        return this._contactHardeningLightSizeUVRatio;\r\n    }\r\n    /**\r\n     * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.\r\n     * Using a ratio helps keeping shape stability independently of the map size.\r\n     *\r\n     * It does not account for the light projection as it was having too much\r\n     * instability during the light setup or during light position changes.\r\n     *\r\n     * Only valid if useContactHardeningShadow is true.\r\n     */\r\n    public set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio: number) {\r\n        this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;\r\n    }\r\n\r\n    protected _darkness = 0;\r\n\r\n    /** Gets or sets the actual darkness of a shadow */\r\n    public get darkness() {\r\n        return this._darkness;\r\n    }\r\n\r\n    public set darkness(value: number) {\r\n        this.setDarkness(value);\r\n    }\r\n\r\n    /**\r\n     * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.\r\n     * 0 means strongest and 1 would means no shadow.\r\n     * @returns the darkness.\r\n     */\r\n    public getDarkness(): number {\r\n        return this._darkness;\r\n    }\r\n    /**\r\n     * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.\r\n     * @param darkness The darkness value 0 means strongest and 1 would means no shadow.\r\n     * @returns the shadow generator allowing fluent coding.\r\n     */\r\n    public setDarkness(darkness: number): ShadowGenerator {\r\n        if (darkness >= 1.0) {\r\n            this._darkness = 1.0;\r\n        } else if (darkness <= 0.0) {\r\n            this._darkness = 0.0;\r\n        } else {\r\n            this._darkness = darkness;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected _transparencyShadow = false;\r\n\r\n    /** Gets or sets the ability to have transparent shadow */\r\n    public get transparencyShadow() {\r\n        return this._transparencyShadow;\r\n    }\r\n\r\n    public set transparencyShadow(value: boolean) {\r\n        this.setTransparencyShadow(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the ability to have transparent shadow (boolean).\r\n     * @param transparent True if transparent else False\r\n     * @returns the shadow generator allowing fluent coding\r\n     */\r\n    public setTransparencyShadow(transparent: boolean): ShadowGenerator {\r\n        this._transparencyShadow = transparent;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables shadows with varying strength based on the transparency\r\n     * When it is enabled, the strength of the shadow is taken equal to mesh.visibility\r\n     * If you enabled an alpha texture on your material, the alpha value red from the texture is also combined to compute the strength:\r\n     *          mesh.visibility * alphaTexture.a\r\n     * The texture used is the diffuse by default, but it can be set to the opacity by setting useOpacityTextureForTransparentShadow\r\n     * Note that by definition transparencyShadow must be set to true for enableSoftTransparentShadow to work!\r\n     */\r\n    public enableSoftTransparentShadow: boolean = false;\r\n\r\n    /**\r\n     * If this is true, use the opacity texture's alpha channel for transparent shadows instead of the diffuse one\r\n     */\r\n    public useOpacityTextureForTransparentShadow: boolean = false;\r\n\r\n    protected _shadowMap: Nullable<RenderTargetTexture>;\r\n    protected _shadowMap2: Nullable<RenderTargetTexture>;\r\n\r\n    /**\r\n     * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).\r\n     * @returns The render target texture if present otherwise, null\r\n     */\r\n    public getShadowMap(): Nullable<RenderTargetTexture> {\r\n        return this._shadowMap;\r\n    }\r\n\r\n    /**\r\n     * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).\r\n     * @returns The render target texture if the shadow map is present otherwise, null\r\n     */\r\n    public getShadowMapForRendering(): Nullable<RenderTargetTexture> {\r\n        if (this._shadowMap2) {\r\n            return this._shadowMap2;\r\n        }\r\n\r\n        return this._shadowMap;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of that object\r\n     * @returns \"ShadowGenerator\"\r\n     */\r\n    public getClassName(): string {\r\n        return ShadowGenerator.CLASSNAME;\r\n    }\r\n\r\n    /**\r\n     * Helper function to add a mesh and its descendants to the list of shadow casters.\r\n     * @param mesh Mesh to add\r\n     * @param includeDescendants boolean indicating if the descendants should be added. Default to true\r\n     * @returns the Shadow Generator itself\r\n     */\r\n    public addShadowCaster(mesh: AbstractMesh, includeDescendants = true): ShadowGenerator {\r\n        if (!this._shadowMap) {\r\n            return this;\r\n        }\r\n\r\n        if (!this._shadowMap.renderList) {\r\n            this._shadowMap.renderList = [];\r\n        }\r\n\r\n        if (this._shadowMap.renderList.indexOf(mesh) === -1) {\r\n            this._shadowMap.renderList.push(mesh);\r\n        }\r\n\r\n        if (includeDescendants) {\r\n            for (const childMesh of mesh.getChildMeshes()) {\r\n                if (this._shadowMap.renderList.indexOf(childMesh) === -1) {\r\n                    this._shadowMap.renderList.push(childMesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Helper function to remove a mesh and its descendants from the list of shadow casters\r\n     * @param mesh Mesh to remove\r\n     * @param includeDescendants boolean indicating if the descendants should be removed. Default to true\r\n     * @returns the Shadow Generator itself\r\n     */\r\n    public removeShadowCaster(mesh: AbstractMesh, includeDescendants = true): ShadowGenerator {\r\n        if (!this._shadowMap || !this._shadowMap.renderList) {\r\n            return this;\r\n        }\r\n\r\n        const index = this._shadowMap.renderList.indexOf(mesh);\r\n\r\n        if (index !== -1) {\r\n            this._shadowMap.renderList.splice(index, 1);\r\n        }\r\n\r\n        if (includeDescendants) {\r\n            for (const child of mesh.getChildren()) {\r\n                this.removeShadowCaster(<any>child);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Controls the extent to which the shadows fade out at the edge of the frustum\r\n     */\r\n    public frustumEdgeFalloff = 0;\r\n\r\n    protected _light: IShadowLight;\r\n    /**\r\n     * Returns the associated light object.\r\n     * @returns the light generating the shadow\r\n     */\r\n    public getLight(): IShadowLight {\r\n        return this._light;\r\n    }\r\n\r\n    /** Shader language used by the generator */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language used in this generator.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * If true the shadow map is generated by rendering the back face of the mesh instead of the front face.\r\n     * This can help with self-shadowing as the geometry making up the back of objects is slightly offset.\r\n     * It might on the other hand introduce peter panning.\r\n     */\r\n    public forceBackFacesOnly = false;\r\n\r\n    protected _camera: Nullable<Camera>;\r\n\r\n    protected _getCamera() {\r\n        return this._camera ?? this._scene.activeCamera;\r\n    }\r\n\r\n    protected _scene: Scene;\r\n    protected _useRedTextureType: boolean;\r\n    protected _lightDirection = Vector3.Zero();\r\n\r\n    protected _viewMatrix = Matrix.Zero();\r\n    protected _projectionMatrix = Matrix.Zero();\r\n    protected _transformMatrix = Matrix.Zero();\r\n    protected _cachedPosition: Vector3 = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    protected _cachedDirection: Vector3 = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    protected _cachedDefines: string;\r\n    protected _currentRenderId: number;\r\n    protected _boxBlurPostprocess: Nullable<PostProcess>;\r\n    protected _kernelBlurXPostprocess: Nullable<PostProcess>;\r\n    protected _kernelBlurYPostprocess: Nullable<PostProcess>;\r\n    protected _blurPostProcesses: PostProcess[];\r\n    protected _mapSize: number;\r\n    protected _currentFaceIndex = 0;\r\n    protected _currentFaceIndexCache = 0;\r\n    protected _textureType: number;\r\n    protected _defaultTextureMatrix = Matrix.Identity();\r\n    protected _storedUniqueId: Nullable<number>;\r\n    protected _useUBO: boolean;\r\n    protected _sceneUBOs: UniformBuffer[];\r\n    protected _currentSceneUBO: UniformBuffer;\r\n    protected _opacityTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"ShadowGeneratorSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Gets or sets the size of the texture what stores the shadows\r\n     */\r\n    public get mapSize(): number {\r\n        return this._mapSize;\r\n    }\r\n\r\n    public set mapSize(size: number) {\r\n        this._mapSize = size;\r\n        this._light._markMeshesAsLightDirty();\r\n        this.recreateShadowMap();\r\n    }\r\n\r\n    /**\r\n     * Creates a ShadowGenerator object.\r\n     * A ShadowGenerator is the required tool to use the shadows.\r\n     * Each light casting shadows needs to use its own ShadowGenerator.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\r\n     * @param mapSize The size of the texture what stores the shadows. Example : 1024.\r\n     * @param light The light object generating the shadows.\r\n     * @param usefullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\r\n     * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\r\n     * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: false)\r\n     * @param forceGLSL defines a boolean indicating if the shader must be compiled in GLSL even if we are using WebGPU\r\n     */\r\n    constructor(mapSize: number, light: IShadowLight, usefullFloatFirst?: boolean, camera?: Nullable<Camera>, useRedTextureType?: boolean, forceGLSL = false) {\r\n        this._mapSize = mapSize;\r\n        this._light = light;\r\n        this._scene = light.getScene();\r\n        this._camera = camera ?? null;\r\n        this._useRedTextureType = !!useRedTextureType;\r\n\r\n        this._initShaderSourceAsync(forceGLSL);\r\n\r\n        let shadowGenerators = light._shadowGenerators;\r\n        if (!shadowGenerators) {\r\n            shadowGenerators = light._shadowGenerators = new Map();\r\n        }\r\n        shadowGenerators.set(this._camera, this);\r\n        this.id = light.id;\r\n        this._useUBO = this._scene.getEngine().supportsUniformBuffers;\r\n\r\n        if (this._useUBO) {\r\n            this._sceneUBOs = [];\r\n            this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light \"${this._light.name}\")`));\r\n        }\r\n\r\n        ShadowGenerator._SceneComponentInitialization(this._scene);\r\n\r\n        // Texture type fallback from float to int if not supported.\r\n        const caps = this._scene.getEngine().getCaps();\r\n\r\n        if (!usefullFloatFirst) {\r\n            if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n                this._textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n                this._textureType = Constants.TEXTURETYPE_FLOAT;\r\n            } else {\r\n                this._textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            }\r\n        } else {\r\n            if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n                this._textureType = Constants.TEXTURETYPE_FLOAT;\r\n            } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n                this._textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else {\r\n                this._textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            }\r\n        }\r\n\r\n        this._initializeGenerator();\r\n        this._applyFilterValues();\r\n    }\r\n\r\n    protected _initializeGenerator(): void {\r\n        this._light._markMeshesAsLightDirty();\r\n        this._initializeShadowMap();\r\n    }\r\n\r\n    protected _createTargetRenderTexture(): void {\r\n        const engine = this._scene.getEngine();\r\n        if (engine._features.supportDepthStencilTexture) {\r\n            this._shadowMap = new RenderTargetTexture(\r\n                this._light.name + \"_shadowMap\",\r\n                this._mapSize,\r\n                this._scene,\r\n                false,\r\n                true,\r\n                this._textureType,\r\n                this._light.needCube(),\r\n                undefined,\r\n                false,\r\n                false,\r\n                undefined,\r\n                this._useRedTextureType ? Constants.TEXTUREFORMAT_RED : Constants.TEXTUREFORMAT_RGBA\r\n            );\r\n            this._shadowMap.createDepthStencilTexture(\r\n                engine.useReverseDepthBuffer ? Constants.GREATER : Constants.LESS,\r\n                true,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                `DepthStencilForShadowGenerator-${this._light.name}`\r\n            );\r\n        } else {\r\n            this._shadowMap = new RenderTargetTexture(this._light.name + \"_shadowMap\", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());\r\n        }\r\n        this._shadowMap.noPrePassRenderer = true;\r\n    }\r\n\r\n    protected _initializeShadowMap(): void {\r\n        this._createTargetRenderTexture();\r\n\r\n        if (this._shadowMap === null) {\r\n            return;\r\n        }\r\n\r\n        this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._shadowMap.anisotropicFilteringLevel = 1;\r\n        this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._shadowMap.renderParticles = false;\r\n        this._shadowMap.ignoreCameraViewport = true;\r\n        if (this._storedUniqueId) {\r\n            this._shadowMap.uniqueId = this._storedUniqueId;\r\n        }\r\n\r\n        // Custom render function.\r\n        this._shadowMap.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ) => this._renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes);\r\n\r\n        // When preWarm is false, forces the mesh is ready function to true as we are double checking it\r\n        // in the custom render function. Also it prevents side effects and useless\r\n        // shader variations in DEPTHPREPASS mode.\r\n        this._shadowMap.customIsReadyFunction = (mesh: AbstractMesh, _refreshRate: number, preWarm?: boolean | undefined): boolean => {\r\n            if (!preWarm || !mesh.subMeshes) {\r\n                return true;\r\n            }\r\n\r\n            let isReady = true;\r\n            for (const subMesh of mesh.subMeshes) {\r\n                const renderingMesh = subMesh.getRenderingMesh();\r\n                const scene = this._scene;\r\n                const engine = scene.getEngine();\r\n                const material = subMesh.getMaterial();\r\n\r\n                if (!material || subMesh.verticesCount === 0 || (this.customAllowRendering && !this.customAllowRendering(subMesh))) {\r\n                    continue;\r\n                }\r\n\r\n                const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                if (batch.mustReturn) {\r\n                    continue;\r\n                }\r\n\r\n                const hardwareInstancedRendering =\r\n                    engine.getCaps().instancedArrays &&\r\n                    ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n                const isTransparent = material.needAlphaBlendingForMesh(renderingMesh);\r\n\r\n                isReady = this.isReady(subMesh, hardwareInstancedRendering, isTransparent) && isReady;\r\n            }\r\n\r\n            return isReady;\r\n        };\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._shadowMap.onBeforeBindObservable.add(() => {\r\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\r\n            engine._debugPushGroup?.(`shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\r\n        });\r\n\r\n        // Record Face Index before render.\r\n        this._shadowMap.onBeforeRenderObservable.add((faceIndex: number) => {\r\n            if (this._sceneUBOs) {\r\n                this._scene.setSceneUniformBuffer(this._sceneUBOs[0]);\r\n            }\r\n            this._currentFaceIndex = faceIndex;\r\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\r\n                engine.setColorWrite(false);\r\n            }\r\n            this.getTransformMatrix(); // generate the view/projection matrix\r\n            this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\r\n            if (this._useUBO) {\r\n                this._scene.getSceneUniformBuffer().unbindEffect();\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        });\r\n\r\n        // Blur if required after render.\r\n        this._shadowMap.onAfterUnbindObservable.add(() => {\r\n            if (this._sceneUBOs) {\r\n                this._scene.setSceneUniformBuffer(this._currentSceneUBO);\r\n            }\r\n            this._scene.updateTransformMatrix(); // restore the view/projection matrices of the active camera\r\n\r\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\r\n                engine.setColorWrite(true);\r\n            }\r\n            if (!this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {\r\n                engine._debugPopGroup?.(1);\r\n                return;\r\n            }\r\n            const shadowMap = this.getShadowMapForRendering();\r\n\r\n            if (shadowMap) {\r\n                this._scene.postProcessManager.directRender(this._blurPostProcesses, shadowMap.renderTarget, true);\r\n                engine.unBindFramebuffer(shadowMap.renderTarget!, true);\r\n            }\r\n\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        // Clear according to the chosen filter.\r\n        const clearZero = new Color4(0, 0, 0, 0);\r\n        const clearOne = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        this._shadowMap.onClearObservable.add((engine) => {\r\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\r\n                engine.clear(clearOne, false, true, false);\r\n            } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {\r\n                engine.clear(clearZero, true, true, false);\r\n            } else {\r\n                engine.clear(clearOne, true, true, false);\r\n            }\r\n        });\r\n\r\n        // Recreate on resize.\r\n        this._shadowMap.onResizeObservable.add((rtt) => {\r\n            this._storedUniqueId = this._shadowMap!.uniqueId;\r\n            this._mapSize = rtt.getRenderSize();\r\n            this._light._markMeshesAsLightDirty();\r\n            this.recreateShadowMap();\r\n        });\r\n\r\n        // Ensures rendering groupids do not erase the depth buffer\r\n        // or we would lose the shadows information.\r\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\r\n            this._shadowMap.setRenderingAutoClearDepthStencil(i, false);\r\n        }\r\n    }\r\n\r\n    private _shadersLoaded = false;\r\n    private async _initShaderSourceAsync(forceGLSL = false) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        if (engine.isWebGPU && !forceGLSL && !ShadowGenerator.ForceGLSL) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n\r\n            await Promise.all([\r\n                import(\"../../ShadersWGSL/shadowMap.fragment\"),\r\n                import(\"../../ShadersWGSL/shadowMap.vertex\"),\r\n                import(\"../../ShadersWGSL/depthBoxBlur.fragment\"),\r\n                import(\"../../ShadersWGSL/ShadersInclude/shadowMapFragmentSoftTransparentShadow\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([\r\n                import(\"../../Shaders/shadowMap.fragment\"),\r\n                import(\"../../Shaders/shadowMap.vertex\"),\r\n                import(\"../../Shaders/depthBoxBlur.fragment\"),\r\n                import(\"../../Shaders/ShadersInclude/shadowMapFragmentSoftTransparentShadow\"),\r\n            ]);\r\n        }\r\n\r\n        this._shadersLoaded = true;\r\n    }\r\n\r\n    protected _initializeBlurRTTAndPostProcesses(): void {\r\n        const engine = this._scene.getEngine();\r\n        const targetSize = this._mapSize / this.blurScale;\r\n\r\n        if (!this.useKernelBlur || this.blurScale !== 1.0) {\r\n            this._shadowMap2 = new RenderTargetTexture(this._light.name + \"_shadowMap2\", targetSize, this._scene, false, true, this._textureType, undefined, undefined, false);\r\n            this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        }\r\n\r\n        if (this.useKernelBlur) {\r\n            this._kernelBlurXPostprocess = new BlurPostProcess(\r\n                this._light.name + \"KernelBlurX\",\r\n                new Vector2(1, 0),\r\n                this.blurKernel,\r\n                1.0,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                this._textureType\r\n            );\r\n            this._kernelBlurXPostprocess.width = targetSize;\r\n            this._kernelBlurXPostprocess.height = targetSize;\r\n            this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            this._kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._shadowMap);\r\n            });\r\n\r\n            this._kernelBlurYPostprocess = new BlurPostProcess(\r\n                this._light.name + \"KernelBlurY\",\r\n                new Vector2(0, 1),\r\n                this.blurKernel,\r\n                1.0,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                this._textureType\r\n            );\r\n\r\n            this._kernelBlurXPostprocess.autoClear = false;\r\n            this._kernelBlurYPostprocess.autoClear = false;\r\n\r\n            if (this._textureType === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n                (<BlurPostProcess>this._kernelBlurXPostprocess).packedFloat = true;\r\n                (<BlurPostProcess>this._kernelBlurYPostprocess).packedFloat = true;\r\n            }\r\n\r\n            this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];\r\n        } else {\r\n            this._boxBlurPostprocess = new PostProcess(\r\n                this._light.name + \"DepthBoxBlur\",\r\n                \"depthBoxBlur\",\r\n                [\"screenSize\", \"boxOffset\"],\r\n                [],\r\n                1.0,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                \"#define OFFSET \" + this._blurBoxOffset,\r\n                this._textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                this._shaderLanguage\r\n            );\r\n            this._boxBlurPostprocess.externalTextureSamplerBinding = true;\r\n            this._boxBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", targetSize, targetSize);\r\n                effect.setTexture(\"textureSampler\", this._shadowMap);\r\n            });\r\n\r\n            this._boxBlurPostprocess.autoClear = false;\r\n\r\n            this._blurPostProcesses = [this._boxBlurPostprocess];\r\n        }\r\n    }\r\n\r\n    protected _renderForShadowMap(\r\n        opaqueSubMeshes: SmartArray<SubMesh>,\r\n        alphaTestSubMeshes: SmartArray<SubMesh>,\r\n        transparentSubMeshes: SmartArray<SubMesh>,\r\n        depthOnlySubMeshes: SmartArray<SubMesh>\r\n    ): void {\r\n        let index: number;\r\n\r\n        if (depthOnlySubMeshes.length) {\r\n            for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);\r\n            }\r\n        }\r\n\r\n        for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n            this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);\r\n        }\r\n\r\n        for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n            this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);\r\n        }\r\n\r\n        if (this._transparencyShadow) {\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);\r\n            }\r\n        } else {\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _bindCustomEffectForRenderSubMeshForShadowMap(subMesh: SubMesh, effect: Effect, mesh: AbstractMesh): void {\r\n        effect.setMatrix(\"viewProjection\", this.getTransformMatrix());\r\n    }\r\n\r\n    protected _renderSubMeshForShadowMap(subMesh: SubMesh, isTransparent: boolean = false): void {\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = subMesh.getEffectiveMesh();\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n        const material = subMesh.getMaterial();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        // Note:\r\n        // In rhs mode, we assume that meshes will be rendered in right-handed space (i.e. with an RHS camera), so the default value of material.sideOrientation is updated accordingly (see material constructor).\r\n        // However, when generating a shadow map, we render from the point of view of the light, whose view/projection matrices are always in lhs mode.\r\n        // We therefore need to \"undo\" the sideOrientation inversion that was previously performed when constructing the material.\r\n        const useRHS = scene.useRightHandedSystem;\r\n        const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\r\n        let sideOrientation = material._getEffectiveOrientation(renderingMesh);\r\n\r\n        if ((detNeg && !useRHS) || (!detNeg && useRHS)) {\r\n            sideOrientation =\r\n                sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation ? Constants.MATERIAL_CounterClockWiseSideOrientation : Constants.MATERIAL_ClockWiseSideOrientation;\r\n        }\r\n        const reverseSideOrientation = sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n        engine.setState(material.backFaceCulling, undefined, undefined, reverseSideOrientation, material.cullBackFaces);\r\n\r\n        // Managing instances\r\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        const hardwareInstancedRendering =\r\n            engine.getCaps().instancedArrays &&\r\n            ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n        if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {\r\n            return;\r\n        }\r\n\r\n        if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {\r\n            subMesh._renderId = scene.getRenderId();\r\n\r\n            const shadowDepthWrapper = material.shadowDepthWrapper;\r\n\r\n            const drawWrapper = shadowDepthWrapper?.getEffect(subMesh, this, engine.currentRenderPassId) ?? subMesh._getDrawWrapper()!;\r\n            const effect = DrawWrapper.GetEffect(drawWrapper)!;\r\n\r\n            engine.enableEffect(drawWrapper);\r\n\r\n            if (!hardwareInstancedRendering) {\r\n                renderingMesh._bind(subMesh, effect, material.fillMode);\r\n            }\r\n\r\n            this.getTransformMatrix(); // make sure _cachedDirection et _cachedPosition are up to date\r\n\r\n            effect.setFloat3(\"biasAndScaleSM\", this.bias, this.normalBias, this.depthScale);\r\n\r\n            if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                effect.setVector3(\"lightDataSM\", this._cachedDirection);\r\n            } else {\r\n                effect.setVector3(\"lightDataSM\", this._cachedPosition);\r\n            }\r\n\r\n            const camera = this._getCamera();\r\n            effect.setFloat2(\"depthValuesSM\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera));\r\n\r\n            if (isTransparent && this.enableSoftTransparentShadow) {\r\n                effect.setFloat2(\"softTransparentShadowSM\", effectiveMesh.visibility * material.alpha, this._opacityTexture?.getAlphaFromRGB ? 1 : 0);\r\n            }\r\n\r\n            if (shadowDepthWrapper) {\r\n                subMesh._setMainDrawWrapperOverride(drawWrapper);\r\n                if (shadowDepthWrapper.standalone) {\r\n                    shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);\r\n                } else {\r\n                    material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);\r\n                }\r\n                subMesh._setMainDrawWrapperOverride(null);\r\n            } else {\r\n                // Alpha test\r\n                if (this._opacityTexture) {\r\n                    effect.setTexture(\"diffuseSampler\", this._opacityTexture);\r\n                    effect.setMatrix(\"diffuseMatrix\", this._opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    const skeleton = renderingMesh.skeleton;\r\n\r\n                    if (skeleton.isUsingTextureForMatrices) {\r\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n\r\n                        if (!boneTexture) {\r\n                            return;\r\n                        }\r\n\r\n                        effect.setTexture(\"boneSampler\", boneTexture);\r\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                    } else {\r\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Baked vertex animations\r\n                const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;\r\n                if (bvaManager && bvaManager.isEnabled) {\r\n                    bvaManager.bind(effect, hardwareInstancedRendering);\r\n                }\r\n\r\n                // Clip planes\r\n                bindClipPlane(effect, material, scene);\r\n            }\r\n\r\n            if (!this._useUBO && !shadowDepthWrapper) {\r\n                this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, effectiveMesh);\r\n            }\r\n\r\n            BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());\r\n            this._scene.getSceneUniformBuffer().bindUniformBuffer();\r\n\r\n            const world = effectiveMesh.getWorldMatrix();\r\n\r\n            // In the non hardware instanced mode, the Mesh ubo update is done by the callback passed to renderingMesh._processRendering (see below)\r\n            if (hardwareInstancedRendering) {\r\n                effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                effectiveMesh.transferToEffect(world);\r\n            }\r\n\r\n            if (this.forceBackFacesOnly) {\r\n                engine.setState(true, 0, false, true, material.cullBackFaces);\r\n            }\r\n\r\n            // Observables\r\n            this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);\r\n            this.onBeforeShadowMapRenderObservable.notifyObservers(effect);\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, worldOverride) => {\r\n                if (effectiveMesh !== renderingMesh && !isInstance) {\r\n                    renderingMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                    renderingMesh.transferToEffect(worldOverride);\r\n                } else {\r\n                    effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                    effectiveMesh.transferToEffect(isInstance ? worldOverride : world);\r\n                }\r\n            });\r\n\r\n            if (this.forceBackFacesOnly) {\r\n                engine.setState(true, 0, false, false, material.cullBackFaces);\r\n            }\r\n\r\n            // Observables\r\n            this.onAfterShadowMapRenderObservable.notifyObservers(effect);\r\n            this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);\r\n        } else {\r\n            // Need to reset refresh rate of the shadowMap\r\n            if (this._shadowMap) {\r\n                this._shadowMap.resetRefreshCounter();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _applyFilterValues(): void {\r\n        if (!this._shadowMap) {\r\n            return;\r\n        }\r\n\r\n        if (this.filter === ShadowGenerator.FILTER_NONE || this.filter === ShadowGenerator.FILTER_PCSS) {\r\n            this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);\r\n        } else {\r\n            this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.\r\n     * @param onCompiled Callback triggered at the and of the effects compilation\r\n     * @param options Sets of optional options forcing the compilation with different modes\r\n     */\r\n    public forceCompilation(onCompiled?: (generator: IShadowGenerator) => void, options?: Partial<{ useInstances: boolean }>): void {\r\n        const localOptions = {\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        const shadowMap = this.getShadowMap();\r\n        if (!shadowMap) {\r\n            if (onCompiled) {\r\n                onCompiled(this);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const renderList = shadowMap.renderList;\r\n        if (!renderList) {\r\n            if (onCompiled) {\r\n                onCompiled(this);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const subMeshes: SubMesh[] = [];\r\n        for (const mesh of renderList) {\r\n            subMeshes.push(...mesh.subMeshes);\r\n        }\r\n        if (subMeshes.length === 0) {\r\n            if (onCompiled) {\r\n                onCompiled(this);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let currentIndex = 0;\r\n\r\n        const checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            while (\r\n                this.isReady(\r\n                    subMeshes[currentIndex],\r\n                    localOptions.useInstances,\r\n                    subMeshes[currentIndex].getMaterial()?.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh()) ?? false\r\n                )\r\n            ) {\r\n                currentIndex++;\r\n                if (currentIndex >= subMeshes.length) {\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            setTimeout(checkReady, 16);\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.\r\n     * @param options Sets of optional options forcing the compilation with different modes\r\n     * @returns A promise that resolves when the compilation completes\r\n     */\r\n    public forceCompilationAsync(options?: Partial<{ useInstances: boolean }>): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.forceCompilation(() => {\r\n                resolve();\r\n            }, options);\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _isReadyCustomDefines(defines: any, subMesh: SubMesh, useInstances: boolean): void {}\r\n\r\n    private _prepareShadowDefines(subMesh: SubMesh, useInstances: boolean, defines: string[], isTransparent: boolean): string[] {\r\n        defines.push(\"#define SM_LIGHTTYPE_\" + this._light.getClassName().toUpperCase());\r\n\r\n        defines.push(\"#define SM_FLOAT \" + (this._textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE ? \"1\" : \"0\"));\r\n\r\n        defines.push(\"#define SM_ESM \" + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? \"1\" : \"0\"));\r\n\r\n        defines.push(\"#define SM_DEPTHTEXTURE \" + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? \"1\" : \"0\"));\r\n\r\n        const mesh = subMesh.getMesh();\r\n\r\n        // Normal bias.\r\n        defines.push(\"#define SM_NORMALBIAS \" + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? \"1\" : \"0\"));\r\n        defines.push(\"#define SM_DIRECTIONINLIGHTDATA \" + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? \"1\" : \"0\"));\r\n\r\n        // Point light\r\n        defines.push(\"#define SM_USEDISTANCE \" + (this._light.needCube() ? \"1\" : \"0\"));\r\n\r\n        // Soft transparent shadows\r\n        defines.push(\"#define SM_SOFTTRANSPARENTSHADOW \" + (this.enableSoftTransparentShadow && isTransparent ? \"1\" : \"0\"));\r\n\r\n        this._isReadyCustomDefines(defines, subMesh, useInstances);\r\n\r\n        return defines;\r\n    }\r\n\r\n    /**\r\n     * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).\r\n     * @param subMesh The submesh we want to render in the shadow map\r\n     * @param useInstances Defines whether will draw in the map using instances\r\n     * @param isTransparent Indicates that isReady is called for a transparent subMesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean, isTransparent: boolean): boolean {\r\n        if (!this._shadersLoaded) {\r\n            return false;\r\n        }\r\n\r\n        const material = subMesh.getMaterial(),\r\n            shadowDepthWrapper = material?.shadowDepthWrapper;\r\n\r\n        this._opacityTexture = null;\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        const defines: string[] = [];\r\n\r\n        this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);\r\n\r\n        if (shadowDepthWrapper) {\r\n            if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {\r\n                return false;\r\n            }\r\n        } else {\r\n            const subMeshEffect = subMesh._getDrawWrapper(undefined, true)!;\r\n\r\n            let effect = subMeshEffect.effect!;\r\n            let cachedDefines = subMeshEffect.defines;\r\n\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            const mesh = subMesh.getMesh();\r\n\r\n            let useNormal = false;\r\n            let uv1 = false;\r\n            let uv2 = false;\r\n            const color = false;\r\n\r\n            // Normal bias.\r\n            if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n                defines.push(\"#define NORMAL\");\r\n                useNormal = true;\r\n                if (mesh.nonUniformScaling) {\r\n                    defines.push(\"#define NONUNIFORMSCALING\");\r\n                }\r\n            }\r\n\r\n            // Alpha test\r\n            const needAlphaTesting = material.needAlphaTestingForMesh(mesh);\r\n\r\n            if (needAlphaTesting || material.needAlphaBlendingForMesh(mesh)) {\r\n                if (this.useOpacityTextureForTransparentShadow) {\r\n                    this._opacityTexture = (material as any).opacityTexture;\r\n                } else {\r\n                    this._opacityTexture = material.getAlphaTestTexture();\r\n                }\r\n                if (this._opacityTexture) {\r\n                    if (!this._opacityTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n\r\n                    const alphaCutOff = (material as any).alphaCutOff ?? ShadowGenerator.DEFAULT_ALPHA_CUTOFF;\r\n\r\n                    defines.push(\"#define ALPHATEXTURE\");\r\n                    if (needAlphaTesting) {\r\n                        defines.push(`#define ALPHATESTVALUE ${alphaCutOff}${alphaCutOff % 1 === 0 ? \".\" : \"\"}`);\r\n                    }\r\n                    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                        attribs.push(VertexBuffer.UVKind);\r\n                        defines.push(\"#define UV1\");\r\n                        uv1 = true;\r\n                    }\r\n                    if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                        if (this._opacityTexture.coordinatesIndex === 1) {\r\n                            attribs.push(VertexBuffer.UV2Kind);\r\n                            defines.push(\"#define UV2\");\r\n                            uv2 = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Bones\r\n            const fallbacks = new EffectFallbacks();\r\n            if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n                attribs.push(VertexBuffer.MatricesIndicesKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsKind);\r\n                if (mesh.numBoneInfluencers > 4) {\r\n                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n                }\r\n                const skeleton = mesh.skeleton;\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n                if (mesh.numBoneInfluencers > 0) {\r\n                    fallbacks.addCPUSkinningFallback(0, mesh);\r\n                }\r\n\r\n                if (skeleton.isUsingTextureForMatrices) {\r\n                    defines.push(\"#define BONETEXTURE\");\r\n                } else {\r\n                    defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n                }\r\n            } else {\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n            }\r\n\r\n            // Morph targets\r\n            const numMorphInfluencers = mesh.morphTargetManager\r\n                ? PrepareDefinesAndAttributesForMorphTargets(\r\n                      mesh.morphTargetManager,\r\n                      defines,\r\n                      attribs,\r\n                      mesh,\r\n                      true, // usePositionMorph\r\n                      useNormal, // useNormalMorph\r\n                      false, // useTangentMorph\r\n                      uv1, // useUVMorph\r\n                      uv2, // useUV2Morph\r\n                      color // useColorMorph\r\n                  )\r\n                : 0;\r\n\r\n            // ClipPlanes\r\n            prepareStringDefinesForClipPlanes(material, this._scene, defines);\r\n\r\n            // Instances\r\n            if (useInstances) {\r\n                defines.push(\"#define INSTANCES\");\r\n                PushAttributesForInstances(attribs);\r\n                if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                    defines.push(\"#define THIN_INSTANCES\");\r\n                }\r\n            }\r\n\r\n            if (this.customShaderOptions) {\r\n                if (this.customShaderOptions.defines) {\r\n                    for (const define of this.customShaderOptions.defines) {\r\n                        if (defines.indexOf(define) === -1) {\r\n                            defines.push(define);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Baked vertex animations\r\n            const bvaManager = mesh.bakedVertexAnimationManager;\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (useInstances) {\r\n                    attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n                }\r\n            }\r\n\r\n            // Get correct effect\r\n            const join = defines.join(\"\\n\");\r\n            if (cachedDefines !== join) {\r\n                cachedDefines = join;\r\n\r\n                let shaderName = \"shadowMap\";\r\n                const uniforms = [\r\n                    \"world\",\r\n                    \"mBones\",\r\n                    \"viewProjection\",\r\n                    \"diffuseMatrix\",\r\n                    \"lightDataSM\",\r\n                    \"depthValuesSM\",\r\n                    \"biasAndScaleSM\",\r\n                    \"morphTargetInfluences\",\r\n                    \"morphTargetCount\",\r\n                    \"boneTextureWidth\",\r\n                    \"softTransparentShadowSM\",\r\n                    \"morphTargetTextureInfo\",\r\n                    \"morphTargetTextureIndices\",\r\n                    \"bakedVertexAnimationSettings\",\r\n                    \"bakedVertexAnimationTextureSizeInverted\",\r\n                    \"bakedVertexAnimationTime\",\r\n                    \"bakedVertexAnimationTexture\",\r\n                ];\r\n                const samplers = [\"diffuseSampler\", \"boneSampler\", \"morphTargets\", \"bakedVertexAnimationTexture\"];\r\n                const uniformBuffers = [\"Scene\", \"Mesh\"];\r\n\r\n                addClipPlaneUniforms(uniforms);\r\n\r\n                // Custom shader?\r\n                if (this.customShaderOptions) {\r\n                    shaderName = this.customShaderOptions.shaderName;\r\n\r\n                    if (this.customShaderOptions.attributes) {\r\n                        for (const attrib of this.customShaderOptions.attributes) {\r\n                            if (attribs.indexOf(attrib) === -1) {\r\n                                attribs.push(attrib);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (this.customShaderOptions.uniforms) {\r\n                        for (const uniform of this.customShaderOptions.uniforms) {\r\n                            if (uniforms.indexOf(uniform) === -1) {\r\n                                uniforms.push(uniform);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (this.customShaderOptions.samplers) {\r\n                        for (const sampler of this.customShaderOptions.samplers) {\r\n                            if (samplers.indexOf(sampler) === -1) {\r\n                                samplers.push(sampler);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const engine = this._scene.getEngine();\r\n\r\n                effect = engine.createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: null,\r\n                        onError: null,\r\n                        indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                        shaderLanguage: this._shaderLanguage,\r\n                    },\r\n                    engine\r\n                );\r\n\r\n                subMeshEffect.setEffect(effect, cachedDefines);\r\n            }\r\n\r\n            if (!effect.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {\r\n            if (!this._blurPostProcesses || !this._blurPostProcesses.length) {\r\n                this._initializeBlurRTTAndPostProcesses();\r\n            }\r\n        }\r\n\r\n        if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {\r\n            return false;\r\n        }\r\n        if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {\r\n            return false;\r\n        }\r\n        if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\r\n     * @param defines Defines of the material we want to update\r\n     * @param lightIndex Index of the light in the enabled light list of the material\r\n     */\r\n    public prepareDefines(defines: any, lightIndex: number): void {\r\n        const scene = this._scene;\r\n        const light = this._light;\r\n\r\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\r\n            return;\r\n        }\r\n\r\n        defines[\"SHADOW\" + lightIndex] = true;\r\n\r\n        if (this.useContactHardeningShadow) {\r\n            defines[\"SHADOWPCSS\" + lightIndex] = true;\r\n            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {\r\n                defines[\"SHADOWLOWQUALITY\" + lightIndex] = true;\r\n            } else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {\r\n                defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = true;\r\n            }\r\n            // else default to high.\r\n        } else if (this.usePercentageCloserFiltering) {\r\n            defines[\"SHADOWPCF\" + lightIndex] = true;\r\n            if (this._filteringQuality === ShadowGenerator.QUALITY_LOW) {\r\n                defines[\"SHADOWLOWQUALITY\" + lightIndex] = true;\r\n            } else if (this._filteringQuality === ShadowGenerator.QUALITY_MEDIUM) {\r\n                defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = true;\r\n            }\r\n            // else default to high.\r\n        } else if (this.usePoissonSampling) {\r\n            defines[\"SHADOWPOISSON\" + lightIndex] = true;\r\n        } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {\r\n            defines[\"SHADOWESM\" + lightIndex] = true;\r\n        } else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {\r\n            defines[\"SHADOWCLOSEESM\" + lightIndex] = true;\r\n        }\r\n\r\n        if (light.needCube()) {\r\n            defines[\"SHADOWCUBE\" + lightIndex] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\r\n     * defined in the generator but impacting the effect).\r\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\r\n     * @param effect The effect we are binding the information for\r\n     */\r\n    public bindShadowLight(lightIndex: string, effect: Effect): void {\r\n        const light = this._light;\r\n        const scene = this._scene;\r\n\r\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\r\n            return;\r\n        }\r\n\r\n        const camera = this._getCamera();\r\n        const shadowMap = this.getShadowMap();\r\n\r\n        if (!shadowMap) {\r\n            return;\r\n        }\r\n\r\n        if (!light.needCube()) {\r\n            effect.setMatrix(\"lightMatrix\" + lightIndex, this.getTransformMatrix());\r\n        }\r\n\r\n        // Only PCF uses depth stencil texture.\r\n        const shadowMapForRendering = this.getShadowMapForRendering();\r\n        if (this._filter === ShadowGenerator.FILTER_PCF) {\r\n            effect.setDepthStencilTexture(\"shadowTexture\" + lightIndex, shadowMapForRendering);\r\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);\r\n        } else if (this._filter === ShadowGenerator.FILTER_PCSS) {\r\n            effect.setDepthStencilTexture(\"shadowTexture\" + lightIndex, shadowMapForRendering);\r\n            effect.setTexture(\"depthTexture\" + lightIndex, shadowMapForRendering);\r\n            light._uniformBuffer.updateFloat4(\r\n                \"shadowsInfo\",\r\n                this.getDarkness(),\r\n                1 / shadowMap.getSize().width,\r\n                this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width,\r\n                this.frustumEdgeFalloff,\r\n                lightIndex\r\n            );\r\n        } else {\r\n            effect.setTexture(\"shadowTexture\" + lightIndex, shadowMapForRendering);\r\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);\r\n        }\r\n\r\n        light._uniformBuffer.updateFloat2(\r\n            \"depthValues\",\r\n            this.getLight().getDepthMinZ(camera),\r\n            this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera),\r\n            lightIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the view matrix used to render the shadow map.\r\n     */\r\n    public get viewMatrix() {\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the projection matrix used to render the shadow map.\r\n     */\r\n    public get projectionMatrix() {\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the transformation matrix used to project the meshes into the map from the light point of view.\r\n     * (eq to shadow projection matrix * light transform matrix)\r\n     * @returns The transform matrix used to create the shadow map\r\n     */\r\n    public getTransformMatrix(): Matrix {\r\n        const scene = this._scene;\r\n        if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {\r\n            return this._transformMatrix;\r\n        }\r\n\r\n        this._currentRenderId = scene.getRenderId();\r\n        this._currentFaceIndexCache = this._currentFaceIndex;\r\n\r\n        let lightPosition = this._light.position;\r\n        if (this._light.computeTransformedInformation()) {\r\n            lightPosition = this._light.transformedPosition;\r\n        }\r\n\r\n        Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);\r\n        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\r\n            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\r\n        }\r\n\r\n        if (\r\n            this._light.needProjectionMatrixCompute() ||\r\n            !this._cachedPosition ||\r\n            !this._cachedDirection ||\r\n            !lightPosition.equals(this._cachedPosition) ||\r\n            !this._lightDirection.equals(this._cachedDirection)\r\n        ) {\r\n            this._cachedPosition.copyFrom(lightPosition);\r\n            this._cachedDirection.copyFrom(this._lightDirection);\r\n\r\n            Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);\r\n\r\n            const shadowMap = this.getShadowMap();\r\n\r\n            if (shadowMap) {\r\n                const renderList = shadowMap.renderList;\r\n\r\n                if (renderList) {\r\n                    this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);\r\n                }\r\n            }\r\n\r\n            this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\r\n        }\r\n\r\n        return this._transformMatrix;\r\n    }\r\n\r\n    /**\r\n     * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between\r\n     * Cube and 2D textures for instance.\r\n     */\r\n    public recreateShadowMap(): void {\r\n        const shadowMap = this._shadowMap;\r\n        if (!shadowMap) {\r\n            return;\r\n        }\r\n\r\n        // Track render list.\r\n        const renderList = shadowMap.renderList;\r\n        // Clean up existing data.\r\n        this._disposeRTTandPostProcesses();\r\n        // Reinitializes.\r\n        this._initializeGenerator();\r\n        // Reaffect the filter to ensure a correct fallback if necessary.\r\n        this.filter = this._filter;\r\n        // Reaffect the filter.\r\n        this._applyFilterValues();\r\n        // Reaffect Render List.\r\n        if (renderList) {\r\n            // Note: don't do this._shadowMap!.renderList = renderList;\r\n            // The renderList hooked array is accessing the old RenderTargetTexture (see RenderTargetTexture._hookArray), which is disposed at this point (by the call to _disposeRTTandPostProcesses)\r\n            if (!this._shadowMap!.renderList) {\r\n                this._shadowMap!.renderList = [];\r\n            }\r\n            for (const mesh of renderList) {\r\n                this._shadowMap!.renderList.push(mesh);\r\n            }\r\n        } else {\r\n            this._shadowMap!.renderList = null;\r\n        }\r\n    }\r\n\r\n    protected _disposeBlurPostProcesses(): void {\r\n        if (this._shadowMap2) {\r\n            this._shadowMap2.dispose();\r\n            this._shadowMap2 = null;\r\n        }\r\n\r\n        if (this._boxBlurPostprocess) {\r\n            this._boxBlurPostprocess.dispose();\r\n            this._boxBlurPostprocess = null;\r\n        }\r\n\r\n        if (this._kernelBlurXPostprocess) {\r\n            this._kernelBlurXPostprocess.dispose();\r\n            this._kernelBlurXPostprocess = null;\r\n        }\r\n\r\n        if (this._kernelBlurYPostprocess) {\r\n            this._kernelBlurYPostprocess.dispose();\r\n            this._kernelBlurYPostprocess = null;\r\n        }\r\n\r\n        this._blurPostProcesses = [];\r\n    }\r\n\r\n    protected _disposeRTTandPostProcesses(): void {\r\n        if (this._shadowMap) {\r\n            this._shadowMap.dispose();\r\n            this._shadowMap = null;\r\n        }\r\n\r\n        this._disposeBlurPostProcesses();\r\n    }\r\n\r\n    protected _disposeSceneUBOs(): void {\r\n        if (this._sceneUBOs) {\r\n            for (const ubo of this._sceneUBOs) {\r\n                ubo.dispose();\r\n            }\r\n            this._sceneUBOs = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the ShadowGenerator.\r\n     * Returns nothing.\r\n     */\r\n    public dispose(): void {\r\n        this._disposeRTTandPostProcesses();\r\n\r\n        this._disposeSceneUBOs();\r\n\r\n        if (this._light) {\r\n            if (this._light._shadowGenerators) {\r\n                const iterator = this._light._shadowGenerators.entries();\r\n                for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\r\n                    const [camera, shadowGenerator] = entry.value;\r\n                    if (shadowGenerator === this) {\r\n                        this._light._shadowGenerators.delete(camera);\r\n                    }\r\n                }\r\n                if (this._light._shadowGenerators.size === 0) {\r\n                    this._light._shadowGenerators = null;\r\n                }\r\n            }\r\n            this._light._markMeshesAsLightDirty();\r\n        }\r\n\r\n        this.onBeforeShadowMapRenderMeshObservable.clear();\r\n        this.onBeforeShadowMapRenderObservable.clear();\r\n        this.onAfterShadowMapRenderMeshObservable.clear();\r\n        this.onAfterShadowMapRenderObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the shadow generator setup to a json object.\r\n     * @returns The serialized JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        const shadowMap = this.getShadowMap();\r\n\r\n        if (!shadowMap) {\r\n            return serializationObject;\r\n        }\r\n\r\n        serializationObject.className = this.getClassName();\r\n        serializationObject.lightId = this._light.id;\r\n        serializationObject.cameraId = this._camera?.id;\r\n        serializationObject.id = this.id;\r\n        serializationObject.mapSize = shadowMap.getRenderSize();\r\n        serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;\r\n        serializationObject.darkness = this.getDarkness();\r\n        serializationObject.transparencyShadow = this._transparencyShadow;\r\n        serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;\r\n        serializationObject.bias = this.bias;\r\n        serializationObject.normalBias = this.normalBias;\r\n        serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;\r\n        serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;\r\n        serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;\r\n        serializationObject.filteringQuality = this.filteringQuality;\r\n        serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;\r\n        serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;\r\n        serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;\r\n        serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;\r\n        serializationObject.usePoissonSampling = this.usePoissonSampling;\r\n        serializationObject.depthScale = this.depthScale;\r\n        serializationObject.blurBoxOffset = this.blurBoxOffset;\r\n        serializationObject.blurKernel = this.blurKernel;\r\n        serializationObject.blurScale = this.blurScale;\r\n        serializationObject.useKernelBlur = this.useKernelBlur;\r\n\r\n        serializationObject.renderList = [];\r\n        if (shadowMap.renderList) {\r\n            for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\r\n                const mesh = shadowMap.renderList[meshIndex];\r\n\r\n                serializationObject.renderList.push(mesh.id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\r\n     * @param parsedShadowGenerator The JSON object to parse\r\n     * @param scene The scene to create the shadow map for\r\n     * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator\r\n     * @returns The parsed shadow generator\r\n     */\r\n    public static Parse(parsedShadowGenerator: any, scene: Scene, constr?: (mapSize: number, light: IShadowLight, camera: Nullable<Camera>) => ShadowGenerator): ShadowGenerator {\r\n        const light = <IShadowLight>scene.getLightById(parsedShadowGenerator.lightId);\r\n        const camera: Nullable<Camera> = parsedShadowGenerator.cameraId !== undefined ? scene.getCameraById(parsedShadowGenerator.cameraId) : null;\r\n        const shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light, camera) : new ShadowGenerator(parsedShadowGenerator.mapSize, light, undefined, camera);\r\n        const shadowMap = shadowGenerator.getShadowMap();\r\n\r\n        for (let meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {\r\n            const meshes = scene.getMeshesById(parsedShadowGenerator.renderList[meshIndex]);\r\n            meshes.forEach(function (mesh) {\r\n                if (!shadowMap) {\r\n                    return;\r\n                }\r\n                if (!shadowMap.renderList) {\r\n                    shadowMap.renderList = [];\r\n                }\r\n                shadowMap.renderList.push(mesh);\r\n            });\r\n        }\r\n\r\n        if (parsedShadowGenerator.id !== undefined) {\r\n            shadowGenerator.id = parsedShadowGenerator.id;\r\n        }\r\n\r\n        shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;\r\n\r\n        if (parsedShadowGenerator.darkness !== undefined) {\r\n            shadowGenerator.setDarkness(parsedShadowGenerator.darkness);\r\n        }\r\n\r\n        if (parsedShadowGenerator.transparencyShadow) {\r\n            shadowGenerator.setTransparencyShadow(true);\r\n        }\r\n\r\n        if (parsedShadowGenerator.frustumEdgeFalloff !== undefined) {\r\n            shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;\r\n        }\r\n\r\n        if (parsedShadowGenerator.bias !== undefined) {\r\n            shadowGenerator.bias = parsedShadowGenerator.bias;\r\n        }\r\n\r\n        if (parsedShadowGenerator.normalBias !== undefined) {\r\n            shadowGenerator.normalBias = parsedShadowGenerator.normalBias;\r\n        }\r\n\r\n        if (parsedShadowGenerator.usePercentageCloserFiltering) {\r\n            shadowGenerator.usePercentageCloserFiltering = true;\r\n        } else if (parsedShadowGenerator.useContactHardeningShadow) {\r\n            shadowGenerator.useContactHardeningShadow = true;\r\n        } else if (parsedShadowGenerator.usePoissonSampling) {\r\n            shadowGenerator.usePoissonSampling = true;\r\n        } else if (parsedShadowGenerator.useExponentialShadowMap) {\r\n            shadowGenerator.useExponentialShadowMap = true;\r\n        } else if (parsedShadowGenerator.useBlurExponentialShadowMap) {\r\n            shadowGenerator.useBlurExponentialShadowMap = true;\r\n        } else if (parsedShadowGenerator.useCloseExponentialShadowMap) {\r\n            shadowGenerator.useCloseExponentialShadowMap = true;\r\n        } else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {\r\n            shadowGenerator.useBlurCloseExponentialShadowMap = true;\r\n        }\r\n        // Backward compat\r\n        else if (parsedShadowGenerator.useVarianceShadowMap) {\r\n            shadowGenerator.useExponentialShadowMap = true;\r\n        } else if (parsedShadowGenerator.useBlurVarianceShadowMap) {\r\n            shadowGenerator.useBlurExponentialShadowMap = true;\r\n        }\r\n\r\n        if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== undefined) {\r\n            shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;\r\n        }\r\n\r\n        if (parsedShadowGenerator.filteringQuality !== undefined) {\r\n            shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;\r\n        }\r\n\r\n        if (parsedShadowGenerator.depthScale) {\r\n            shadowGenerator.depthScale = parsedShadowGenerator.depthScale;\r\n        }\r\n\r\n        if (parsedShadowGenerator.blurScale) {\r\n            shadowGenerator.blurScale = parsedShadowGenerator.blurScale;\r\n        }\r\n\r\n        if (parsedShadowGenerator.blurBoxOffset) {\r\n            shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;\r\n        }\r\n\r\n        if (parsedShadowGenerator.useKernelBlur) {\r\n            shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;\r\n        }\r\n\r\n        if (parsedShadowGenerator.blurKernel) {\r\n            shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;\r\n        }\r\n\r\n        return shadowGenerator;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/depth.fragment\";\r\nimport \"../Shaders/depth.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { BindBonesParameters, BindMorphTargetParameters, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances } from \"../Materials/materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport type { IEffectCreationOptions } from \"core/Materials\";\r\n\r\n/**\r\n * This represents a depth renderer in Babylon.\r\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\r\n */\r\nexport class DepthRenderer {\r\n    private _scene: Scene;\r\n    private _depthMap: RenderTargetTexture;\r\n    private readonly _storeNonLinearDepth: boolean;\r\n    private readonly _storeCameraSpaceZ: boolean;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * Force all the depth renderer to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /** Color used to clear the depth texture. Default: (1,0,0,1) */\r\n    public clearColor: Color4;\r\n\r\n    /** Get if the depth renderer is using packed depth or not */\r\n    public readonly isPacked: boolean;\r\n\r\n    private _camera: Nullable<Camera>;\r\n\r\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\r\n    public enabled = true;\r\n\r\n    /** Force writing the transparent objects into the depth map */\r\n    public forceDepthWriteTransparentMeshes = false;\r\n\r\n    /**\r\n     * Specifies that the depth renderer will only be used within\r\n     * the camera it is created for.\r\n     * This can help forcing its rendering during the camera processing.\r\n     */\r\n    public useOnlyInActiveCamera: boolean = false;\r\n\r\n    /** If true, reverse the culling of materials before writing to the depth texture.\r\n     * So, basically, when \"true\", back facing instead of front facing faces are rasterized into the texture\r\n     */\r\n    public reverseCulling = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"DepthRendererSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._depthMap.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a depth renderer\r\n     * @param scene The scene the renderer belongs to\r\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\r\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\r\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)\r\n     * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\r\n     * @param name Name of the render target (default: DepthRenderer)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        type: number = Constants.TEXTURETYPE_FLOAT,\r\n        camera: Nullable<Camera> = null,\r\n        storeNonLinearDepth = false,\r\n        samplingMode = Texture.TRILINEAR_SAMPLINGMODE,\r\n        storeCameraSpaceZ = false,\r\n        name?: string\r\n    ) {\r\n        this._scene = scene;\r\n        this._storeNonLinearDepth = storeNonLinearDepth;\r\n        this._storeCameraSpaceZ = storeCameraSpaceZ;\r\n        this.isPacked = type === Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this.isPacked) {\r\n            this.clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this.clearColor = new Color4(storeCameraSpaceZ ? 1e8 : 1.0, 0.0, 0.0, 1.0);\r\n        }\r\n\r\n        this._initShaderSourceAsync();\r\n\r\n        DepthRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._camera = camera;\r\n\r\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\r\n            if (type === Constants.TEXTURETYPE_FLOAT && !engine._caps.textureFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n            if (type === Constants.TEXTURETYPE_HALF_FLOAT && !engine._caps.textureHalfFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n        }\r\n\r\n        // Render target\r\n        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_R;\r\n        this._depthMap = new RenderTargetTexture(\r\n            name ?? \"DepthRenderer\",\r\n            { width: engine.getRenderWidth(), height: engine.getRenderHeight() },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            type,\r\n            false,\r\n            samplingMode,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            format\r\n        );\r\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.refreshRate = 1;\r\n        this._depthMap.renderParticles = false;\r\n        this._depthMap.renderList = null;\r\n        this._depthMap.noPrePassRenderer = true;\r\n\r\n        // Camera to get depth map from to support multiple concurrent cameras\r\n        this._depthMap.activeCamera = this._camera;\r\n        this._depthMap.ignoreCameraViewport = true;\r\n        this._depthMap.useCameraPostProcesses = false;\r\n\r\n        // set default depth value to 1.0 (far away)\r\n        this._depthMap.onClearObservable.add((engine) => {\r\n            engine.clear(this.clearColor, true, true, true);\r\n        });\r\n\r\n        this._depthMap.onBeforeBindObservable.add(() => {\r\n            engine._debugPushGroup?.(\"depth renderer\", 1);\r\n        });\r\n\r\n        this._depthMap.onAfterUnbindObservable.add(() => {\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        this._depthMap.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering =\r\n                        engine.getCaps().instancedArrays &&\r\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            const scene = this._scene;\r\n            const engine = scene.getEngine();\r\n            const material = subMesh.getMaterial();\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\r\n                return;\r\n            }\r\n\r\n            // Culling\r\n            const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\r\n            let sideOrientation = material._getEffectiveOrientation(renderingMesh);\r\n\r\n            if (detNeg) {\r\n                sideOrientation =\r\n                    sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation\r\n                        ? Constants.MATERIAL_CounterClockWiseSideOrientation\r\n                        : Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n            const reverseSideOrientation = sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering =\r\n                engine.getCaps().instancedArrays &&\r\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n            const camera = this._camera || scene.activeCamera;\r\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\r\n                subMesh._renderId = scene.getRenderId();\r\n\r\n                const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n                let drawWrapper = subMesh._getDrawWrapper();\r\n                if (!drawWrapper && renderingMaterial) {\r\n                    drawWrapper = renderingMaterial._getDrawWrapper();\r\n                }\r\n                const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (!renderingMaterial) {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                    if (this._storeCameraSpaceZ) {\r\n                        effect.setMatrix(\"view\", scene.getViewMatrix());\r\n                    }\r\n                } else {\r\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n                }\r\n\r\n                let minZ: number, maxZ: number;\r\n\r\n                if (cameraIsOrtho) {\r\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                } else {\r\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\r\n                }\r\n\r\n                effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\r\n\r\n                if (!renderingMaterial) {\r\n                    // Alpha test\r\n                    if (material.needAlphaTestingForMesh(effectiveMesh)) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    BindBonesParameters(renderingMesh, effect);\r\n\r\n                    // Clip planes\r\n                    bindClipPlane(effect, material, scene);\r\n\r\n                    // Morph targets\r\n                    BindMorphTargetParameters(renderingMesh, effect);\r\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                        renderingMesh.morphTargetManager._bind(effect);\r\n                    }\r\n\r\n                    // Baked vertex animations\r\n                    const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;\r\n                    if (bvaManager && bvaManager.isEnabled) {\r\n                        bvaManager.bind(effect, hardwareInstancedRendering);\r\n                    }\r\n\r\n                    // Points cloud rendering\r\n                    if (material.pointsCloud) {\r\n                        effect.setFloat(\"pointSize\", material.pointSize);\r\n                    }\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                    effect.setMatrix(\"world\", world)\r\n                );\r\n            }\r\n        };\r\n\r\n        this._depthMap.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            let index;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (this.forceDepthWriteTransparentMeshes) {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    renderSubMesh(transparentSubMeshes.data[index]);\r\n                }\r\n            } else {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private _shadersLoaded = false;\r\n    private async _initShaderSourceAsync(forceGLSL = false) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        if (engine.isWebGPU && !forceGLSL && !DepthRenderer.ForceGLSL) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n\r\n            await Promise.all([import(\"../ShadersWGSL/depth.vertex\"), import(\"../ShadersWGSL/depth.fragment\")]);\r\n        } else {\r\n            await Promise.all([import(\"../Shaders/depth.vertex\"), import(\"../Shaders/depth.fragment\")]);\r\n        }\r\n\r\n        this._shadersLoaded = true;\r\n    }\r\n\r\n    /**\r\n     * Creates the depth rendering effect and checks if the effect is ready.\r\n     * @param subMesh The submesh to be used to render the depth map of\r\n     * @param useInstances If multiple world instances should be used\r\n     * @returns if the depth renderer is ready to render the depth map\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        if (!this._shadersLoaded) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n        const scene = mesh.getScene();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        if (!material || material.disableDepthWrite) {\r\n            return false;\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n        const color = false;\r\n\r\n        // Alpha test\r\n        if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {\r\n            defines.push(\"#define ALPHATEST\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n                uv1 = true;\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n                uv2 = true;\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const numMorphInfluencers = mesh.morphTargetManager\r\n            ? PrepareDefinesAndAttributesForMorphTargets(\r\n                  mesh.morphTargetManager,\r\n                  defines,\r\n                  attribs,\r\n                  mesh,\r\n                  true, // usePositionMorph\r\n                  false, // useNormalMorph\r\n                  false, // useTangentMorph\r\n                  uv1, // useUVMorph\r\n                  uv2, // useUV2Morph\r\n                  color // useColorMorph\r\n              )\r\n            : 0;\r\n\r\n        // Points cloud rendering\r\n        if (material.pointsCloud) {\r\n            defines.push(\"#define POINTSIZE\");\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Baked vertex animations\r\n        const bvaManager = mesh.bakedVertexAnimationManager;\r\n        if (bvaManager && bvaManager.isEnabled) {\r\n            defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n            if (useInstances) {\r\n                attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n            }\r\n        }\r\n\r\n        // None linear depth\r\n        if (this._storeNonLinearDepth) {\r\n            defines.push(\"#define NONLINEARDEPTH\");\r\n        }\r\n\r\n        // Store camera space Z coordinate instead of NDC Z\r\n        if (this._storeCameraSpaceZ) {\r\n            defines.push(\"#define STORE_CAMERASPACE_Z\");\r\n        }\r\n\r\n        // Float Mode\r\n        if (this.isPacked) {\r\n            defines.push(\"#define PACKED\");\r\n        }\r\n\r\n        // Clip planes\r\n        prepareStringDefinesForClipPlanes(material, scene, defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"boneTextureWidth\",\r\n                \"pointSize\",\r\n                \"viewProjection\",\r\n                \"view\",\r\n                \"diffuseMatrix\",\r\n                \"depthValues\",\r\n                \"morphTargetInfluences\",\r\n                \"morphTargetCount\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n                \"bakedVertexAnimationSettings\",\r\n                \"bakedVertexAnimationTextureSizeInverted\",\r\n                \"bakedVertexAnimationTime\",\r\n                \"bakedVertexAnimationTexture\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\", \"morphTargets\", \"boneSampler\", \"bakedVertexAnimationTexture\"];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                engine.createEffect(\r\n                    \"depth\",\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: [],\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: null,\r\n                        onError: null,\r\n                        indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                        shaderLanguage: this._shaderLanguage,\r\n                    },\r\n                    engine\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture which the depth map will be written to.\r\n     * @returns The depth map texture\r\n     */\r\n    public getDepthMap(): RenderTargetTexture {\r\n        return this._depthMap;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the depth renderer.\r\n     */\r\n    public dispose(): void {\r\n        const keysToDelete = [];\r\n        for (const key in this._scene._depthRenderer) {\r\n            const depthRenderer = this._scene._depthRenderer[key];\r\n            if (depthRenderer === this) {\r\n                keysToDelete.push(key);\r\n            }\r\n        }\r\n\r\n        if (keysToDelete.length > 0) {\r\n            this._depthMap.dispose();\r\n\r\n            for (const key of keysToDelete) {\r\n                delete this._scene._depthRenderer[key];\r\n            }\r\n        }\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"minmaxReduxPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform sampler2D sourceTexture;uniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(sourceTexture,coord,0).r;float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;float minz=min(min(min(f1,f2),f3),f4);\n#ifdef DEPTH_REDUX\nfloat maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#else\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(f1.x,f2.x);float maxz=max(f1.y,f2.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\nvoid main(void)\n{glFragColor=vec4(0.);if (true) { \ndiscard;}}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const minmaxReduxPixelShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Observer } from \"./observable\";\r\nimport { Observable } from \"./observable\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { PostProcessManager } from \"../PostProcesses/postProcessManager\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\nimport \"../Shaders/minmaxRedux.fragment\";\r\n\r\n/**\r\n * This class computes a min/max reduction from a texture: it means it computes the minimum\r\n * and maximum values from all values of the texture.\r\n * It is performed on the GPU for better performances, thanks to a succession of post processes.\r\n * The source values are read from the red channel of the texture.\r\n */\r\nexport class MinMaxReducer {\r\n    /**\r\n     * Observable triggered when the computation has been performed\r\n     */\r\n    public onAfterReductionPerformed = new Observable<{ min: number; max: number }>();\r\n\r\n    protected _camera: Camera;\r\n    protected _sourceTexture: Nullable<RenderTargetTexture>;\r\n    protected _reductionSteps: Nullable<Array<PostProcess>>;\r\n    protected _postProcessManager: PostProcessManager;\r\n    protected _onAfterUnbindObserver: Nullable<Observer<RenderTargetTexture>>;\r\n    protected _forceFullscreenViewport = true;\r\n    protected _onContextRestoredObserver: Nullable<Observer<AbstractEngine>>;\r\n\r\n    /**\r\n     * Creates a min/max reducer\r\n     * @param camera The camera to use for the post processes\r\n     */\r\n    constructor(camera: Camera) {\r\n        this._camera = camera;\r\n        this._postProcessManager = new PostProcessManager(camera.getScene());\r\n\r\n        this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {\r\n            this._postProcessManager._rebuild();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used to read the values from.\r\n     */\r\n    public get sourceTexture(): Nullable<RenderTargetTexture> {\r\n        return this._sourceTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the source texture to read the values from.\r\n     * One must indicate if the texture is a depth texture or not through the depthRedux parameter\r\n     * because in such textures '1' value must not be taken into account to compute the maximum\r\n     * as this value is used to clear the texture.\r\n     * Note that the computation is not activated by calling this function, you must call activate() for that!\r\n     * @param sourceTexture The texture to read the values from. The values should be in the red channel.\r\n     * @param depthRedux Indicates if the texture is a depth texture or not\r\n     * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)\r\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\r\n     */\r\n    public setSourceTexture(sourceTexture: RenderTargetTexture, depthRedux: boolean, type: number = Constants.TEXTURETYPE_HALF_FLOAT, forceFullscreenViewport = true): void {\r\n        if (sourceTexture === this._sourceTexture) {\r\n            return;\r\n        }\r\n\r\n        this.dispose(false);\r\n\r\n        this._sourceTexture = sourceTexture;\r\n        this._reductionSteps = [];\r\n        this._forceFullscreenViewport = forceFullscreenViewport;\r\n\r\n        const scene = this._camera.getScene();\r\n\r\n        // create the first step\r\n        const reductionInitial = new PostProcess(\r\n            \"Initial reduction phase\",\r\n            \"minmaxRedux\", // shader\r\n            [\"texSize\"],\r\n            [\"sourceTexture\"], // textures\r\n            1.0, // options\r\n            null, // camera\r\n            Constants.TEXTURE_NEAREST_NEAREST, // sampling\r\n            scene.getEngine(), // engine\r\n            false, // reusable\r\n            \"#define INITIAL\" + (depthRedux ? \"\\n#define DEPTH_REDUX\" : \"\"), // defines\r\n            type,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            Constants.TEXTUREFORMAT_RG\r\n        );\r\n\r\n        reductionInitial.autoClear = false;\r\n        reductionInitial.forceFullscreenViewport = forceFullscreenViewport;\r\n\r\n        let w = this._sourceTexture.getRenderWidth(),\r\n            h = this._sourceTexture.getRenderHeight();\r\n\r\n        reductionInitial.onApply = ((w: number, h: number) => {\r\n            return (effect: Effect) => {\r\n                effect.setTexture(\"sourceTexture\", this._sourceTexture);\r\n                effect.setFloat2(\"texSize\", w, h);\r\n            };\r\n        })(w, h);\r\n\r\n        this._reductionSteps.push(reductionInitial);\r\n\r\n        let index = 1;\r\n\r\n        // create the additional steps\r\n        while (w > 1 || h > 1) {\r\n            w = Math.max(Math.round(w / 2), 1);\r\n            h = Math.max(Math.round(h / 2), 1);\r\n\r\n            const reduction = new PostProcess(\r\n                \"Reduction phase \" + index,\r\n                \"minmaxRedux\", // shader\r\n                [\"texSize\"],\r\n                null,\r\n                { width: w, height: h }, // options\r\n                null, // camera\r\n                Constants.TEXTURE_NEAREST_NEAREST, // sampling\r\n                scene.getEngine(), // engine\r\n                false, // reusable\r\n                \"#define \" + (w == 1 && h == 1 ? \"LAST\" : w == 1 || h == 1 ? \"ONEBEFORELAST\" : \"MAIN\"), // defines\r\n                type,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                Constants.TEXTUREFORMAT_RG\r\n            );\r\n\r\n            reduction.autoClear = false;\r\n            reduction.forceFullscreenViewport = forceFullscreenViewport;\r\n\r\n            reduction.onApply = ((w: number, h: number) => {\r\n                return (effect: Effect) => {\r\n                    if (w == 1 || h == 1) {\r\n                        effect.setInt2(\"texSize\", w, h);\r\n                    } else {\r\n                        effect.setFloat2(\"texSize\", w, h);\r\n                    }\r\n                };\r\n            })(w, h);\r\n\r\n            this._reductionSteps.push(reduction);\r\n\r\n            index++;\r\n\r\n            if (w == 1 && h == 1) {\r\n                const func = (w: number, h: number, reduction: PostProcess) => {\r\n                    const buffer = new Float32Array(4 * w * h),\r\n                        minmax = { min: 0, max: 0 };\r\n                    return () => {\r\n                        scene.getEngine()._readTexturePixels(reduction.inputTexture.texture!, w, h, -1, 0, buffer, false);\r\n                        minmax.min = buffer[0];\r\n                        minmax.max = buffer[1];\r\n                        this.onAfterReductionPerformed.notifyObservers(minmax);\r\n                    };\r\n                };\r\n                reduction.onAfterRenderObservable.add(func(w, h, reduction));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refresh rate of the computation.\r\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._sourceTexture ? this._sourceTexture.refreshRate : -1;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        if (this._sourceTexture) {\r\n            this._sourceTexture.refreshRate = value;\r\n        }\r\n    }\r\n\r\n    protected _activated = false;\r\n\r\n    /**\r\n     * Gets the activation status of the reducer\r\n     */\r\n    public get activated(): boolean {\r\n        return this._activated;\r\n    }\r\n\r\n    /**\r\n     * Activates the reduction computation.\r\n     * When activated, the observers registered in onAfterReductionPerformed are\r\n     * called after the computation is performed\r\n     */\r\n    public activate(): void {\r\n        if (this._onAfterUnbindObserver || !this._sourceTexture) {\r\n            return;\r\n        }\r\n\r\n        this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {\r\n            const engine = this._camera.getScene().getEngine();\r\n            engine._debugPushGroup?.(`min max reduction`, 1);\r\n            this._reductionSteps![0].activate(this._camera);\r\n            this._postProcessManager.directRender(this._reductionSteps!, this._reductionSteps![0].inputTexture, this._forceFullscreenViewport);\r\n            engine.unBindFramebuffer(this._reductionSteps![0].inputTexture, false);\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        this._activated = true;\r\n    }\r\n\r\n    /**\r\n     * Deactivates the reduction computation.\r\n     */\r\n    public deactivate(): void {\r\n        if (!this._onAfterUnbindObserver || !this._sourceTexture) {\r\n            return;\r\n        }\r\n\r\n        this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\r\n        this._onAfterUnbindObserver = null;\r\n        this._activated = false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the min/max reducer\r\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\r\n     */\r\n    public dispose(disposeAll = true): void {\r\n        if (disposeAll) {\r\n            this.onAfterReductionPerformed.clear();\r\n\r\n            if (this._onContextRestoredObserver) {\r\n                this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n                this._onContextRestoredObserver = null;\r\n            }\r\n        }\r\n\r\n        this.deactivate();\r\n\r\n        if (this._reductionSteps) {\r\n            for (let i = 0; i < this._reductionSteps.length; ++i) {\r\n                this._reductionSteps[i].dispose();\r\n            }\r\n            this._reductionSteps = null;\r\n        }\r\n\r\n        if (this._postProcessManager && disposeAll) {\r\n            this._postProcessManager.dispose();\r\n        }\r\n\r\n        this._sourceTexture = null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { DepthRenderer } from \"../Rendering/depthRenderer\";\r\n\r\nimport { MinMaxReducer } from \"./minMaxReducer\";\r\n\r\n/**\r\n * This class is a small wrapper around the MinMaxReducer class to compute the min/max values of a depth texture\r\n */\r\nexport class DepthReducer extends MinMaxReducer {\r\n    private _depthRenderer: Nullable<DepthRenderer>;\r\n    private _depthRendererId: string;\r\n\r\n    /**\r\n     * Gets the depth renderer used for the computation.\r\n     * Note that the result is null if you provide your own renderer when calling setDepthRenderer.\r\n     */\r\n    public get depthRenderer(): Nullable<DepthRenderer> {\r\n        return this._depthRenderer;\r\n    }\r\n\r\n    /**\r\n     * Creates a depth reducer\r\n     * @param camera The camera used to render the depth texture\r\n     */\r\n    constructor(camera: Camera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Sets the depth renderer to use to generate the depth map\r\n     * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically\r\n     * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)\r\n     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)\r\n     */\r\n    public setDepthRenderer(depthRenderer: Nullable<DepthRenderer> = null, type: number = Constants.TEXTURETYPE_HALF_FLOAT, forceFullscreenViewport = true): void {\r\n        const scene = this._camera.getScene();\r\n\r\n        if (this._depthRenderer) {\r\n            delete scene._depthRenderer[this._depthRendererId];\r\n\r\n            this._depthRenderer.dispose();\r\n            this._depthRenderer = null;\r\n        }\r\n\r\n        if (depthRenderer === null) {\r\n            if (!scene._depthRenderer) {\r\n                scene._depthRenderer = {};\r\n            }\r\n\r\n            depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n            depthRenderer.enabled = false;\r\n\r\n            this._depthRendererId = \"minmax\" + this._camera.id;\r\n            scene._depthRenderer[this._depthRendererId] = depthRenderer;\r\n        }\r\n\r\n        super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override setSourceTexture(\r\n        sourceTexture: RenderTargetTexture,\r\n        depthRedux: boolean,\r\n        type: number = Constants.TEXTURETYPE_HALF_FLOAT,\r\n        forceFullscreenViewport = true\r\n    ): void {\r\n        super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);\r\n    }\r\n\r\n    /**\r\n     * Activates the reduction computation.\r\n     * When activated, the observers registered in onAfterReductionPerformed are\r\n     * called after the computation is performed\r\n     */\r\n    public override activate(): void {\r\n        if (this._depthRenderer) {\r\n            this._depthRenderer.enabled = true;\r\n        }\r\n\r\n        super.activate();\r\n    }\r\n\r\n    /**\r\n     * Deactivates the reduction computation.\r\n     */\r\n    public override deactivate(): void {\r\n        super.deactivate();\r\n\r\n        if (this._depthRenderer) {\r\n            this._depthRenderer.enabled = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the depth reducer\r\n     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.\r\n     */\r\n    public override dispose(disposeAll = true): void {\r\n        super.dispose(disposeAll);\r\n\r\n        if (this._depthRenderer && disposeAll) {\r\n            const scene = this._depthRenderer.getDepthMap().getScene();\r\n            if (scene) {\r\n                delete scene._depthRenderer[this._depthRendererId];\r\n            }\r\n\r\n            this._depthRenderer.dispose();\r\n            this._depthRenderer = null;\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\n\r\nimport type { IShadowLight } from \"../../Lights/shadowLight\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\n\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport type { DirectionalLight } from \"../directionalLight\";\r\n\r\nimport { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { DepthRenderer } from \"../../Rendering/depthRenderer\";\r\nimport { DepthReducer } from \"../../Misc/depthReducer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\n\r\ninterface ICascade {\r\n    prevBreakDistance: number;\r\n    breakDistance: number;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst UpDir = Vector3.Up();\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst ZeroVec = Vector3.Zero();\r\n\r\nconst tmpv1 = new Vector3(),\r\n    tmpv2 = new Vector3(),\r\n    tmpMatrix = new Matrix();\r\n\r\n/**\r\n * A CSM implementation allowing casting shadows on large scenes.\r\n * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\r\n * Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/\r\n */\r\nexport class CascadedShadowGenerator extends ShadowGenerator {\r\n    private static readonly _FrustumCornersNDCSpace = [\r\n        new Vector3(-1.0, +1.0, -1.0),\r\n        new Vector3(+1.0, +1.0, -1.0),\r\n        new Vector3(+1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, +1.0, +1.0),\r\n        new Vector3(+1.0, +1.0, +1.0),\r\n        new Vector3(+1.0, -1.0, +1.0),\r\n        new Vector3(-1.0, -1.0, +1.0),\r\n    ];\r\n\r\n    /**\r\n     * Name of the CSM class\r\n     */\r\n    public static override CLASSNAME = \"CascadedShadowGenerator\";\r\n\r\n    /**\r\n     * Defines the default number of cascades used by the CSM.\r\n     */\r\n    public static readonly DEFAULT_CASCADES_COUNT = 4;\r\n    /**\r\n     * Defines the minimum number of cascades used by the CSM.\r\n     */\r\n    public static MIN_CASCADES_COUNT = 2;\r\n    /**\r\n     * Defines the maximum number of cascades used by the CSM.\r\n     */\r\n    public static MAX_CASCADES_COUNT = 4;\r\n\r\n    protected override _validateFilter(filter: number): number {\r\n        if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {\r\n            return filter;\r\n        }\r\n\r\n        Logger.Error('Unsupported filter \"' + filter + '\"!');\r\n\r\n        return ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the actual darkness of the soft shadows while using PCSS filtering (value between 0. and 1.)\r\n     */\r\n    public penumbraDarkness: number;\r\n\r\n    private _numCascades: number;\r\n\r\n    /**\r\n     * Gets or set the number of cascades used by the CSM.\r\n     */\r\n    public get numCascades(): number {\r\n        return this._numCascades;\r\n    }\r\n\r\n    public set numCascades(value: number) {\r\n        value = Math.min(Math.max(value, CascadedShadowGenerator.MIN_CASCADES_COUNT), CascadedShadowGenerator.MAX_CASCADES_COUNT);\r\n        if (value === this._numCascades) {\r\n            return;\r\n        }\r\n\r\n        this._numCascades = value;\r\n        this.recreateShadowMap();\r\n        this._recreateSceneUBOs();\r\n    }\r\n\r\n    /**\r\n     * Sets this to true if you want that the edges of the shadows don't \"swimm\" / \"shimmer\" when rotating the camera.\r\n     * The trade off is that you lose some precision in the shadow rendering when enabling this setting.\r\n     */\r\n    public stabilizeCascades: boolean;\r\n\r\n    private _freezeShadowCastersBoundingInfo: boolean;\r\n    private _freezeShadowCastersBoundingInfoObservable: Nullable<Observer<Scene>>;\r\n\r\n    /**\r\n     * Enables or disables the shadow casters bounding info computation.\r\n     * If your shadow casters don't move, you can disable this feature.\r\n     * If it is enabled, the bounding box computation is done every frame.\r\n     */\r\n    public get freezeShadowCastersBoundingInfo(): boolean {\r\n        return this._freezeShadowCastersBoundingInfo;\r\n    }\r\n\r\n    public set freezeShadowCastersBoundingInfo(freeze: boolean) {\r\n        if (this._freezeShadowCastersBoundingInfoObservable && freeze) {\r\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\r\n            this._freezeShadowCastersBoundingInfoObservable = null;\r\n        }\r\n\r\n        if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {\r\n            this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(() => this._computeShadowCastersBoundingInfo());\r\n        }\r\n\r\n        this._freezeShadowCastersBoundingInfo = freeze;\r\n\r\n        if (freeze) {\r\n            this._computeShadowCastersBoundingInfo();\r\n        }\r\n    }\r\n\r\n    private _scbiMin: Vector3;\r\n    private _scbiMax: Vector3;\r\n\r\n    protected _computeShadowCastersBoundingInfo(): void {\r\n        this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._scbiMax.copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        if (this._shadowMap && this._shadowMap.renderList) {\r\n            const renderList = this._shadowMap.renderList;\r\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                const mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo(),\r\n                    boundingBox = boundingInfo.boundingBox;\r\n\r\n                this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\r\n                this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\r\n            }\r\n        }\r\n\r\n        this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);\r\n    }\r\n\r\n    protected _shadowCastersBoundingInfo: BoundingInfo;\r\n\r\n    /**\r\n     * Gets or sets the shadow casters bounding info.\r\n     * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo\r\n     * so that the system won't overwrite the bounds you provide\r\n     */\r\n    public get shadowCastersBoundingInfo(): BoundingInfo {\r\n        return this._shadowCastersBoundingInfo;\r\n    }\r\n\r\n    public set shadowCastersBoundingInfo(boundingInfo: BoundingInfo) {\r\n        this._shadowCastersBoundingInfo = boundingInfo;\r\n    }\r\n\r\n    protected _breaksAreDirty: boolean;\r\n\r\n    protected _minDistance: number;\r\n    protected _maxDistance: number;\r\n\r\n    /**\r\n     * Sets the minimal and maximal distances to use when computing the cascade breaks.\r\n     *\r\n     * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.\r\n     * If you don't know these values, simply leave them to their defaults and don't call this function.\r\n     * @param min minimal distance for the breaks (default to 0.)\r\n     * @param max maximal distance for the breaks (default to 1.)\r\n     */\r\n    public setMinMaxDistance(min: number, max: number): void {\r\n        if (this._minDistance === min && this._maxDistance === max) {\r\n            return;\r\n        }\r\n\r\n        if (min > max) {\r\n            min = 0;\r\n            max = 1;\r\n        }\r\n\r\n        if (min < 0) {\r\n            min = 0;\r\n        }\r\n\r\n        if (max > 1) {\r\n            max = 1;\r\n        }\r\n\r\n        this._minDistance = min;\r\n        this._maxDistance = max;\r\n        this._breaksAreDirty = true;\r\n    }\r\n\r\n    /** Gets the minimal distance used in the cascade break computation */\r\n    public get minDistance(): number {\r\n        return this._minDistance;\r\n    }\r\n\r\n    /** Gets the maximal distance used in the cascade break computation */\r\n    public get maxDistance(): number {\r\n        return this._maxDistance;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of that object\r\n     * @returns \"CascadedShadowGenerator\"\r\n     */\r\n    public override getClassName(): string {\r\n        return CascadedShadowGenerator.CLASSNAME;\r\n    }\r\n\r\n    private _cascadeMinExtents: Array<Vector3>;\r\n    private _cascadeMaxExtents: Array<Vector3>;\r\n\r\n    /**\r\n     * Gets a cascade minimum extents\r\n     * @param cascadeIndex index of the cascade\r\n     * @returns the minimum cascade extents\r\n     */\r\n    public getCascadeMinExtents(cascadeIndex: number): Nullable<Vector3> {\r\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;\r\n    }\r\n\r\n    /**\r\n     * Gets a cascade maximum extents\r\n     * @param cascadeIndex index of the cascade\r\n     * @returns the maximum cascade extents\r\n     */\r\n    public getCascadeMaxExtents(cascadeIndex: number): Nullable<Vector3> {\r\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;\r\n    }\r\n\r\n    private _cascades: Array<ICascade>;\r\n    private _currentLayer: number;\r\n    private _viewSpaceFrustumsZ: Array<number>;\r\n    private _viewMatrices: Array<Matrix>;\r\n    private _projectionMatrices: Array<Matrix>;\r\n    private _transformMatrices: Array<Matrix>;\r\n    private _transformMatricesAsArray: Float32Array;\r\n    private _frustumLengths: Array<number>;\r\n    private _lightSizeUVCorrection: Array<number>;\r\n    private _depthCorrection: Array<number>;\r\n    private _frustumCornersWorldSpace: Array<Array<Vector3>>;\r\n    private _frustumCenter: Array<Vector3>;\r\n    private _shadowCameraPos: Array<Vector3>;\r\n\r\n    private _shadowMaxZ: number;\r\n    /**\r\n     * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.\r\n     * It defaults to camera.maxZ\r\n     */\r\n    public get shadowMaxZ(): number {\r\n        if (!this._getCamera()) {\r\n            return 0;\r\n        }\r\n        return this._shadowMaxZ;\r\n    }\r\n    /**\r\n     * Sets the shadow max z distance.\r\n     */\r\n    public set shadowMaxZ(value: number) {\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            this._shadowMaxZ = value;\r\n            return;\r\n        }\r\n        if (this._shadowMaxZ === value || value < camera.minZ || (value > camera.maxZ && camera.maxZ !== 0)) {\r\n            return;\r\n        }\r\n        this._shadowMaxZ = value;\r\n        this._light._markMeshesAsLightDirty();\r\n        this._breaksAreDirty = true;\r\n    }\r\n\r\n    protected _debug: boolean;\r\n\r\n    /**\r\n     * Gets or sets the debug flag.\r\n     * When enabled, the cascades are materialized by different colors on the screen.\r\n     */\r\n    public get debug(): boolean {\r\n        return this._debug;\r\n    }\r\n\r\n    public set debug(dbg: boolean) {\r\n        this._debug = dbg;\r\n        this._light._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _depthClamp: boolean;\r\n\r\n    /**\r\n     * Gets or sets the depth clamping value.\r\n     *\r\n     * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted\r\n     * to account for the shadow casters far away.\r\n     *\r\n     * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.\r\n     */\r\n    public get depthClamp(): boolean {\r\n        return this._depthClamp;\r\n    }\r\n\r\n    public set depthClamp(value: boolean) {\r\n        this._depthClamp = value;\r\n    }\r\n\r\n    private _cascadeBlendPercentage: number;\r\n\r\n    /**\r\n     * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).\r\n     * It defaults to 0.1 (10% blending).\r\n     */\r\n    public get cascadeBlendPercentage(): number {\r\n        return this._cascadeBlendPercentage;\r\n    }\r\n\r\n    public set cascadeBlendPercentage(value: number) {\r\n        this._cascadeBlendPercentage = value;\r\n        this._light._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _lambda: number;\r\n\r\n    /**\r\n     * Gets or set the lambda parameter.\r\n     * This parameter is used to split the camera frustum and create the cascades.\r\n     * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.\r\n     * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.\r\n     */\r\n    public get lambda(): number {\r\n        return this._lambda;\r\n    }\r\n\r\n    public set lambda(value: number) {\r\n        const lambda = Math.min(Math.max(value, 0), 1);\r\n        if (this._lambda == lambda) {\r\n            return;\r\n        }\r\n        this._lambda = lambda;\r\n        this._breaksAreDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the view matrix corresponding to a given cascade\r\n     * @param cascadeNum cascade to retrieve the view matrix from\r\n     * @returns the cascade view matrix\r\n     */\r\n    public getCascadeViewMatrix(cascadeNum: number): Nullable<Matrix> {\r\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the projection matrix corresponding to a given cascade\r\n     * @param cascadeNum cascade to retrieve the projection matrix from\r\n     * @returns the cascade projection matrix\r\n     */\r\n    public getCascadeProjectionMatrix(cascadeNum: number): Nullable<Matrix> {\r\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the transformation matrix corresponding to a given cascade\r\n     * @param cascadeNum cascade to retrieve the transformation matrix from\r\n     * @returns the cascade transformation matrix\r\n     */\r\n    public getCascadeTransformMatrix(cascadeNum: number): Nullable<Matrix> {\r\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;\r\n    }\r\n\r\n    private _depthRenderer: Nullable<DepthRenderer>;\r\n    /**\r\n     * Sets the depth renderer to use when autoCalcDepthBounds is enabled.\r\n     *\r\n     * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.\r\n     *\r\n     * You should call this function if you already have a depth renderer enabled in your scene, to avoid\r\n     * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!\r\n     * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created\r\n     */\r\n    public setDepthRenderer(depthRenderer: Nullable<DepthRenderer>): void {\r\n        this._depthRenderer = depthRenderer;\r\n\r\n        if (this._depthReducer) {\r\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\r\n        }\r\n    }\r\n\r\n    private _depthReducer: Nullable<DepthReducer>;\r\n    private _autoCalcDepthBounds: boolean;\r\n\r\n    /**\r\n     * Gets or sets the autoCalcDepthBounds property.\r\n     *\r\n     * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one\r\n     * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the\r\n     * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.\r\n     * It can greatly enhance the shadow quality, at the expense of more GPU works.\r\n     * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.\r\n     */\r\n    public get autoCalcDepthBounds(): boolean {\r\n        return this._autoCalcDepthBounds;\r\n    }\r\n\r\n    public set autoCalcDepthBounds(value: boolean) {\r\n        const camera = this._getCamera();\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        this._autoCalcDepthBounds = value;\r\n\r\n        if (!value) {\r\n            if (this._depthReducer) {\r\n                this._depthReducer.deactivate();\r\n            }\r\n            this.setMinMaxDistance(0, 1);\r\n            return;\r\n        }\r\n\r\n        if (!this._depthReducer) {\r\n            this._depthReducer = new DepthReducer(camera);\r\n            this._depthReducer.onAfterReductionPerformed.add((minmax: { min: number; max: number }) => {\r\n                let min = minmax.min,\r\n                    max = minmax.max;\r\n                if (min >= max) {\r\n                    min = 0;\r\n                    max = 1;\r\n                }\r\n                if (min != this._minDistance || max != this._maxDistance) {\r\n                    this.setMinMaxDistance(min, max);\r\n                }\r\n            });\r\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\r\n        }\r\n\r\n        this._depthReducer.activate();\r\n    }\r\n\r\n    /**\r\n     * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true\r\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\r\n     * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible\r\n     * for setting the refresh rate on the renderer yourself!\r\n     */\r\n    public get autoCalcDepthBoundsRefreshRate(): number {\r\n        return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate ?? -1;\r\n    }\r\n\r\n    public set autoCalcDepthBoundsRefreshRate(value: number) {\r\n        if (this._depthReducer?.depthRenderer) {\r\n            this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.\r\n     * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if\r\n     * you change the camera near/far planes!\r\n     */\r\n    public splitFrustum(): void {\r\n        this._breaksAreDirty = true;\r\n    }\r\n\r\n    private _splitFrustum(): void {\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        const near = camera.minZ,\r\n            far = camera.maxZ || this._shadowMaxZ, // account for infinite far plane (ie. maxZ = 0)\r\n            cameraRange = far - near,\r\n            minDistance = this._minDistance,\r\n            maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;\r\n\r\n        const minZ = near + minDistance * cameraRange,\r\n            maxZ = near + maxDistance * cameraRange;\r\n\r\n        const range = maxZ - minZ,\r\n            ratio = maxZ / minZ;\r\n\r\n        for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {\r\n            const p = (cascadeIndex + 1) / this._numCascades,\r\n                log = minZ * ratio ** p,\r\n                uniform = minZ + range * p;\r\n\r\n            const d = this._lambda * (log - uniform) + uniform;\r\n\r\n            this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;\r\n            this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;\r\n\r\n            this._viewSpaceFrustumsZ[cascadeIndex] = d;\r\n            this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;\r\n        }\r\n\r\n        this._breaksAreDirty = false;\r\n    }\r\n\r\n    private _computeMatrices(): void {\r\n        const scene = this._scene;\r\n\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);\r\n        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\r\n            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\r\n        }\r\n\r\n        this._cachedDirection.copyFrom(this._lightDirection);\r\n\r\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\r\n\r\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\r\n            this._computeFrustumInWorldSpace(cascadeIndex);\r\n            this._computeCascadeFrustum(cascadeIndex);\r\n\r\n            this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1); // tmpv1 = cascadeExtents\r\n\r\n            // Get position of the shadow camera\r\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);\r\n\r\n            // Come up with a new orthographic camera for the shadow caster\r\n            Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);\r\n\r\n            // Z extents of the current cascade, in cascade view coordinate system\r\n            let viewMinZ = 0,\r\n                viewMaxZ = tmpv1.z;\r\n\r\n            // Try to tighten minZ and maxZ based on the bounding box of the shadow casters\r\n            const boundingInfo = this._shadowCastersBoundingInfo;\r\n\r\n            boundingInfo.update(this._viewMatrices[cascadeIndex]);\r\n            // Note that after the call to update, the boundingInfo properties that are identified as \"world\" coordinates are in fact view coordinates for the current cascade!\r\n            // This is because the boundingInfo properties that are identifed as \"local\" are in fact world coordinates (see _computeShadowCastersBoundingInfo()), and we multiply them by the current cascade view matrix when we call update.\r\n\r\n            const castersViewMinZ = boundingInfo.boundingBox.minimumWorld.z;\r\n            const castersViewMaxZ = boundingInfo.boundingBox.maximumWorld.z;\r\n\r\n            if (castersViewMinZ > viewMaxZ) {\r\n                // Do nothing, keep the current z extents.\r\n                // All the casters are too far from the light to have an impact on the current cascade.\r\n                // Possible optimization: skip the rendering of the shadow map for this cascade, as all the casters will be clipped by the GPU anyway.\r\n            } else {\r\n                if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {\r\n                    // If we don't use depth clamping, we must define minZ so that all shadow casters are in the cascade frustum\r\n                    viewMinZ = Math.min(viewMinZ, castersViewMinZ);\r\n\r\n                    if (this.filter !== ShadowGenerator.FILTER_PCSS) {\r\n                        // We do not need the actual distance between the currently shaded pixel and the occluder when generating shadows, so we can lower the far plane to increase the accuracy of the shadow map.\r\n                        viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);\r\n                    }\r\n                } else {\r\n                    // If we use depth clamping (but not PCSS!), we can adjust minZ/maxZ to reduce the range [minZ, maxZ] (and obtain additional precision in the shadow map)\r\n                    viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);\r\n\r\n                    // Thanks to depth clamping, casters won't be Z clipped even if they fall outside the [-1,1] range, so we can move the near plane to 0 if castersViewMinZ < 0.\r\n                    // We will generate negative Z values in the shadow map, but that's okay (they will be clamped to the 0..1 range anyway), except in PCSS case\r\n                    // where we need the actual distance between the currently shader pixel and the occluder: that's why we don't use depth clamping in PCSS case.\r\n                    viewMinZ = Math.max(viewMinZ, castersViewMinZ);\r\n\r\n                    // If all the casters are behind the near plane of the cascade, minZ = 0 due to the previous line, and maxZ < 0 at this point.\r\n                    // We need to make sure that maxZ > minZ, so in this case we set maxZ a little higher than minZ. As we are using depth clamping, the casters won't be Z clipped, so we just need to make sure that we have a valid Z range for the cascade.\r\n                    // Having a 0 range is not ok, due to undefined behavior in the calculation in this case.\r\n                    viewMaxZ = Math.max(viewMinZ + 1.0, viewMaxZ);\r\n                }\r\n            }\r\n\r\n            Matrix.OrthoOffCenterLHToRef(\r\n                this._cascadeMinExtents[cascadeIndex].x,\r\n                this._cascadeMaxExtents[cascadeIndex].x,\r\n                this._cascadeMinExtents[cascadeIndex].y,\r\n                this._cascadeMaxExtents[cascadeIndex].y,\r\n                useReverseDepthBuffer ? viewMaxZ : viewMinZ,\r\n                useReverseDepthBuffer ? viewMinZ : viewMaxZ,\r\n                this._projectionMatrices[cascadeIndex],\r\n                scene.getEngine().isNDCHalfZRange\r\n            );\r\n\r\n            this._cascadeMinExtents[cascadeIndex].z = viewMinZ;\r\n            this._cascadeMaxExtents[cascadeIndex].z = viewMaxZ;\r\n\r\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\r\n\r\n            // Create the rounding matrix, by projecting the world-space origin and determining\r\n            // the fractional offset in texel space\r\n            Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1); // tmpv1 = shadowOrigin\r\n            tmpv1.scaleInPlace(this._mapSize / 2);\r\n\r\n            tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z)); // tmpv2 = roundedOrigin\r\n            tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize); // tmpv2 = roundOffset\r\n\r\n            Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0.0, tmpMatrix);\r\n\r\n            this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix, this._projectionMatrices[cascadeIndex]);\r\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\r\n\r\n            this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);\r\n        }\r\n    }\r\n\r\n    // Get the 8 points of the view frustum in world space\r\n    private _computeFrustumInWorldSpace(cascadeIndex: number): void {\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance,\r\n            splitDist = this._cascades[cascadeIndex].breakDistance;\r\n\r\n        const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;\r\n\r\n        camera.getViewMatrix(); // make sure the transformation matrix we get when calling 'getTransformationMatrix()' is calculated with an up to date view matrix\r\n\r\n        const cameraInfiniteFarPlane = camera.maxZ === 0;\r\n        const saveCameraMaxZ = camera.maxZ;\r\n\r\n        if (cameraInfiniteFarPlane) {\r\n            camera.maxZ = this._shadowMaxZ;\r\n            camera.getProjectionMatrix(true);\r\n        }\r\n\r\n        const invViewProj = Matrix.Invert(camera.getTransformationMatrix());\r\n\r\n        if (cameraInfiniteFarPlane) {\r\n            camera.maxZ = saveCameraMaxZ;\r\n            camera.getProjectionMatrix(true);\r\n        }\r\n\r\n        const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;\r\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++cornerIndex) {\r\n            tmpv1.copyFrom(CascadedShadowGenerator._FrustumCornersNDCSpace[(cornerIndex + cornerIndexOffset) % CascadedShadowGenerator._FrustumCornersNDCSpace.length]);\r\n            if (isNDCHalfZRange && tmpv1.z === -1) {\r\n                tmpv1.z = 0;\r\n            }\r\n            Vector3.TransformCoordinatesToRef(tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\r\n        }\r\n\r\n        // Get the corners of the current cascade slice of the view frustum\r\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length / 2; ++cornerIndex) {\r\n            tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\r\n            tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist); // near corner ray\r\n            tmpv1.scaleInPlace(splitDist); // far corner ray\r\n\r\n            tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\r\n\r\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);\r\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);\r\n        }\r\n    }\r\n\r\n    private _computeCascadeFrustum(cascadeIndex: number): void {\r\n        this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cascadeMaxExtents[cascadeIndex].copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n        this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);\r\n\r\n        const camera = this._getCamera();\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        // Calculate the centroid of the view frustum slice\r\n        for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\r\n            this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\r\n        }\r\n\r\n        this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);\r\n\r\n        if (this.stabilizeCascades) {\r\n            // Calculate the radius of a bounding sphere surrounding the frustum corners\r\n            let sphereRadius = 0;\r\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\r\n                const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();\r\n                sphereRadius = Math.max(sphereRadius, dist);\r\n            }\r\n\r\n            sphereRadius = Math.ceil(sphereRadius * 16) / 16;\r\n\r\n            this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);\r\n            this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);\r\n        } else {\r\n            // Create a temporary view matrix for the light\r\n            const lightCameraPos = this._frustumCenter[cascadeIndex];\r\n\r\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1); // tmpv1 = look at\r\n\r\n            Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix); // matrix = lightView\r\n\r\n            // Calculate an AABB around the frustum corners\r\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\r\n                Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix, tmpv1);\r\n\r\n                this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);\r\n                this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _recreateSceneUBOs(): void {\r\n        this._disposeSceneUBOs();\r\n        if (this._sceneUBOs) {\r\n            for (let i = 0; i < this._numCascades; ++i) {\r\n                this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light \"${this._light.name}\" cascade #${i})`));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Support test.\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            return false;\r\n        }\r\n        return engine._features.supportCSM;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"ShadowGeneratorSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Creates a Cascaded Shadow Generator object.\r\n     * A ShadowGenerator is the required tool to use the shadows.\r\n     * Each directional light casting shadows needs to use its own ShadowGenerator.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\r\n     * @param mapSize The size of the texture what stores the shadows. Example : 1024.\r\n     * @param light The directional light object generating the shadows.\r\n     * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\r\n     * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\r\n     * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: true)\r\n     */\r\n    constructor(mapSize: number, light: DirectionalLight, usefulFloatFirst?: boolean, camera?: Nullable<Camera>, useRedTextureType = true) {\r\n        if (!CascadedShadowGenerator.IsSupported) {\r\n            Logger.Error(\"CascadedShadowMap is not supported by the current engine.\");\r\n            return;\r\n        }\r\n\r\n        super(mapSize, light, usefulFloatFirst, camera, useRedTextureType);\r\n\r\n        this.usePercentageCloserFiltering = true;\r\n    }\r\n\r\n    protected override _initializeGenerator(): void {\r\n        this.penumbraDarkness = this.penumbraDarkness ?? 1.0;\r\n        this._numCascades = this._numCascades ?? CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;\r\n        this.stabilizeCascades = this.stabilizeCascades ?? false;\r\n        this._freezeShadowCastersBoundingInfoObservable = this._freezeShadowCastersBoundingInfoObservable ?? null;\r\n        this.freezeShadowCastersBoundingInfo = this.freezeShadowCastersBoundingInfo ?? false;\r\n        this._scbiMin = this._scbiMin ?? new Vector3(0, 0, 0);\r\n        this._scbiMax = this._scbiMax ?? new Vector3(0, 0, 0);\r\n        this._shadowCastersBoundingInfo = this._shadowCastersBoundingInfo ?? new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        this._breaksAreDirty = this._breaksAreDirty ?? true;\r\n        this._minDistance = this._minDistance ?? 0;\r\n        this._maxDistance = this._maxDistance ?? 1;\r\n        this._currentLayer = this._currentLayer ?? 0;\r\n        this._shadowMaxZ = this._shadowMaxZ ?? this._getCamera()?.maxZ ?? 10000;\r\n        this._debug = this._debug ?? false;\r\n        this._depthClamp = this._depthClamp ?? true;\r\n        this._cascadeBlendPercentage = this._cascadeBlendPercentage ?? 0.1;\r\n        this._lambda = this._lambda ?? 0.5;\r\n        this._autoCalcDepthBounds = this._autoCalcDepthBounds ?? false;\r\n\r\n        this._recreateSceneUBOs();\r\n\r\n        super._initializeGenerator();\r\n    }\r\n\r\n    protected override _createTargetRenderTexture(): void {\r\n        const engine = this._scene.getEngine();\r\n        const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };\r\n        this._shadowMap = new RenderTargetTexture(\r\n            this._light.name + \"_CSMShadowMap\",\r\n            size,\r\n            this._scene,\r\n            false,\r\n            true,\r\n            this._textureType,\r\n            false,\r\n            undefined,\r\n            false,\r\n            false,\r\n            undefined,\r\n            this._useRedTextureType ? Constants.TEXTUREFORMAT_RED : Constants.TEXTUREFORMAT_RGBA\r\n        );\r\n        this._shadowMap.createDepthStencilTexture(\r\n            engine.useReverseDepthBuffer ? Constants.GREATER : Constants.LESS,\r\n            true,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            `DepthStencilForCSMShadowGenerator-${this._light.name}`\r\n        );\r\n        this._shadowMap.noPrePassRenderer = true;\r\n    }\r\n\r\n    protected override _initializeShadowMap(): void {\r\n        super._initializeShadowMap();\r\n\r\n        if (this._shadowMap === null) {\r\n            return;\r\n        }\r\n\r\n        this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);\r\n        this._viewSpaceFrustumsZ = new Array(this._numCascades);\r\n        this._frustumLengths = new Array(this._numCascades);\r\n        this._lightSizeUVCorrection = new Array(this._numCascades * 2);\r\n        this._depthCorrection = new Array(this._numCascades);\r\n\r\n        this._cascades = [];\r\n        this._viewMatrices = [];\r\n        this._projectionMatrices = [];\r\n        this._transformMatrices = [];\r\n        this._cascadeMinExtents = [];\r\n        this._cascadeMaxExtents = [];\r\n        this._frustumCenter = [];\r\n        this._shadowCameraPos = [];\r\n        this._frustumCornersWorldSpace = [];\r\n\r\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\r\n            this._cascades[cascadeIndex] = {\r\n                prevBreakDistance: 0,\r\n                breakDistance: 0,\r\n            };\r\n\r\n            this._viewMatrices[cascadeIndex] = Matrix.Zero();\r\n            this._projectionMatrices[cascadeIndex] = Matrix.Zero();\r\n            this._transformMatrices[cascadeIndex] = Matrix.Zero();\r\n            this._cascadeMinExtents[cascadeIndex] = new Vector3();\r\n            this._cascadeMaxExtents[cascadeIndex] = new Vector3();\r\n            this._frustumCenter[cascadeIndex] = new Vector3();\r\n            this._shadowCameraPos[cascadeIndex] = new Vector3();\r\n            this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator._FrustumCornersNDCSpace.length);\r\n\r\n            for (let i = 0; i < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++i) {\r\n                this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();\r\n            }\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._shadowMap.onBeforeBindObservable.clear();\r\n        this._shadowMap.onBeforeRenderObservable.clear();\r\n\r\n        this._shadowMap.onBeforeRenderObservable.add((layer: number) => {\r\n            if (this._sceneUBOs) {\r\n                this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);\r\n            }\r\n            this._currentLayer = layer;\r\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\r\n                engine.setColorWrite(false);\r\n            }\r\n            this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer)!, this.getCascadeProjectionMatrix(layer)!);\r\n            if (this._useUBO) {\r\n                this._scene.getSceneUniformBuffer().unbindEffect();\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        });\r\n\r\n        this._shadowMap.onBeforeBindObservable.add(() => {\r\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\r\n            engine._debugPushGroup?.(`cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\r\n            if (this._breaksAreDirty) {\r\n                this._splitFrustum();\r\n            }\r\n            this._computeMatrices();\r\n        });\r\n\r\n        this._splitFrustum();\r\n    }\r\n\r\n    protected override _bindCustomEffectForRenderSubMeshForShadowMap(subMesh: SubMesh, effect: Effect): void {\r\n        effect.setMatrix(\"viewProjection\", this.getCascadeTransformMatrix(this._currentLayer)!);\r\n    }\r\n\r\n    protected override _isReadyCustomDefines(defines: any): void {\r\n        defines.push(\"#define SM_DEPTHCLAMP \" + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? \"1\" : \"0\"));\r\n    }\r\n\r\n    /**\r\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\r\n     * @param defines Defines of the material we want to update\r\n     * @param lightIndex Index of the light in the enabled light list of the material\r\n     */\r\n    public override prepareDefines(defines: any, lightIndex: number): void {\r\n        super.prepareDefines(defines, lightIndex);\r\n\r\n        const scene = this._scene;\r\n        const light = this._light;\r\n\r\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\r\n            return;\r\n        }\r\n\r\n        defines[\"SHADOWCSM\" + lightIndex] = true;\r\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = this.debug;\r\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = this.numCascades;\r\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = scene.useRightHandedSystem;\r\n\r\n        const camera = this._getCamera();\r\n\r\n        if (camera && this._shadowMaxZ <= (camera.maxZ || this._shadowMaxZ)) {\r\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = true;\r\n        }\r\n\r\n        if (this.cascadeBlendPercentage === 0) {\r\n            defines[\"SHADOWCSMNOBLEND\" + lightIndex] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\r\n     * defined in the generator but impacting the effect).\r\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\r\n     * @param effect The effect we are binfing the information for\r\n     */\r\n    public override bindShadowLight(lightIndex: string, effect: Effect): void {\r\n        const light = this._light;\r\n        const scene = this._scene;\r\n\r\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\r\n            return;\r\n        }\r\n\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        const shadowMap = this.getShadowMap();\r\n        if (!shadowMap) {\r\n            return;\r\n        }\r\n\r\n        const width = shadowMap.getSize().width;\r\n\r\n        effect.setMatrices(\"lightMatrix\" + lightIndex, this._transformMatricesAsArray);\r\n        effect.setArray(\"viewFrustumZ\" + lightIndex, this._viewSpaceFrustumsZ);\r\n        effect.setFloat(\"cascadeBlendFactor\" + lightIndex, this.cascadeBlendPercentage === 0 ? 10000 : 1 / this.cascadeBlendPercentage);\r\n        effect.setArray(\"frustumLengths\" + lightIndex, this._frustumLengths);\r\n\r\n        // Only PCF uses depth stencil texture.\r\n        if (this._filter === ShadowGenerator.FILTER_PCF) {\r\n            effect.setDepthStencilTexture(\"shadowTexture\" + lightIndex, shadowMap);\r\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\r\n        } else if (this._filter === ShadowGenerator.FILTER_PCSS) {\r\n            for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\r\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 0] =\r\n                    cascadeIndex === 0\r\n                        ? 1\r\n                        : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x); // x correction\r\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 1] =\r\n                    cascadeIndex === 0\r\n                        ? 1\r\n                        : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y); // y correction\r\n                this._depthCorrection[cascadeIndex] =\r\n                    cascadeIndex === 0\r\n                        ? 1\r\n                        : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);\r\n            }\r\n            effect.setDepthStencilTexture(\"shadowTexture\" + lightIndex, shadowMap);\r\n            effect.setTexture(\"depthTexture\" + lightIndex, shadowMap);\r\n\r\n            effect.setArray2(\"lightSizeUVCorrection\" + lightIndex, this._lightSizeUVCorrection);\r\n            effect.setArray(\"depthCorrection\" + lightIndex, this._depthCorrection);\r\n            effect.setFloat(\"penumbraDarkness\" + lightIndex, this.penumbraDarkness);\r\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);\r\n        } else {\r\n            effect.setTexture(\"shadowTexture\" + lightIndex, shadowMap);\r\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\r\n        }\r\n\r\n        light._uniformBuffer.updateFloat2(\r\n            \"depthValues\",\r\n            this.getLight().getDepthMinZ(camera),\r\n            this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera),\r\n            lightIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.\r\n     * (eq to view projection * shadow projection matrices)\r\n     * @returns The transform matrix used to create the shadow map\r\n     */\r\n    public override getTransformMatrix(): Matrix {\r\n        return this.getCascadeTransformMatrix(0)!;\r\n    }\r\n\r\n    /**\r\n     * Disposes the ShadowGenerator.\r\n     * Returns nothing.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        if (this._freezeShadowCastersBoundingInfoObservable) {\r\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\r\n            this._freezeShadowCastersBoundingInfoObservable = null;\r\n        }\r\n\r\n        if (this._depthReducer) {\r\n            this._depthReducer.dispose();\r\n            this._depthReducer = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the shadow generator setup to a json object.\r\n     * @returns The serialized JSON object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject: any = super.serialize();\r\n        const shadowMap = this.getShadowMap();\r\n\r\n        if (!shadowMap) {\r\n            return serializationObject;\r\n        }\r\n\r\n        serializationObject.numCascades = this._numCascades;\r\n        serializationObject.debug = this._debug;\r\n        serializationObject.stabilizeCascades = this.stabilizeCascades;\r\n        serializationObject.lambda = this._lambda;\r\n        serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;\r\n        serializationObject.depthClamp = this._depthClamp;\r\n        serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;\r\n        serializationObject.shadowMaxZ = this._shadowMaxZ;\r\n        serializationObject.penumbraDarkness = this.penumbraDarkness;\r\n\r\n        serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;\r\n        serializationObject.minDistance = this.minDistance;\r\n        serializationObject.maxDistance = this.maxDistance;\r\n\r\n        serializationObject.renderList = [];\r\n        if (shadowMap.renderList) {\r\n            for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\r\n                const mesh = shadowMap.renderList[meshIndex];\r\n\r\n                serializationObject.renderList.push(mesh.id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\r\n     * @param parsedShadowGenerator The JSON object to parse\r\n     * @param scene The scene to create the shadow map for\r\n     * @returns The parsed shadow generator\r\n     */\r\n    public static override Parse(parsedShadowGenerator: any, scene: Scene): ShadowGenerator {\r\n        const shadowGenerator = ShadowGenerator.Parse(\r\n            parsedShadowGenerator,\r\n            scene,\r\n            (mapSize: number, light: IShadowLight, camera: Nullable<Camera>) => new CascadedShadowGenerator(mapSize, <DirectionalLight>light, undefined, camera)\r\n        ) as CascadedShadowGenerator;\r\n\r\n        if (parsedShadowGenerator.numCascades !== undefined) {\r\n            shadowGenerator.numCascades = parsedShadowGenerator.numCascades;\r\n        }\r\n\r\n        if (parsedShadowGenerator.debug !== undefined) {\r\n            shadowGenerator.debug = parsedShadowGenerator.debug;\r\n        }\r\n\r\n        if (parsedShadowGenerator.stabilizeCascades !== undefined) {\r\n            shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;\r\n        }\r\n\r\n        if (parsedShadowGenerator.lambda !== undefined) {\r\n            shadowGenerator.lambda = parsedShadowGenerator.lambda;\r\n        }\r\n\r\n        if (parsedShadowGenerator.cascadeBlendPercentage !== undefined) {\r\n            shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;\r\n        }\r\n\r\n        if (parsedShadowGenerator.depthClamp !== undefined) {\r\n            shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;\r\n        }\r\n\r\n        if (parsedShadowGenerator.autoCalcDepthBounds !== undefined) {\r\n            shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;\r\n        }\r\n\r\n        if (parsedShadowGenerator.shadowMaxZ !== undefined) {\r\n            shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;\r\n        }\r\n\r\n        if (parsedShadowGenerator.penumbraDarkness !== undefined) {\r\n            shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;\r\n        }\r\n\r\n        if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== undefined) {\r\n            shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;\r\n        }\r\n\r\n        if (parsedShadowGenerator.minDistance !== undefined && parsedShadowGenerator.maxDistance !== undefined) {\r\n            shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);\r\n        }\r\n\r\n        return shadowGenerator;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["name", "name", "engine", "name", "engine", "scene", "camera", "w", "h", "reduction"]
}
