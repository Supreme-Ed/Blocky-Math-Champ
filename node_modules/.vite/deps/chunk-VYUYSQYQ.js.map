{
  "version": 3,
  "sources": ["../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts"],
  "sourcesContent": ["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20; i++) {\r\n                            // 20 iterations should be enough to converge\r\n                            if (estimatedTargetRadius <= targetInertia) {\r\n                                // We do not want a negative radius, so we break out of the loop\r\n                                break;\r\n                            }\r\n                            if (Math.abs(targetInertia * this.camera.inertia) < 0.001) {\r\n                                // We do not want to go below a certain threshold, so we break out of the loop\r\n                                break;\r\n                            }\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n"],
  "mappings": "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",
  "names": []
}
