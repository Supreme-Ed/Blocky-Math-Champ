import {
  PointerEventTypes,
  init_pointerEvents
} from "./chunk-GPWRF6JF.js";
import {
  CameraInputTypes,
  init_cameraInputsManager
} from "./chunk-VJCNHUGS.js";
import {
  __decorate,
  init_decorators,
  init_tslib_es6,
  serialize
} from "./chunk-IZLWPSPC.js";
import {
  Tools,
  init_tools
} from "./chunk-D3VYVQM6.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js
var BaseCameraPointersInput;
var init_BaseCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_pointerEvents();
    BaseCameraPointersInput = class {
      constructor() {
        this._currentMousePointerIdDown = -1;
        this.buttons = [0, 1, 2];
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        let previousPinchSquaredDistance = 0;
        let previousMultiTouchPanPosition = null;
        this._pointA = null;
        this._pointB = null;
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._buttonsPressed = 0;
        this._pointerInput = (p) => {
          var _a, _b;
          const evt = p.event;
          const isTouch = evt.pointerType === "touch";
          if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
            return;
          }
          const srcElement = evt.target;
          this._altKey = evt.altKey;
          this._ctrlKey = evt.ctrlKey;
          this._metaKey = evt.metaKey;
          this._shiftKey = evt.shiftKey;
          this._buttonsPressed = evt.buttons;
          if (engine.isPointerLock) {
            const offsetX = evt.movementX;
            const offsetY = evt.movementY;
            this.onTouch(null, offsetX, offsetY);
            this._pointA = null;
            this._pointB = null;
          } else if (p.type !== PointerEventTypes.POINTERDOWN && p.type !== PointerEventTypes.POINTERDOUBLETAP && isTouch && ((_a = this._pointA) == null ? void 0 : _a.pointerId) !== evt.pointerId && ((_b = this._pointB) == null ? void 0 : _b.pointerId) !== evt.pointerId) {
            return;
          } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentMousePointerIdDown === -1 || isTouch)) {
            try {
              srcElement == null ? void 0 : srcElement.setPointerCapture(evt.pointerId);
            } catch (e) {
            }
            if (this._pointA === null) {
              this._pointA = {
                x: evt.clientX,
                y: evt.clientY,
                pointerId: evt.pointerId,
                type: evt.pointerType
              };
            } else if (this._pointB === null) {
              this._pointB = {
                x: evt.clientX,
                y: evt.clientY,
                pointerId: evt.pointerId,
                type: evt.pointerType
              };
            } else {
              return;
            }
            if (this._currentMousePointerIdDown === -1 && !isTouch) {
              this._currentMousePointerIdDown = evt.pointerId;
            }
            this.onButtonDown(evt);
            if (!noPreventDefault) {
              evt.preventDefault();
              element && element.focus();
            }
          } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {
            this.onDoubleTap(evt.pointerType);
          } else if (p.type === PointerEventTypes.POINTERUP && (this._currentMousePointerIdDown === evt.pointerId || isTouch)) {
            try {
              srcElement == null ? void 0 : srcElement.releasePointerCapture(evt.pointerId);
            } catch (e) {
            }
            if (!isTouch) {
              this._pointB = null;
            }
            if (engine._badOS) {
              this._pointA = this._pointB = null;
            } else {
              if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {
                this._pointA = this._pointB;
                this._pointB = null;
              } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {
                this._pointB = null;
              } else {
                this._pointA = this._pointB = null;
              }
            }
            if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {
              this.onMultiTouch(
                this._pointA,
                this._pointB,
                previousPinchSquaredDistance,
                0,
                // pinchSquaredDistance
                previousMultiTouchPanPosition,
                null
                // multiTouchPanPosition
              );
              previousPinchSquaredDistance = 0;
              previousMultiTouchPanPosition = null;
            }
            this._currentMousePointerIdDown = -1;
            this.onButtonUp(evt);
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          } else if (p.type === PointerEventTypes.POINTERMOVE) {
            if (!noPreventDefault) {
              evt.preventDefault();
            }
            if (this._pointA && this._pointB === null) {
              const offsetX = evt.clientX - this._pointA.x;
              const offsetY = evt.clientY - this._pointA.y;
              this._pointA.x = evt.clientX;
              this._pointA.y = evt.clientY;
              this.onTouch(this._pointA, offsetX, offsetY);
            } else if (this._pointA && this._pointB) {
              const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;
              ed.x = evt.clientX;
              ed.y = evt.clientY;
              const distX = this._pointA.x - this._pointB.x;
              const distY = this._pointA.y - this._pointB.y;
              const pinchSquaredDistance = distX * distX + distY * distY;
              const multiTouchPanPosition = {
                x: (this._pointA.x + this._pointB.x) / 2,
                y: (this._pointA.y + this._pointB.y) / 2,
                pointerId: evt.pointerId,
                type: p.type
              };
              this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
              previousMultiTouchPanPosition = multiTouchPanPosition;
              previousPinchSquaredDistance = pinchSquaredDistance;
            }
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);
        this._onLostFocus = () => {
          this._pointA = this._pointB = null;
          previousPinchSquaredDistance = 0;
          previousMultiTouchPanPosition = null;
          this.onLostFocus();
        };
        this._contextMenuBind = (evt) => this.onContextMenu(evt);
        element && element.addEventListener("contextmenu", this._contextMenuBind, false);
        const hostWindow = this.camera.getScene().getEngine().getHostWindow();
        if (hostWindow) {
          Tools.RegisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
        }
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._onLostFocus) {
          const hostWindow = this.camera.getScene().getEngine().getHostWindow();
          if (hostWindow) {
            Tools.UnregisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
          }
        }
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this._observer = null;
          if (this._contextMenuBind) {
            const inputElement = this.camera.getScene().getEngine().getInputElement();
            inputElement && inputElement.removeEventListener("contextmenu", this._contextMenuBind);
          }
          this._onLostFocus = null;
        }
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._buttonsPressed = 0;
        this._currentMousePointerIdDown = -1;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "BaseCameraPointersInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "pointers";
      }
      /**
       * Called on pointer POINTERDOUBLETAP event.
       * Override this method to provide functionality on POINTERDOUBLETAP event.
       * @param type type of event
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onDoubleTap(type) {
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      /**
       * Called on pointer POINTERMOVE event if only a single touch is active.
       * Override this method to provide functionality.
       * @param point The current position of the pointer
       * @param offsetX The offsetX of the pointer when the event occurred
       * @param offsetY The offsetY of the pointer when the event occurred
       */
      onTouch(point, offsetX, offsetY) {
      }
      /**
       * Called on pointer POINTERMOVE event if multiple touches are active.
       * Override this method to provide functionality.
       * @param _pointA First point in the pair
       * @param _pointB Second point in the pair
       * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)
       * @param pinchSquaredDistance Sqr Distance between the points this time
       * @param previousMultiTouchPanPosition Previous center point between the points
       * @param multiTouchPanPosition Current center point between the points
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
      }
      /**
       * Called on JS contextmenu event.
       * Override this method to provide functionality.
       * @param evt the event to be handled
       */
      onContextMenu(evt) {
        evt.preventDefault();
      }
      /**
       * Called each time a new POINTERDOWN event occurs. Ie, for each button
       * press.
       * Override this method to provide functionality.
       * @param _evt Defines the event to track
       */
      onButtonDown(_evt) {
      }
      /**
       * Called each time a new POINTERUP event occurs. Ie, for each button
       * release.
       * Override this method to provide functionality.
       * @param _evt Defines the event to track
       */
      onButtonUp(_evt) {
      }
      /**
       * Called when window becomes inactive.
       * Override this method to provide functionality.
       */
      onLostFocus() {
      }
    };
    __decorate([
      serialize()
    ], BaseCameraPointersInput.prototype, "buttons", void 0);
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js
var ArcRotateCameraPointersInput;
var init_arcRotateCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_BaseCameraPointersInput();
    ArcRotateCameraPointersInput = class _ArcRotateCameraPointersInput extends BaseCameraPointersInput {
      constructor() {
        super(...arguments);
        this.buttons = [0, 1, 2];
        this.angularSensibilityX = 1e3;
        this.angularSensibilityY = 1e3;
        this.pinchPrecision = 12;
        this.pinchDeltaPercentage = 0;
        this.useNaturalPinchZoom = false;
        this.pinchZoom = true;
        this.panningSensibility = 1e3;
        this.multiTouchPanning = true;
        this.multiTouchPanAndZoom = true;
        this.pinchInwards = true;
        this._isPanClick = false;
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraPointersInput";
      }
      /**
       * Move camera from multi touch panning positions.
       * @param previousMultiTouchPanPosition
       * @param multiTouchPanPosition
       */
      _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {
          const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
          const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
          this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
          this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
        }
      }
      /**
       * Move camera from pinch zoom distances.
       * @param previousPinchSquaredDistance
       * @param pinchSquaredDistance
       */
      _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {
        const radius = this.camera.radius || _ArcRotateCameraPointersInput.MinimumRadiusForPinch;
        if (this.useNaturalPinchZoom) {
          this.camera.radius = radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);
        } else if (this.pinchDeltaPercentage) {
          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 1e-3 * radius * this.pinchDeltaPercentage;
        } else {
          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2);
        }
      }
      /**
       * Called on pointer POINTERMOVE event if only a single touch is active.
       * @param point current touch point
       * @param offsetX offset on X
       * @param offsetY offset on Y
       */
      onTouch(point, offsetX, offsetY) {
        if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {
          this.camera.inertialPanningX += -offsetX / this.panningSensibility;
          this.camera.inertialPanningY += offsetY / this.panningSensibility;
        } else {
          this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;
          this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;
        }
      }
      /**
       * Called on pointer POINTERDOUBLETAP event.
       */
      onDoubleTap() {
        if (this.camera.useInputToRestoreState) {
          this.camera.restoreState();
        }
      }
      /**
       * Called on pointer POINTERMOVE event if multiple touches are active.
       * @param pointA point A
       * @param pointB point B
       * @param previousPinchSquaredDistance distance between points in previous pinch
       * @param pinchSquaredDistance distance between points in current pinch
       * @param previousMultiTouchPanPosition multi-touch position in previous step
       * @param multiTouchPanPosition multi-touch position in current step
       */
      onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
          return;
        }
        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
          return;
        }
        if (this.multiTouchPanAndZoom) {
          this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
          this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
        } else if (this.multiTouchPanning && this.pinchZoom) {
          this._twoFingerActivityCount++;
          if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance) {
            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
            this._isPinching = true;
          } else {
            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
          }
        } else if (this.multiTouchPanning) {
          this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
        } else if (this.pinchZoom) {
          this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
        }
      }
      /**
       * Called each time a new POINTERDOWN event occurs. Ie, for each button
       * press.
       * @param evt Defines the event to track
       */
      onButtonDown(evt) {
        this._isPanClick = evt.button === this.camera._panningMouseButton;
      }
      /**
       * Called each time a new POINTERUP event occurs. Ie, for each button
       * release.
       * @param _evt Defines the event to track
       */
      onButtonUp(_evt) {
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
      }
      /**
       * Called when window becomes inactive.
       */
      onLostFocus() {
        this._isPanClick = false;
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
      }
    };
    ArcRotateCameraPointersInput.MinimumRadiusForPinch = 1e-3;
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "buttons", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "angularSensibilityX", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "angularSensibilityY", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchPrecision", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "useNaturalPinchZoom", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchZoom", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "panningSensibility", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "multiTouchPanning", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "multiTouchPanAndZoom", void 0);
    CameraInputTypes["ArcRotateCameraPointersInput"] = ArcRotateCameraPointersInput;
  }
});

export {
  BaseCameraPointersInput,
  init_BaseCameraPointersInput,
  ArcRotateCameraPointersInput,
  init_arcRotateCameraPointersInput
};
//# sourceMappingURL=chunk-C524CPPM.js.map
