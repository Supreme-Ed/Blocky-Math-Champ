{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Event/flowGraphReceiveCustomEventBlock.ts"],
  "sourcesContent": ["import type { Observer } from \"../../../Misc/observable\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport { FlowGraphEventBlock } from \"../../flowGraphEventBlock\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\n/**\r\n * Parameters used to create a FlowGraphReceiveCustomEventBlock.\r\n */\r\nexport interface IFlowGraphReceiveCustomEventBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The id of the event to receive.\r\n     * This event id is unique to the environment (not the context).\r\n     */\r\n    eventId: string;\r\n    /**\r\n     * The names of the data outputs for that event. Should be in the same order as the event data in\r\n     * SendCustomEvent\r\n     */\r\n    eventData: { [key: string]: { type: RichType<any> } };\r\n}\r\n\r\n/**\r\n * A block that receives a custom event.\r\n * It saves the event data in the data outputs, based on the provided eventData in the configuration. For example, if the event data is\r\n * `{ x: { type: RichTypeNumber }, y: { type: RichTypeNumber } }`, the block will have two data outputs: x and y.\r\n */\r\nexport class FlowGraphReceiveCustomEventBlock extends FlowGraphEventBlock {\r\n    public override initPriority: number = 1;\r\n\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config: IFlowGraphReceiveCustomEventBlockConfiguration\r\n    ) {\r\n        super(config);\r\n        // use event data to register data outputs\r\n        for (const key in this.config.eventData) {\r\n            this.registerDataOutput(key, this.config.eventData[key].type);\r\n        }\r\n    }\r\n\r\n    public _preparePendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        // check if we are not exceeding the max number of events\r\n        if (observable && observable.hasObservers() && observable.observers.length > FlowGraphCoordinator.MaxEventsPerType) {\r\n            this._reportError(context, `FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${FlowGraphCoordinator.MaxEventsPerType}.`);\r\n            return;\r\n        }\r\n\r\n        const eventObserver = observable.add((eventData: { [key: string]: any }) => {\r\n            Object.keys(eventData).forEach((key) => {\r\n                this.getDataOutput(key)?.setValue(eventData[key], context);\r\n            });\r\n            this._execute(context);\r\n        });\r\n        context._setExecutionVariable(this, \"_eventObserver\", eventObserver);\r\n    }\r\n    public _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        if (observable) {\r\n            const eventObserver = context._getExecutionVariable<Nullable<Observer<any[]>>>(this, \"_eventObserver\", null);\r\n            observable.remove(eventObserver);\r\n        } else {\r\n            Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`);\r\n        }\r\n    }\r\n\r\n    public override _executeEvent(_context: FlowGraphContext, _payload: any): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.ReceiveCustomEvent;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.ReceiveCustomEvent, FlowGraphReceiveCustomEventBlock);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAEA,IA6Ba;AA7Bb;;;AAEA;AAGA;AAEA;AAsBM,IAAO,mCAAP,cAAgD,oBAAmB;MAGrE,YAIoB,QAAsD;AAEtE,cAAM,MAAM;AAFI,aAAA,SAAA;AANJ,aAAA,eAAuB;AAUnC,mBAAW,OAAO,KAAK,OAAO,WAAW;AACrC,eAAK,mBAAmB,KAAK,KAAK,OAAO,UAAU,GAAG,EAAE,IAAI;QAChE;MACJ;MAEO,qBAAqB,SAAyB;AACjD,cAAM,aAAa,QAAQ,cAAc,YAAY,yBAAyB,KAAK,OAAO,OAAO;AAEjG,YAAI,cAAc,WAAW,aAAY,KAAM,WAAW,UAAU,SAAS,qBAAqB,kBAAkB;AAChH,eAAK,aAAa,SAAS,kEAAkE,KAAK,OAAO,OAAO,YAAY,qBAAqB,gBAAgB,GAAG;AACpK;QACJ;AAEA,cAAM,gBAAgB,WAAW,IAAI,CAAC,cAAqC;AACvE,iBAAO,KAAK,SAAS,EAAE,QAAQ,CAAC,QAAO;AAtDnD;AAuDgB,uBAAK,cAAc,GAAG,MAAtB,mBAAyB,SAAS,UAAU,GAAG,GAAG;UACtD,CAAC;AACD,eAAK,SAAS,OAAO;QACzB,CAAC;AACD,gBAAQ,sBAAsB,MAAM,kBAAkB,aAAa;MACvE;MACO,oBAAoB,SAAyB;AAChD,cAAM,aAAa,QAAQ,cAAc,YAAY,yBAAyB,KAAK,OAAO,OAAO;AACjG,YAAI,YAAY;AACZ,gBAAM,gBAAgB,QAAQ,sBAAiD,MAAM,kBAAkB,IAAI;AAC3G,qBAAW,OAAO,aAAa;QACnC,OAAO;AACH,gBAAM,KAAK,kEAAkE,KAAK,OAAO,OAAO,EAAE;QACtG;MACJ;MAEgB,cAAc,UAA4B,UAAa;AACnE,eAAO;MACX;;;;MAKgB,eAAY;AACxB,eAAA;MACJ;;AAEJ,kBAAa,oCAAyC,gCAAgC;;;",
  "names": []
}
