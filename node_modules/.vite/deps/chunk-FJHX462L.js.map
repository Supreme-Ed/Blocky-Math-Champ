{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/flowGraphSignalConnection.ts", "../../../dev/core/src/FlowGraph/flowGraphExecutionBlock.ts"],
  "sourcesContent": ["import type { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport { FlowGraphConnection, FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { FlowGraphAction } from \"./flowGraphLogger\";\r\n\r\n/**\r\n * Represents a connection point for a signal.\r\n * When an output point is activated, it will activate the connected input point.\r\n * When an input point is activated, it will execute the block it belongs to.\r\n */\r\nexport class FlowGraphSignalConnection extends FlowGraphConnection<FlowGraphExecutionBlock, FlowGraphSignalConnection> {\r\n    /**\r\n     * Optional payload. Can be used, for example, when an error is thrown to pass additional information.\r\n     */\r\n    public payload: any;\r\n\r\n    /**\r\n     * The priority of the signal. Signals with higher priority will be executed first.\r\n     * Set priority before adding the connection as sorting happens only when the connection is added.\r\n     */\r\n    public priority: number = 0;\r\n\r\n    public override _isSingularConnection(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override connectTo(point: FlowGraphSignalConnection): void {\r\n        super.connectTo(point);\r\n        // sort according to priority to handle execution order\r\n        this._connectedPoint.sort((a, b) => b.priority - a.priority);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activateSignal(context: FlowGraphContext): void {\r\n        context.logger?.addLogItem({\r\n            action: FlowGraphAction.ActivateSignal,\r\n            className: this._ownerBlock.getClassName(),\r\n            uniqueId: this._ownerBlock.uniqueId,\r\n            payload: {\r\n                connectionType: this.connectionType,\r\n                name: this.name,\r\n            },\r\n        });\r\n        if (this.connectionType === FlowGraphConnectionType.Input) {\r\n            context._notifyExecuteNode(this._ownerBlock);\r\n            this._ownerBlock._execute(context, this);\r\n            context._increaseExecutionId();\r\n        } else {\r\n            for (const connectedPoint of this._connectedPoint) {\r\n                connectedPoint._activateSignal(context);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"FlowGraphSignalConnection\", FlowGraphSignalConnection);\r\n", "import type { IFlowGraphBlockConfiguration } from \"./flowGraphBlock\";\r\nimport { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\n\r\n/**\r\n * A block that executes some action. Always has an input signal (which is not used by event blocks).\r\n * Can have one or more output signals.\r\n */\r\nexport abstract class FlowGraphExecutionBlock extends FlowGraphBlock {\r\n    /**\r\n     * Input connection: The input signal of the block.\r\n     */\r\n    public readonly in: FlowGraphSignalConnection;\r\n\r\n    /**\r\n     * An output connection that can be used to signal an error, if the block defines it.\r\n     */\r\n    public readonly error: FlowGraphSignalConnection;\r\n    /**\r\n     * Input connections that activate the block.\r\n     */\r\n    public signalInputs: FlowGraphSignalConnection[];\r\n    /**\r\n     * Output connections that can activate downstream blocks.\r\n     */\r\n    public signalOutputs: FlowGraphSignalConnection[];\r\n\r\n    /**\r\n     * The priority of the block. Higher priority blocks will be executed first.\r\n     * Note that priority cannot be change AFTER the block was added as sorting happens when the block is added to the execution queue.\r\n     */\r\n    public readonly priority: number = 0;\r\n\r\n    protected constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.signalInputs = [];\r\n        this.signalOutputs = [];\r\n        this.in = this._registerSignalInput(\"in\");\r\n        this.error = this._registerSignalOutput(\"error\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Executes the flow graph execution block.\r\n     */\r\n    public abstract _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void;\r\n\r\n    protected _registerSignalInput(name: string): FlowGraphSignalConnection {\r\n        const input = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Input, this);\r\n        this.signalInputs.push(input);\r\n        return input;\r\n    }\r\n\r\n    protected _registerSignalOutput(name: string): FlowGraphSignalConnection {\r\n        const output = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Output, this);\r\n        this.signalOutputs.push(output);\r\n        return output;\r\n    }\r\n\r\n    protected _unregisterSignalInput(name: string): void {\r\n        const index = this.signalInputs.findIndex((input) => input.name === name);\r\n        if (index !== -1) {\r\n            this.signalInputs[index].dispose();\r\n            this.signalInputs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    protected _unregisterSignalOutput(name: string): void {\r\n        const index = this.signalOutputs.findIndex((output) => output.name === name);\r\n        if (index !== -1) {\r\n            this.signalOutputs[index].dispose();\r\n            this.signalOutputs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    protected _reportError(context: FlowGraphContext, error: Error | string) {\r\n        this.error.payload = typeof error === \"string\" ? new Error(error) : error;\r\n        this.error._activateSignal(context);\r\n    }\r\n\r\n    /**\r\n     * Given a name of a signal input, return that input if it exists\r\n     * @param name the name of the input\r\n     * @returns if the input exists, the input. Otherwise, undefined.\r\n     */\r\n    public getSignalInput(name: string): FlowGraphSignalConnection | undefined {\r\n        return this.signalInputs.find((input) => input.name === name);\r\n    }\r\n\r\n    /**\r\n     * Given a name of a signal output, return that input if it exists\r\n     * @param name the name of the input\r\n     * @returns if the input exists, the input. Otherwise, undefined.\r\n     */\r\n    public getSignalOutput(name: string): FlowGraphSignalConnection | undefined {\r\n        return this.signalOutputs.find((output) => output.name === name);\r\n    }\r\n\r\n    /**\r\n     * Serializes this block\r\n     * @param serializationObject the object to serialize in\r\n     */\r\n    public override serialize(serializationObject: any = {}) {\r\n        super.serialize(serializationObject);\r\n        serializationObject.signalInputs = [];\r\n        serializationObject.signalOutputs = [];\r\n        for (const input of this.signalInputs) {\r\n            const serializedInput: any = {};\r\n            input.serialize(serializedInput);\r\n            serializationObject.signalInputs.push(serializedInput);\r\n        }\r\n        for (const output of this.signalOutputs) {\r\n            const serializedOutput: any = {};\r\n            output.serialize(serializedOutput);\r\n            serializationObject.signalOutputs.push(serializedOutput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deserializes from an object\r\n     * @param serializationObject the object to deserialize from\r\n     */\r\n    public override deserialize(serializationObject: any) {\r\n        for (let i = 0; i < serializationObject.signalInputs.length; i++) {\r\n            const signalInput = this.getSignalInput(serializationObject.signalInputs[i].name);\r\n            if (signalInput) {\r\n                signalInput.deserialize(serializationObject.signalInputs[i]);\r\n            } else {\r\n                throw new Error(\"Could not find signal input with name \" + serializationObject.signalInputs[i].name + \" in block \" + serializationObject.className);\r\n            }\r\n        }\r\n        for (let i = 0; i < serializationObject.signalOutputs.length; i++) {\r\n            const signalOutput = this.getSignalOutput(serializationObject.signalOutputs[i].name);\r\n            if (signalOutput) {\r\n                signalOutput.deserialize(serializationObject.signalOutputs[i]);\r\n            } else {\r\n                throw new Error(\"Could not find signal output with name \" + serializationObject.signalOutputs[i].name + \" in block \" + serializationObject.className);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FlowGraphExecutionBlock\";\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
