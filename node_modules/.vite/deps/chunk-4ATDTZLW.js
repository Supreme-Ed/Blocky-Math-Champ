import {
  FlowGraphExecutionBlock,
  init_flowGraphExecutionBlock
} from "./chunk-FJHX462L.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-D6A73UHJ.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSequenceBlock.js
var FlowGraphSequenceBlock;
var init_flowGraphSequenceBlock = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSequenceBlock.js"() {
    init_typeStore();
    init_flowGraphExecutionBlock();
    FlowGraphSequenceBlock = class extends FlowGraphExecutionBlock {
      constructor(config) {
        super(config);
        this.config = config;
        this.executionSignals = [];
        this.setNumberOfOutputSignals(this.config.outputSignalCount);
      }
      _execute(context) {
        for (let i = 0; i < this.executionSignals.length; i++) {
          this.executionSignals[i]._activateSignal(context);
        }
      }
      /**
       * Sets the block's output flows. Would usually be passed from the constructor but can be changed afterwards.
       * @param outputSignalCount the number of output flows
       */
      setNumberOfOutputSignals(outputSignalCount = 1) {
        while (this.executionSignals.length > outputSignalCount) {
          const flow = this.executionSignals.pop();
          if (flow) {
            flow.disconnectFromAll();
            this._unregisterSignalOutput(flow.name);
          }
        }
        while (this.executionSignals.length < outputSignalCount) {
          this.executionSignals.push(this._registerSignalOutput(`out_${this.executionSignals.length}`));
        }
      }
      /**
       * @returns class name of the block.
       */
      getClassName() {
        return "FlowGraphSequenceBlock";
      }
    };
    RegisterClass("FlowGraphSequenceBlock", FlowGraphSequenceBlock);
  }
});

export {
  FlowGraphSequenceBlock,
  init_flowGraphSequenceBlock
};
//# sourceMappingURL=chunk-4ATDTZLW.js.map
