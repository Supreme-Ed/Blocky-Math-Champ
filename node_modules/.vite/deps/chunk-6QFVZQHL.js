import {
  Engine,
  PostProcess,
  SphericalHarmonics,
  SphericalPolynomial,
  init_engine,
  init_postProcess,
  init_sphericalPolynomial
} from "./chunk-3J7D4RUP.js";
import {
  EffectWrapper,
  init_effectRenderer
} from "./chunk-6FU7CWU2.js";
import {
  RenderTargetTexture,
  init_renderTargetTexture
} from "./chunk-GDIZEFDS.js";
import {
  Texture,
  init_texture
} from "./chunk-TQ7EBD7Y.js";
import {
  SerializationHelper,
  init_decorators_serialization
} from "./chunk-5WVONG5F.js";
import {
  __decorate,
  init_decorators,
  init_tslib_es6,
  serialize
} from "./chunk-IZLWPSPC.js";
import {
  Vector3,
  init_math_vector
} from "./chunk-3KKXJTKL.js";
import {
  AbstractEngine,
  init_abstractEngine
} from "./chunk-WYMBDNR4.js";
import {
  Color3,
  init_math_color
} from "./chunk-FBNFE7ZR.js";
import {
  ToLinearSpace,
  init_math_constants
} from "./chunk-UTDEUVI2.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-D6A73UHJ.js";
import {
  Clamp,
  init_math_scalar_functions
} from "./chunk-TR2XLTTJ.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js
var FileFaceOrientation, CubeMapToSphericalPolynomialTools;
var init_cubemapToSphericalPolynomial = __esm({
  "node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js"() {
    init_math_vector();
    init_math_scalar_functions();
    init_sphericalPolynomial();
    init_math_constants();
    init_math_color();
    FileFaceOrientation = class {
      constructor(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {
        this.name = name;
        this.worldAxisForNormal = worldAxisForNormal;
        this.worldAxisForFileX = worldAxisForFileX;
        this.worldAxisForFileY = worldAxisForFileY;
      }
    };
    CubeMapToSphericalPolynomialTools = class {
      /**
       * Converts a texture to the according Spherical Polynomial data.
       * This extracts the first 3 orders only as they are the only one used in the lighting.
       *
       * @param texture The texture to extract the information from.
       * @returns The Spherical Polynomial data.
       */
      static ConvertCubeMapTextureToSphericalPolynomial(texture) {
        var _a;
        if (!texture.isCube) {
          return null;
        }
        (_a = texture.getScene()) == null ? void 0 : _a.getEngine().flushFramebuffer();
        const size = texture.getSize().width;
        const rightPromise = texture.readPixels(0, void 0, void 0, false);
        const leftPromise = texture.readPixels(1, void 0, void 0, false);
        let upPromise;
        let downPromise;
        if (texture.isRenderTarget) {
          upPromise = texture.readPixels(3, void 0, void 0, false);
          downPromise = texture.readPixels(2, void 0, void 0, false);
        } else {
          upPromise = texture.readPixels(2, void 0, void 0, false);
          downPromise = texture.readPixels(3, void 0, void 0, false);
        }
        const frontPromise = texture.readPixels(4, void 0, void 0, false);
        const backPromise = texture.readPixels(5, void 0, void 0, false);
        const gammaSpace = texture.gammaSpace;
        const format = 5;
        let type = 0;
        if (texture.textureType == 1 || texture.textureType == 2) {
          type = 1;
        }
        return new Promise((resolve) => {
          Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {
            const cubeInfo = {
              size,
              right,
              left,
              up,
              down,
              front,
              back,
              format,
              type,
              gammaSpace
            };
            resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));
          });
        });
      }
      /**
       * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin
       * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/
       * @param x
       * @param y
       * @returns the area
       */
      static _AreaElement(x, y) {
        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
      }
      /**
       * Converts a cubemap to the according Spherical Polynomial data.
       * This extracts the first 3 orders only as they are the only one used in the lighting.
       *
       * @param cubeInfo The Cube map to extract the information from.
       * @returns The Spherical Polynomial data.
       */
      static ConvertCubeMapToSphericalPolynomial(cubeInfo) {
        const sphericalHarmonics = new SphericalHarmonics();
        let totalSolidAngle = 0;
        const du = 2 / cubeInfo.size;
        const dv = du;
        const halfTexel = 0.5 * du;
        const minUV = halfTexel - 1;
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          const fileFace = this._FileFaces[faceIndex];
          const dataArray = cubeInfo[fileFace.name];
          let v = minUV;
          const stride = cubeInfo.format === 5 ? 4 : 3;
          for (let y = 0; y < cubeInfo.size; y++) {
            let u = minUV;
            for (let x = 0; x < cubeInfo.size; x++) {
              const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);
              worldDirection.normalize();
              const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);
              let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];
              let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];
              let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];
              if (isNaN(r)) {
                r = 0;
              }
              if (isNaN(g)) {
                g = 0;
              }
              if (isNaN(b)) {
                b = 0;
              }
              if (cubeInfo.type === 0) {
                r /= 255;
                g /= 255;
                b /= 255;
              }
              if (cubeInfo.gammaSpace) {
                r = Math.pow(Clamp(r), ToLinearSpace);
                g = Math.pow(Clamp(g), ToLinearSpace);
                b = Math.pow(Clamp(b), ToLinearSpace);
              }
              const max = this.MAX_HDRI_VALUE;
              if (this.PRESERVE_CLAMPED_COLORS) {
                const currentMax = Math.max(r, g, b);
                if (currentMax > max) {
                  const factor = max / currentMax;
                  r *= factor;
                  g *= factor;
                  b *= factor;
                }
              } else {
                r = Clamp(r, 0, max);
                g = Clamp(g, 0, max);
                b = Clamp(b, 0, max);
              }
              const color = new Color3(r, g, b);
              sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);
              totalSolidAngle += deltaSolidAngle;
              u += du;
            }
            v += dv;
          }
        }
        const sphereSolidAngle = 4 * Math.PI;
        const facesProcessed = 6;
        const expectedSolidAngle = sphereSolidAngle * facesProcessed / 6;
        const correctionFactor = expectedSolidAngle / totalSolidAngle;
        sphericalHarmonics.scaleInPlace(correctionFactor);
        sphericalHarmonics.convertIncidentRadianceToIrradiance();
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);
      }
    };
    CubeMapToSphericalPolynomialTools._FileFaces = [
      new FileFaceOrientation("right", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)),
      // +X east
      new FileFaceOrientation("left", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)),
      // -X west
      new FileFaceOrientation("up", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)),
      // +Y north
      new FileFaceOrientation("down", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)),
      // -Y south
      new FileFaceOrientation("front", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)),
      // +Z top
      new FileFaceOrientation("back", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0))
      // -Z bottom
    ];
    CubeMapToSphericalPolynomialTools.MAX_HDRI_VALUE = 4096;
    CubeMapToSphericalPolynomialTools.PRESERVE_CLAMPED_COLORS = false;
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinPassPostProcess.js
var ThinPassPostProcess, ThinPassCubePostProcess;
var init_thinPassPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinPassPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinPassPostProcess = class _ThinPassPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(Promise.all([import("./pass.fragment-D7EUDRGO.js")]));
        } else {
          list.push(Promise.all([import("./pass.fragment-4NZBZQQM.js")]));
        }
        super._gatherImports(useWebGPU, list);
      }
      /**
       * Constructs a new pass post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name, engine = null, options) {
        super({
          ...options,
          name,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinPassPostProcess.FragmentUrl
        });
      }
    };
    ThinPassPostProcess.FragmentUrl = "pass";
    ThinPassCubePostProcess = class _ThinPassCubePostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(Promise.all([import("./passCube.fragment-J5QOL6ZW.js")]));
        } else {
          list.push(Promise.all([import("./passCube.fragment-GEYJDNYV.js")]));
        }
        super._gatherImports(useWebGPU, list);
      }
      /**
       * Creates the PassCubePostProcess
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name, engine = null, options) {
        super({
          ...options,
          name,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinPassCubePostProcess.FragmentUrl,
          defines: "#define POSITIVEX"
        });
        this._face = 0;
      }
      /**
       * Gets or sets the cube face to display.
       *  * 0 is +X
       *  * 1 is -X
       *  * 2 is +Y
       *  * 3 is -Y
       *  * 4 is +Z
       *  * 5 is -Z
       */
      get face() {
        return this._face;
      }
      set face(value) {
        if (value < 0 || value > 5) {
          return;
        }
        this._face = value;
        switch (this._face) {
          case 0:
            this.updateEffect("#define POSITIVEX");
            break;
          case 1:
            this.updateEffect("#define NEGATIVEX");
            break;
          case 2:
            this.updateEffect("#define POSITIVEY");
            break;
          case 3:
            this.updateEffect("#define NEGATIVEY");
            break;
          case 4:
            this.updateEffect("#define POSITIVEZ");
            break;
          case 5:
            this.updateEffect("#define NEGATIVEZ");
            break;
        }
      }
    };
    ThinPassCubePostProcess.FragmentUrl = "passCube";
  }
});

// node_modules/@babylonjs/core/PostProcesses/passPostProcess.js
var PassPostProcess, PassCubePostProcess;
var init_passPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/passPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_abstractEngine();
    init_typeStore();
    init_decorators_serialization();
    init_thinPassPostProcess();
    init_decorators();
    PassPostProcess = class _PassPostProcess extends PostProcess {
      /**
       * Gets a string identifying the name of the class
       * @returns "PassPostProcess" string
       */
      getClassName() {
        return "PassPostProcess";
      }
      /**
       * Creates the PassPostProcess
       * @param name The name of the effect.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType The type of texture to be used when performing the post processing.
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(name, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          blockCompilation,
          ...options
        };
        super(name, ThinPassPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinPassPostProcess(name, engine, localOptions) : void 0,
          ...localOptions
        });
      }
      /**
       * @internal
       */
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new _PassPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    RegisterClass("BABYLON.PassPostProcess", PassPostProcess);
    PassCubePostProcess = class _PassCubePostProcess extends PostProcess {
      /**
       * Gets or sets the cube face to display.
       *  * 0 is +X
       *  * 1 is -X
       *  * 2 is +Y
       *  * 3 is -Y
       *  * 4 is +Z
       *  * 5 is -Z
       */
      get face() {
        return this._effectWrapper.face;
      }
      set face(value) {
        this._effectWrapper.face = value;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "PassCubePostProcess" string
       */
      getClassName() {
        return "PassCubePostProcess";
      }
      /**
       * Creates the PassCubePostProcess
       * @param name The name of the effect.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType The type of texture to be used when performing the post processing.
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(name, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          blockCompilation,
          ...options
        };
        super(name, ThinPassPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinPassCubePostProcess(name, engine, localOptions) : void 0,
          ...localOptions
        });
      }
      /**
       * @internal
       */
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new _PassCubePostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], PassCubePostProcess.prototype, "face", null);
    AbstractEngine._RescalePostProcessFactory = (engine) => {
      return new PassPostProcess("rescale", 1, null, 2, engine, false, 0);
    };
  }
});

// node_modules/@babylonjs/core/Misc/textureTools.js
function CreateResizedCopy(texture, width, height, useBilinearMode = true) {
  const scene = texture.getScene();
  const engine = scene.getEngine();
  const rtt = new RenderTargetTexture("resized" + texture.name, { width, height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
  rtt.wrapU = texture.wrapU;
  rtt.wrapV = texture.wrapV;
  rtt.uOffset = texture.uOffset;
  rtt.vOffset = texture.vOffset;
  rtt.uScale = texture.uScale;
  rtt.vScale = texture.vScale;
  rtt.uAng = texture.uAng;
  rtt.vAng = texture.vAng;
  rtt.wAng = texture.wAng;
  rtt.coordinatesIndex = texture.coordinatesIndex;
  rtt.level = texture.level;
  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
  rtt._texture.isReady = false;
  texture.wrapU = Texture.CLAMP_ADDRESSMODE;
  texture.wrapV = Texture.CLAMP_ADDRESSMODE;
  const passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
  passPostProcess.externalTextureSamplerBinding = true;
  passPostProcess.onEffectCreatedObservable.addOnce((e) => {
    e.executeWhenCompiled(() => {
      passPostProcess.onApply = function(effect) {
        effect.setTexture("textureSampler", texture);
      };
      const internalTexture = rtt.renderTarget;
      if (internalTexture) {
        scene.postProcessManager.directRender([passPostProcess], internalTexture);
        engine.unBindFramebuffer(internalTexture);
        rtt.disposeFramebufferObjects();
        passPostProcess.dispose();
        rtt.getInternalTexture().isReady = true;
      }
    });
  });
  return rtt;
}
function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format, width, height) {
  const engine = internalTexture.getEngine();
  internalTexture.isReady = false;
  samplingMode = samplingMode ?? internalTexture.samplingMode;
  type = type ?? internalTexture.type;
  format = format ?? internalTexture.format;
  width = width ?? internalTexture.width;
  height = height ?? internalTexture.height;
  if (type === -1) {
    type = 0;
  }
  return new Promise((resolve) => {
    const postProcess = new PostProcess("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, void 0, type, void 0, null, false, format);
    postProcess.externalTextureSamplerBinding = true;
    const encodedTexture = engine.createRenderTargetTexture({ width, height }, {
      generateDepthBuffer: false,
      generateMipMaps: false,
      generateStencilBuffer: false,
      samplingMode,
      type,
      format
    });
    postProcess.onEffectCreatedObservable.addOnce((e) => {
      e.executeWhenCompiled(() => {
        postProcess.onApply = (effect) => {
          effect._bindTexture("textureSampler", internalTexture);
          effect.setFloat2("scale", 1, 1);
        };
        scene.postProcessManager.directRender([postProcess], encodedTexture, true);
        engine.restoreDefaultFramebuffer();
        engine._releaseTexture(internalTexture);
        if (postProcess) {
          postProcess.dispose();
        }
        encodedTexture._swapAndDie(internalTexture);
        internalTexture.type = type;
        internalTexture.format = 5;
        internalTexture.isReady = true;
        resolve(internalTexture);
      });
    });
  });
}
function ToHalfFloat(value) {
  if (!floatView) {
    floatView = new Float32Array(1);
    int32View = new Int32Array(floatView.buffer);
  }
  floatView[0] = value;
  const x = int32View[0];
  let bits = x >> 16 & 32768;
  let m = x >> 12 & 2047;
  const e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e == 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function FromHalfFloat(value) {
  const s = (value & 32768) >> 15;
  const e = (value & 31744) >> 10;
  const f = value & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  } else if (e == 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
async function GetTextureDataAsync(texture, width, height, face = 0, lod = 0) {
  if (!texture.isReady() && texture._texture) {
    await new Promise((resolve, reject) => {
      if (texture._texture === null) {
        reject(0);
        return;
      }
      texture._texture.onLoadedObservable.addOnce(() => {
        resolve(0);
      });
    });
  }
  return await ProcessAsync(texture, width, height, face, lod);
}
var floatView, int32View, ProcessAsync, TextureTools;
var init_textureTools = __esm({
  "node_modules/@babylonjs/core/Misc/textureTools.js"() {
    init_texture();
    init_renderTargetTexture();
    init_passPostProcess();
    init_postProcess();
    ProcessAsync = async (texture, width, height, face, lod) => {
      const scene = texture.getScene();
      const engine = scene.getEngine();
      if (!engine.isWebGPU) {
        if (texture.isCube) {
          await import("./lodCube.fragment-AQNAKI2H.js");
        } else {
          await import("./lod.fragment-XUMIKEKI.js");
        }
      } else {
        if (texture.isCube) {
          await import("./lodCube.fragment-YZZHZY54.js");
        } else {
          await import("./lod.fragment-FN2NK4EO.js");
        }
      }
      let lodPostProcess;
      if (!texture.isCube) {
        lodPostProcess = new PostProcess("lod", "lod", {
          uniforms: ["lod", "gamma"],
          samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,
          engine,
          shaderLanguage: engine.isWebGPU ? 1 : 0
        });
      } else {
        const faceDefines = ["#define POSITIVEX", "#define NEGATIVEX", "#define POSITIVEY", "#define NEGATIVEY", "#define POSITIVEZ", "#define NEGATIVEZ"];
        lodPostProcess = new PostProcess("lodCube", "lodCube", {
          uniforms: ["lod", "gamma"],
          samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,
          engine,
          defines: faceDefines[face],
          shaderLanguage: engine.isWebGPU ? 1 : 0
        });
      }
      await new Promise((resolve) => {
        lodPostProcess.onEffectCreatedObservable.addOnce((e) => {
          e.executeWhenCompiled(() => {
            resolve(0);
          });
        });
      });
      const rtt = new RenderTargetTexture("temp", { width, height }, scene, false);
      lodPostProcess.onApply = function(effect) {
        effect.setTexture("textureSampler", texture);
        effect.setFloat("lod", lod);
        effect.setInt("gamma", texture.gammaSpace ? 1 : 0);
      };
      const internalTexture = texture.getInternalTexture();
      try {
        if (rtt.renderTarget && internalTexture) {
          const samplingMode = internalTexture.samplingMode;
          if (lod !== 0) {
            texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);
          } else {
            texture.updateSamplingMode(Texture.NEAREST_NEAREST);
          }
          scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);
          texture.updateSamplingMode(samplingMode);
          const bufferView = await engine.readPixels(0, 0, width, height);
          const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);
          engine.unBindFramebuffer(rtt.renderTarget);
          return data;
        } else {
          throw Error("Render to texture failed.");
        }
      } finally {
        rtt.dispose();
        lodPostProcess.dispose();
      }
    };
    TextureTools = {
      /**
       * Uses the GPU to create a copy texture rescaled at a given size
       * @param texture Texture to copy from
       * @param width defines the desired width
       * @param height defines the desired height
       * @param useBilinearMode defines if bilinear mode has to be used
       * @returns the generated texture
       */
      CreateResizedCopy,
      /**
       * Apply a post process to a texture
       * @param postProcessName name of the fragment post process
       * @param internalTexture the texture to encode
       * @param scene the scene hosting the texture
       * @param type type of the output texture. If not provided, use the one from internalTexture
       * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture
       * @param format format of the output texture. If not provided, use the one from internalTexture
       * @returns a promise with the internalTexture having its texture replaced by the result of the processing
       */
      ApplyPostProcess,
      /**
       * Converts a number to half float
       * @param value number to convert
       * @returns converted number
       */
      ToHalfFloat,
      /**
       * Converts a half float to a number
       * @param value half float to convert
       * @returns converted half float
       */
      FromHalfFloat,
      /**
       * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
       * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.
       * @param texture the source texture
       * @param width the width of the result, which does not have to match the source texture width
       * @param height the height of the result, which does not have to match the source texture height
       * @param face if the texture has multiple faces, the face index to use for the source
       * @param channels a filter for which of the RGBA channels to return in the result
       * @param lod if the texture has multiple LODs, the lod index to use for the source
       * @returns the 8-bit texture data
       */
      GetTextureDataAsync
    };
  }
});

export {
  CubeMapToSphericalPolynomialTools,
  init_cubemapToSphericalPolynomial,
  ThinPassPostProcess,
  ThinPassCubePostProcess,
  init_thinPassPostProcess,
  PassPostProcess,
  PassCubePostProcess,
  init_passPostProcess,
  CreateResizedCopy,
  ApplyPostProcess,
  ToHalfFloat,
  FromHalfFloat,
  GetTextureDataAsync,
  TextureTools,
  init_textureTools
};
//# sourceMappingURL=chunk-6QFVZQHL.js.map
