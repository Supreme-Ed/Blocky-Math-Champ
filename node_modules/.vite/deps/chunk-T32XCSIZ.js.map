{
  "version": 3,
  "sources": ["../../../dev/core/src/Culling/boundingBox.ts", "../../../dev/core/src/Culling/boundingSphere.ts", "../../../dev/core/src/Culling/boundingInfo.ts"],
  "sourcesContent": ["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in local space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in world space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/**\r\n * Class used to store bounding sphere information\r\n */\r\nexport class BoundingSphere {\r\n    /**\r\n     * Gets the center of the bounding sphere in local space\r\n     */\r\n    public readonly center = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in local space\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Gets the center of the bounding sphere in world space\r\n     */\r\n    public readonly centerWorld = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in world space\r\n     */\r\n    public radiusWorld: number;\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * Creates a new bounding sphere\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding sphere from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.minimum.copyFrom(min);\r\n        this.maximum.copyFrom(max);\r\n\r\n        const distance = Vector3.Distance(min, max);\r\n\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        this.radius = distance * 0.5;\r\n\r\n        this._update(worldMatrix || Matrix.IdentityReadOnly);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding sphere by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingSphere {\r\n        const newRadius = this.radius * factor;\r\n        const tmpVectors = BoundingSphere._TmpVector3;\r\n        const tempRadiusVector = tmpVectors[0].setAll(newRadius);\r\n        const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);\r\n        const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(worldMatrix: DeepImmutable<Matrix>): void {\r\n        if (!worldMatrix.isIdentity()) {\r\n            Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);\r\n            const tempVector = BoundingSphere._TmpVector3[0];\r\n            Vector3.TransformNormalFromFloatsToRef(1.0, 1.0, 1.0, worldMatrix, tempVector);\r\n            this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;\r\n        } else {\r\n            this.centerWorld.copyFrom(this.center);\r\n            this.radiusWorld = this.radius;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        const radius = this.radiusWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) <= -radius) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere center is in between the frustum planes.\r\n     * Used for optimistic fast inclusion.\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if the sphere center is in between the frustum planes\r\n     */\r\n    public isCenterInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding sphere\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding sphere\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);\r\n        if (this.radiusWorld * this.radiusWorld < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Checks if two sphere intersect\r\n     * @param sphere0 sphere 0\r\n     * @param sphere1 sphere 1\r\n     * @returns true if the spheres intersect\r\n     */\r\n    public static Intersects(sphere0: DeepImmutable<BoundingSphere>, sphere1: DeepImmutable<BoundingSphere>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);\r\n        const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;\r\n\r\n        if (radiusSum * radiusSum < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a sphere from a center and a radius\r\n     * @param center The center\r\n     * @param radius radius\r\n     * @param matrix Optional worldMatrix\r\n     * @returns The sphere\r\n     */\r\n    public static CreateFromCenterAndRadius(center: DeepImmutable<Vector3>, radius: number, matrix?: DeepImmutable<Matrix>): BoundingSphere {\r\n        this._TmpVector3[0].copyFrom(center);\r\n        this._TmpVector3[1].copyFromFloats(0, 0, radius);\r\n        this._TmpVector3[2].copyFrom(center);\r\n        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);\r\n        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);\r\n\r\n        const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);\r\n\r\n        if (matrix) {\r\n            sphere._worldMatrix = matrix;\r\n        } else {\r\n            sphere._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        return sphere;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { TmpVectors } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\nconst _result0 = { min: 0, max: 0 };\r\nconst _result1 = { min: 0, max: 0 };\r\nconst computeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number; max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst axisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    computeBoxExtents(axis, box0, _result0);\r\n    computeBoxExtents(axis, box1, _result1);\r\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly _TmpVector3 = BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to include the given point.\r\n     * @param point The point that will be included in the current bounding info (in local space)\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulate(point: Vector3): BoundingInfo {\r\n        const minimum = Vector3.Minimize(this.minimum, point);\r\n        const maximum = Vector3.Maximize(this.maximum, point);\r\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to encapsulate the given bounding info.\r\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulateBoundingInfo(toEncapsulate: BoundingInfo): BoundingInfo {\r\n        const invw = TmpVectors.Matrix[0];\r\n        this.boundingBox.getWorldMatrix().invertToRef(invw);\r\n\r\n        const v = TmpVectors.Vector3[0];\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * The different strategies available are:\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = Constants.MESHES_CULLINGSTRATEGY_STANDARD): boolean {\r\n        const inclusionTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        const bSphereOnlyTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        const box0 = this.boundingBox;\r\n        const box1 = boundingInfo.boundingBox;\r\n\r\n        if (!axisOverlap(box0.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
