{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphWaitAllBlock.ts"],
  "sourcesContent": ["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\r\nimport { RichTypeNumber } from \"core/FlowGraph/flowGraphRichTypes\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\n/**\r\n * Configuration for the wait all block.\r\n */\r\nexport interface IFlowGraphWaitAllBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The number of input signals. There will always be at least one input flow.\r\n     * glTF interactivity has a max of 64 input flows.\r\n     */\r\n    inputSignalCount: number;\r\n}\r\n\r\n/**\r\n * A block that waits for all input flows to be activated before activating its output flow.\r\n */\r\nexport class FlowGraphWaitAllBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * Input connection: Resets the block.\r\n     */\r\n    public reset: FlowGraphSignalConnection;\r\n\r\n    /**\r\n     * Output connection:When the last missing flow is activated\r\n     */\r\n    public completed: FlowGraphSignalConnection;\r\n\r\n    /**\r\n     * Output connection: The number of remaining inputs to be activated.\r\n     */\r\n    public remainingInputs: FlowGraphDataConnection<number>;\r\n    /**\r\n     * An array of input signals\r\n     */\r\n    public readonly inFlows: FlowGraphSignalConnection[] = [];\r\n    private _cachedActivationState: boolean[] = [];\r\n\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config: IFlowGraphWaitAllBlockConfiguration\r\n    ) {\r\n        super(config);\r\n\r\n        this.reset = this._registerSignalInput(\"reset\");\r\n        this.completed = this._registerSignalOutput(\"completed\");\r\n        this.remainingInputs = this.registerDataOutput(\"remainingInputs\", RichTypeNumber, this.config.inputSignalCount || 0);\r\n        // The first inFlow is the default input signal all execution blocks have\r\n        for (let i = 0; i < this.config.inputSignalCount; i++) {\r\n            this.inFlows.push(this._registerSignalInput(`in_${i}`));\r\n        }\r\n        // no need for in\r\n        this._unregisterSignalInput(\"in\");\r\n    }\r\n\r\n    private _getCurrentActivationState(context: FlowGraphContext) {\r\n        const activationState = this._cachedActivationState;\r\n        activationState.length = 0;\r\n        if (!context._hasExecutionVariable(this, \"activationState\")) {\r\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\r\n                activationState.push(false);\r\n            }\r\n        } else {\r\n            const contextActivationState = context._getExecutionVariable(this, \"activationState\", [] as boolean[]);\r\n            for (let i = 0; i < contextActivationState.length; i++) {\r\n                activationState.push(contextActivationState[i]);\r\n            }\r\n        }\r\n        return activationState;\r\n    }\r\n\r\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\r\n        const activationState = this._getCurrentActivationState(context);\r\n        if (callingSignal === this.reset) {\r\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\r\n                activationState[i] = false;\r\n            }\r\n        } else {\r\n            const index = this.inFlows.indexOf(callingSignal);\r\n            if (index >= 0) {\r\n                activationState[index] = true;\r\n            }\r\n        }\r\n        this.remainingInputs.setValue(activationState.filter((v) => !v).length, context);\r\n\r\n        context._setExecutionVariable(this, \"activationState\", activationState.slice());\r\n\r\n        if (!activationState.includes(false)) {\r\n            this.completed._activateSignal(context);\r\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\r\n                activationState[i] = false;\r\n            }\r\n        } else {\r\n            callingSignal !== this.reset && this.out._activateSignal(context);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.WaitAll;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block into a object\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    public override serialize(serializationObject?: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.config.inputFlows = this.config.inputSignalCount;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.WaitAll, FlowGraphWaitAllBlock);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAEA,IAoBa;AApBb;;;AAEA;AAEA;AAgBM,IAAO,wBAAP,cAAqC,qCAAoC;MAqB3E,YAIoB,QAA2C;AAE3D,cAAM,MAAM;AAFI,aAAA,SAAA;AAPJ,aAAA,UAAuC,CAAA;AAC/C,aAAA,yBAAoC,CAAA;AAUxC,aAAK,QAAQ,KAAK,qBAAqB,OAAO;AAC9C,aAAK,YAAY,KAAK,sBAAsB,WAAW;AACvD,aAAK,kBAAkB,KAAK,mBAAmB,mBAAmB,gBAAgB,KAAK,OAAO,oBAAoB,CAAC;AAEnH,iBAAS,IAAI,GAAG,IAAI,KAAK,OAAO,kBAAkB,KAAK;AACnD,eAAK,QAAQ,KAAK,KAAK,qBAAqB,MAAM,CAAC,EAAE,CAAC;QAC1D;AAEA,aAAK,uBAAuB,IAAI;MACpC;MAEQ,2BAA2B,SAAyB;AACxD,cAAM,kBAAkB,KAAK;AAC7B,wBAAgB,SAAS;AACzB,YAAI,CAAC,QAAQ,sBAAsB,MAAM,iBAAiB,GAAG;AACzD,mBAAS,IAAI,GAAG,IAAI,KAAK,OAAO,kBAAkB,KAAK;AACnD,4BAAgB,KAAK,KAAK;UAC9B;QACJ,OAAO;AACH,gBAAM,yBAAyB,QAAQ,sBAAsB,MAAM,mBAAmB,CAAA,CAAe;AACrG,mBAAS,IAAI,GAAG,IAAI,uBAAuB,QAAQ,KAAK;AACpD,4BAAgB,KAAK,uBAAuB,CAAC,CAAC;UAClD;QACJ;AACA,eAAO;MACX;MAEO,SAAS,SAA2B,eAAwC;AAC/E,cAAM,kBAAkB,KAAK,2BAA2B,OAAO;AAC/D,YAAI,kBAAkB,KAAK,OAAO;AAC9B,mBAAS,IAAI,GAAG,IAAI,KAAK,OAAO,kBAAkB,KAAK;AACnD,4BAAgB,CAAC,IAAI;UACzB;QACJ,OAAO;AACH,gBAAM,QAAQ,KAAK,QAAQ,QAAQ,aAAa;AAChD,cAAI,SAAS,GAAG;AACZ,4BAAgB,KAAK,IAAI;UAC7B;QACJ;AACA,aAAK,gBAAgB,SAAS,gBAAgB,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,OAAO;AAE/E,gBAAQ,sBAAsB,MAAM,mBAAmB,gBAAgB,MAAK,CAAE;AAE9E,YAAI,CAAC,gBAAgB,SAAS,KAAK,GAAG;AAClC,eAAK,UAAU,gBAAgB,OAAO;AACtC,mBAAS,IAAI,GAAG,IAAI,KAAK,OAAO,kBAAkB,KAAK;AACnD,4BAAgB,CAAC,IAAI;UACzB;QACJ,OAAO;AACH,4BAAkB,KAAK,SAAS,KAAK,IAAI,gBAAgB,OAAO;QACpE;MACJ;;;;MAKgB,eAAY;AACxB,eAAA;MACJ;;;;;MAMgB,UAAU,qBAAyB;AAC/C,cAAM,UAAU,mBAAmB;AACnC,4BAAoB,OAAO,aAAa,KAAK,OAAO;MACxD;;AAEJ,kBAAa,yBAA8B,qBAAqB;;;",
  "names": []
}
