{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/andOrNotEvaluator.ts", "../../../dev/core/src/Misc/tags.ts", "../../../dev/core/src/Misc/decorators.serialization.ts"],
  "sourcesContent": ["/**\r\n * Class used to evaluate queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^()]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        } else {\r\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback =\r\n            evaluateCallback ||\r\n            ((r) => {\r\n                return r === \"true\" ? true : false;\r\n            });\r\n\r\n        let result;\r\n        const or = parenthesisContent.split(\"||\");\r\n\r\n        for (const i in or) {\r\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\r\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                const and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (let j = 0; j < and.length; ++j) {\r\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            } else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        } else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) {\r\n                            // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") {\r\n                    // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    } else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                } else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        } else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n", "import { AndOrNotEvaluator } from \"./andOrNotEvaluator\";\r\n\r\n/**\r\n * Class used to store custom tags\r\n */\r\nexport class Tags {\r\n    /**\r\n     * Adds support for tags on the given object\r\n     * @param obj defines the object to use\r\n     */\r\n    public static EnableFor(obj: any): void {\r\n        obj._tags = obj._tags || {};\r\n\r\n        obj.hasTags = () => {\r\n            return Tags.HasTags(obj);\r\n        };\r\n\r\n        obj.addTags = (tagsString: string) => {\r\n            return Tags.AddTagsTo(obj, tagsString);\r\n        };\r\n\r\n        obj.removeTags = (tagsString: string) => {\r\n            return Tags.RemoveTagsFrom(obj, tagsString);\r\n        };\r\n\r\n        obj.matchesTagsQuery = (tagsQuery: string) => {\r\n            return Tags.MatchesQuery(obj, tagsQuery);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Removes tags support\r\n     * @param obj defines the object to use\r\n     */\r\n    public static DisableFor(obj: any): void {\r\n        delete obj._tags;\r\n        delete obj.hasTags;\r\n        delete obj.addTags;\r\n        delete obj.removeTags;\r\n        delete obj.matchesTagsQuery;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given object has tags\r\n     * @param obj defines the object to use\r\n     * @returns a boolean\r\n     */\r\n    public static HasTags(obj: any): boolean {\r\n        if (!obj._tags) {\r\n            return false;\r\n        }\r\n\r\n        const tags = obj._tags;\r\n        for (const i in tags) {\r\n            if (Object.prototype.hasOwnProperty.call(tags, i)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the tags available on a given object\r\n     * @param obj defines the object to use\r\n     * @param asString defines if the tags must be returned as a string instead of an array of strings\r\n     * @returns the tags\r\n     */\r\n    public static GetTags(obj: any, asString: boolean = true): any {\r\n        if (!obj._tags) {\r\n            return null;\r\n        }\r\n        if (asString) {\r\n            const tagsArray = [];\r\n            for (const tag in obj._tags) {\r\n                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {\r\n                    tagsArray.push(tag);\r\n                }\r\n            }\r\n            return tagsArray.join(\" \");\r\n        } else {\r\n            return obj._tags;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds tags to an object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.\r\n     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces\r\n     */\r\n    public static AddTagsTo(obj: any, tagsString: string): void {\r\n        if (!tagsString) {\r\n            return;\r\n        }\r\n\r\n        if (typeof tagsString !== \"string\") {\r\n            return;\r\n        }\r\n\r\n        const tags = tagsString.split(\" \");\r\n        tags.forEach(function (tag) {\r\n            Tags._AddTagTo(obj, tag);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _AddTagTo(obj: any, tag: string): void {\r\n        tag = tag.trim();\r\n\r\n        if (tag === \"\" || tag === \"true\" || tag === \"false\") {\r\n            return;\r\n        }\r\n\r\n        if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\r\n            return;\r\n        }\r\n\r\n        Tags.EnableFor(obj);\r\n        obj._tags[tag] = true;\r\n    }\r\n\r\n    /**\r\n     * Removes specific tags from a specific object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tags to remove\r\n     */\r\n    public static RemoveTagsFrom(obj: any, tagsString: string) {\r\n        if (!Tags.HasTags(obj)) {\r\n            return;\r\n        }\r\n        const tags = tagsString.split(\" \");\r\n        for (const t in tags) {\r\n            Tags._RemoveTagFrom(obj, tags[t]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RemoveTagFrom(obj: any, tag: string): void {\r\n        delete obj._tags[tag];\r\n    }\r\n\r\n    /**\r\n     * Defines if tags hosted on an object match a given query\r\n     * @param obj defines the object to use\r\n     * @param tagsQuery defines the tag query\r\n     * @returns a boolean\r\n     */\r\n    public static MatchesQuery(obj: any, tagsQuery: string): boolean {\r\n        if (tagsQuery === undefined) {\r\n            return true;\r\n        }\r\n\r\n        if (tagsQuery === \"\") {\r\n            return Tags.HasTags(obj);\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);\r\n    }\r\n}\r\n", "import type { FresnelParameters } from \"../Materials/fresnelParameters\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Tags } from \"./tags\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { GetMergedStore } from \"./decorators.functions\";\r\n\r\n/** @internal */\r\nexport interface CopySourceOptions {\r\n    /*\r\n     * if a texture is used in more than one channel (e.g diffuse and opacity),\r\n     * only clone it once and reuse it on the other channels. Default false\r\n     */\r\n    cloneTexturesOnlyOnce?: boolean;\r\n}\r\n\r\nconst _copySource = function <T>(creationFunction: () => T, source: T, instanciate: boolean, options: CopySourceOptions = {}): T {\r\n    const destination = creationFunction();\r\n\r\n    // Tags\r\n    if (Tags && Tags.HasTags(source)) {\r\n        Tags.AddTagsTo(destination, Tags.GetTags(source, true));\r\n    }\r\n\r\n    const classStore = GetMergedStore(destination);\r\n\r\n    // Map from source texture uniqueId to destination texture\r\n    const textureMap: Record<number, any> = {};\r\n\r\n    // Properties\r\n    for (const property in classStore) {\r\n        const propertyDescriptor = classStore[property];\r\n        const sourceProperty = (<any>source)[property];\r\n        const propertyType = propertyDescriptor.type;\r\n\r\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n            switch (propertyType) {\r\n                case 0: // Value\r\n                case 6: // Mesh reference\r\n                case 9: // Image processing configuration reference\r\n                case 11: // Camera reference\r\n                    (<any>destination)[property] = sourceProperty;\r\n                    break;\r\n                case 1: // Texture\r\n                    if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\r\n                        (<any>destination)[property] = textureMap[sourceProperty.uniqueId];\r\n                    } else {\r\n                        (<any>destination)[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\r\n                        textureMap[sourceProperty.uniqueId] = (<any>destination)[property];\r\n                    }\r\n                    break;\r\n                case 2: // Color3\r\n                case 3: // FresnelParameters\r\n                case 4: // Vector2\r\n                case 5: // Vector3\r\n                case 7: // Color Curves\r\n                case 8: // Color 4\r\n                case 10: // Quaternion\r\n                case 12: // Matrix\r\n                    (<any>destination)[property] = instanciate ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return destination;\r\n};\r\n\r\n/**\r\n * Class used to help serialization objects\r\n */\r\nexport class SerializationHelper {\r\n    /**\r\n     * Gets or sets a boolean to indicate if the UniqueId property should be serialized\r\n     */\r\n    public static AllowLoadingUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImageProcessingConfigurationParser = (sourceProperty: any): ImageProcessingConfiguration => {\r\n        throw _WarnImport(\"ImageProcessingConfiguration\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _FresnelParametersParser = (sourceProperty: any): FresnelParameters => {\r\n        throw _WarnImport(\"FresnelParameters\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ColorCurvesParser = (sourceProperty: any): ColorCurves => {\r\n        throw _WarnImport(\"ColorCurves\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _TextureParser = (sourceProperty: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> => {\r\n        throw _WarnImport(\"Texture\");\r\n    };\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        if (source.animations) {\r\n            destination.animations = [];\r\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\r\n                const animation = source.animations[animationIndex];\r\n\r\n                destination.animations.push(animation.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static function used to serialized a specific entity\r\n     * @param entity defines the entity to serialize\r\n     * @param serializationObject defines the optional target object where serialization data will be stored\r\n     * @returns a JSON compatible object representing the serialization of the entity\r\n     */\r\n    public static Serialize<T>(entity: T, serializationObject?: any): any {\r\n        if (!serializationObject) {\r\n            serializationObject = {};\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(entity);\r\n        }\r\n\r\n        const serializedProperties = GetMergedStore(entity);\r\n\r\n        // Properties\r\n        for (const property in serializedProperties) {\r\n            const propertyDescriptor = serializedProperties[property];\r\n            const targetPropertyName = propertyDescriptor.sourceName || property;\r\n            const propertyType = propertyDescriptor.type;\r\n            const sourceProperty = (<any>entity)[property];\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        serializationObject[targetPropertyName] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 2: // Color3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 4: // Vector2\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 5: // Vector3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        serializationObject[targetPropertyName] = sourceProperty.id;\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 8: // Color 4\r\n                        serializationObject[targetPropertyName] = (<Color4>sourceProperty).asArray();\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        serializationObject[targetPropertyName] = (<ImageProcessingConfiguration>sourceProperty).serialize();\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        serializationObject[targetPropertyName] = (<Quaternion>sourceProperty).asArray();\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        serializationObject[targetPropertyName] = (<Camera>sourceProperty).id;\r\n                        break;\r\n                    case 12: // Matrix\r\n                        serializationObject[targetPropertyName] = (<Matrix>sourceProperty).asArray();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\r\n     * @param source the source json data\r\n     * @param destination the destination object\r\n     * @param scene the scene where the object is\r\n     * @param rootUrl root url to use to load assets\r\n     */\r\n    public static ParseProperties(source: any, destination: any, scene: Nullable<Scene>, rootUrl: Nullable<string>) {\r\n        if (!rootUrl) {\r\n            rootUrl = \"\";\r\n        }\r\n\r\n        const classStore = GetMergedStore(destination);\r\n\r\n        // Properties\r\n        for (const property in classStore) {\r\n            const propertyDescriptor = classStore[property];\r\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\r\n            const propertyType = propertyDescriptor.type;\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                const dest = <any>destination;\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        dest[property] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        if (scene) {\r\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\r\n                        }\r\n                        break;\r\n                    case 2: // Color3\r\n                        dest[property] = Color3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\r\n                        break;\r\n                    case 4: // Vector2\r\n                        dest[property] = Vector2.FromArray(sourceProperty);\r\n                        break;\r\n                    case 5: // Vector3\r\n                        dest[property] = Vector3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getLastMeshById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\r\n                        break;\r\n                    case 8: // Color 4\r\n                        dest[property] = Color4.FromArray(sourceProperty);\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        dest[property] = Quaternion.FromArray(sourceProperty);\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getCameraById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 12: // Matrix\r\n                        dest[property] = Matrix.FromArray(sourceProperty);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from a serialization data object\r\n     * @param creationFunction defines a function used to instanciated the new entity\r\n     * @param source defines the source serialization data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url for resources\r\n     * @returns a new entity\r\n     */\r\n    public static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl: Nullable<string> = null): T {\r\n        const destination = creationFunction();\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            Tags.AddTagsTo(destination, source.tags);\r\n        }\r\n\r\n        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\r\n\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * Clones an object\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @param options defines the options to use\r\n     * @returns the cloned object\r\n     */\r\n    public static Clone<T>(creationFunction: () => T, source: T, options: CopySourceOptions = {}): T {\r\n        return _copySource(creationFunction, source, false, options);\r\n    }\r\n\r\n    /**\r\n     * Instanciates a new object based on a source one (some data will be shared between both object)\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the new object\r\n     */\r\n    public static Instanciate<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, true);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
