{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/flowGraphPathConverterComponent.ts", "../../../dev/core/src/FlowGraph/Blocks/Data/Transformers/flowGraphJsonPointerParserBlock.ts"],
  "sourcesContent": ["import type { IObjectInfo, IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport { RichTypeFlowGraphInteger } from \"./flowGraphRichTypes\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\n\r\nconst pathHasTemplatesRegex = new RegExp(/\\/\\{(\\w+)\\}(?=\\/|$)/g);\r\n\r\n/**\r\n * @experimental\r\n * A component that converts a path to an object accessor.\r\n */\r\nexport class FlowGraphPathConverterComponent {\r\n    /**\r\n     * The templated inputs for the provided path.\r\n     */\r\n    public readonly templatedInputs: FlowGraphDataConnection<FlowGraphInteger>[] = [];\r\n    public constructor(\r\n        public path: string,\r\n        public ownerBlock: FlowGraphBlock\r\n    ) {\r\n        let match = pathHasTemplatesRegex.exec(path);\r\n        const templateSet = new Set<string>();\r\n        while (match) {\r\n            const [, matchGroup] = match;\r\n            if (templateSet.has(matchGroup)) {\r\n                throw new Error(\"Duplicate template variable detected.\");\r\n            }\r\n            templateSet.add(matchGroup);\r\n            this.templatedInputs.push(ownerBlock.registerDataInput(matchGroup, RichTypeFlowGraphInteger, new FlowGraphInteger(0)));\r\n            match = pathHasTemplatesRegex.exec(path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the accessor for the path.\r\n     * @param pathConverter the path converter to use to convert the path to an object accessor.\r\n     * @param context the context to use.\r\n     * @returns the accessor for the path.\r\n     * @throws if the value for a templated input is invalid.\r\n     */\r\n    public getAccessor(pathConverter: IPathToObjectConverter<IObjectAccessor>, context: FlowGraphContext): IObjectInfo<IObjectAccessor> {\r\n        let finalPath = this.path;\r\n        for (const templatedInput of this.templatedInputs) {\r\n            const valueToReplace = templatedInput.getValue(context).value;\r\n            if (typeof valueToReplace !== \"number\" || valueToReplace < 0) {\r\n                throw new Error(\"Invalid value for templated input.\");\r\n            }\r\n            finalPath = finalPath.replace(`{${templatedInput.name}}`, valueToReplace.toString());\r\n        }\r\n        return pathConverter.convert(finalPath);\r\n    }\r\n}\r\n", "import type { FlowGraphAssetType } from \"core/FlowGraph/flowGraphAssetsContext\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport { FlowGraphPathConverterComponent } from \"core/FlowGraph/flowGraphPathConverterComponent\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport type { IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\nimport type { IPathToObjectConverter } from \"core/ObjectModel/objectModelInterfaces\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport type { Animation } from \"core/Animations/animation\";\nimport type { EasingFunction } from \"core/Animations/easing\";\nimport type { Vector4 } from \"core/Maths/math.vector\";\nimport { Color3, Color4 } from \"core/Maths/math.color\";\nimport { FlowGraphCachedOperationBlock } from \"../flowGraphCachedOperationBlock\";\n\n/**\n * Configuration for the JSON pointer parser block.\n */\nexport interface IFlowGraphJsonPointerParserBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The JSON pointer to parse.\n     */\n    jsonPointer: string;\n    /**\n     * The path converter to use to convert the path to an object accessor.\n     */\n    pathConverter: IPathToObjectConverter<IObjectAccessor>;\n\n    /**\n     * Whether to output the value of the property.\n     */\n    outputValue?: boolean;\n}\n\n/**\n * This block will take a JSON pointer and parse it to get the value from the JSON object.\n * The output is an object and a property name.\n * Optionally, the block can also output the value of the property. This is configurable.\n */\nexport class FlowGraphJsonPointerParserBlock<P extends any, O extends FlowGraphAssetType> extends FlowGraphCachedOperationBlock<P> {\n    /**\n     * Output connection: The object that contains the property.\n     */\n    public readonly object: FlowGraphDataConnection<O>;\n\n    /**\n     * Output connection: The property name.\n     */\n    public readonly propertyName: FlowGraphDataConnection<string>;\n\n    /**\n     * Output connection: A function that can be used to update the value of the property.\n     */\n    public readonly setterFunction: FlowGraphDataConnection<(target: O, propertyName: string, value: P, context: FlowGraphContext) => void>;\n\n    /**\n     * Output connection: A function that can be used to get the value of the property.\n     */\n    public readonly getterFunction: FlowGraphDataConnection<(target: O, propertyName: string, context: FlowGraphContext) => P | undefined>;\n\n    /**\n     * Output connection: A function that can be used to get the interpolation animation property info.\n     */\n    public readonly generateAnimationsFunction: FlowGraphDataConnection<() => (keys: any[], fps: number, easingFunction?: EasingFunction) => Animation[]>;\n\n    /**\n     * The component with the templated inputs for the provided path.\n     */\n    public readonly templateComponent: FlowGraphPathConverterComponent;\n\n    constructor(\n        /**\n         * the configuration of the block\n         */\n        public override config: IFlowGraphJsonPointerParserBlockConfiguration\n    ) {\n        super(RichTypeAny, config);\n        this.object = this.registerDataOutput(\"object\", RichTypeAny);\n        this.propertyName = this.registerDataOutput(\"propertyName\", RichTypeAny);\n        this.setterFunction = this.registerDataOutput(\"setFunction\", RichTypeAny, this._setPropertyValue.bind(this));\n        this.getterFunction = this.registerDataOutput(\"getFunction\", RichTypeAny, this._getPropertyValue.bind(this));\n        this.generateAnimationsFunction = this.registerDataOutput(\"generateAnimationsFunction\", RichTypeAny, this._getInterpolationAnimationPropertyInfo.bind(this));\n        this.templateComponent = new FlowGraphPathConverterComponent(config.jsonPointer, this);\n    }\n\n    public override _doOperation(context: FlowGraphContext): P {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const value = accessorContainer.info.get(accessorContainer.object) as P;\n        const object = accessorContainer.info.getTarget?.(accessorContainer.object);\n        const propertyName = accessorContainer.info.getPropertyName?.[0](accessorContainer.object);\n        if (!object) {\n            throw new Error(\"Object is undefined\");\n        } else {\n            this.object.setValue(object, context);\n            if (propertyName) {\n                this.propertyName.setValue(propertyName, context);\n            }\n        }\n        return value;\n    }\n\n    private _setPropertyValue(_target: O, _propertyName: string, value: P, context: FlowGraphContext): void {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        if (type.startsWith(\"Color\")) {\n            value = ToColor(value as Vector4, type) as unknown as P;\n        }\n        accessorContainer.info.set?.(value, accessorContainer.object);\n    }\n\n    private _getPropertyValue(_target: O, _propertyName: string, context: FlowGraphContext): P | undefined {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        return accessorContainer.info.get(accessorContainer.object);\n    }\n\n    private _getInterpolationAnimationPropertyInfo(\n        _target: O,\n        _propertyName: string,\n        context: FlowGraphContext\n    ): (keys: any[], fps: number, animationType: number, easingFunction?: EasingFunction) => Animation[] {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        return (keys: any[], fps: number, animationType: number, easingFunction?: EasingFunction) => {\n            const animations: Animation[] = [];\n            // make sure keys are of the right type (in case of float3 color/vector)\n            const type = accessorContainer.info.type;\n            if (type.startsWith(\"Color\")) {\n                keys = keys.map((key) => {\n                    return {\n                        frame: key.frame,\n                        value: ToColor(key.value, type),\n                    };\n                });\n            }\n            accessorContainer.info.interpolation?.forEach((info, index) => {\n                const name = accessorContainer.info.getPropertyName?.[index](accessorContainer.object) || \"Animation-interpolation-\" + index;\n                // generate the keys based on interpolation info\n                let newKeys: any[] = keys;\n                if (animationType !== info.type) {\n                    // convert the keys to the right type\n                    newKeys = keys.map((key) => {\n                        return {\n                            frame: key.frame,\n                            value: info.getValue(undefined, key.value.asArray ? key.value.asArray() : [key.value], 0, 1),\n                        };\n                    });\n                }\n                const animationData = info.buildAnimations(accessorContainer.object, name, 60, newKeys);\n                animationData.forEach((animation) => {\n                    if (easingFunction) {\n                        animation.babylonAnimation.setEasingFunction(easingFunction);\n                    }\n                    animations.push(animation.babylonAnimation);\n                });\n            });\n\n            return animations;\n        };\n    }\n\n    /**\n     * Gets the class name of this block\n     * @returns the class name\n     */\n    public override getClassName(): string {\n        return FlowGraphBlockNames.JsonPointerParser;\n    }\n}\n\nfunction ToColor(value: any, expectedValue: string) {\n    if (value.getClassName().startsWith(\"Color\")) {\n        return value as unknown as Color3 | Color4;\n    }\n    if (expectedValue === \"Color3\") {\n        return new Color3(value.x, value.y, value.z);\n    } else if (expectedValue === \"Color4\") {\n        return new Color4(value.x, value.y, value.z, value.w);\n    }\n    return value;\n}\n\nRegisterClass(FlowGraphBlockNames.JsonPointerParser, FlowGraphJsonPointerParserBlock);\n"],
  "mappings": "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",
  "names": ["_a"]
}
