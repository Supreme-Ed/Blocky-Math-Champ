import {
  FlowGraphBinaryOperationBlock,
  init_flowGraphBinaryOperationBlock
} from "./chunk-4DQISBST.js";
import {
  FlowGraphUnaryOperationBlock,
  init_flowGraphUnaryOperationBlock
} from "./chunk-42KOJZHQ.js";
import {
  FlowGraphBlock,
  RichTypeBoolean,
  RichTypeMatrix,
  RichTypeNumber,
  RichTypeQuaternion,
  RichTypeVector3,
  getRichTypeByFlowGraphType,
  init_flowGraphBlock,
  init_flowGraphRichTypes
} from "./chunk-I4L6YYX4.js";
import {
  Matrix,
  Quaternion,
  Vector3,
  init_math_vector
} from "./chunk-3KKXJTKL.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-D6A73UHJ.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Math/flowGraphMatrixMathBlocks.js
var FlowGraphTransposeBlock, FlowGraphDeterminantBlock, FlowGraphInvertMatrixBlock, FlowGraphMatrixMultiplicationBlock, FlowGraphMatrixDecomposeBlock, FlowGraphMatrixComposeBlock;
var init_flowGraphMatrixMathBlocks = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Math/flowGraphMatrixMathBlocks.js"() {
    init_flowGraphBlock();
    init_flowGraphRichTypes();
    init_math_vector();
    init_typeStore();
    init_flowGraphUnaryOperationBlock();
    init_flowGraphBinaryOperationBlock();
    FlowGraphTransposeBlock = class extends FlowGraphUnaryOperationBlock {
      /**
       * Creates a new instance of the block.
       * @param config the configuration of the block
       */
      constructor(config) {
        super(getRichTypeByFlowGraphType(
          (config == null ? void 0 : config.matrixType) || "Matrix"
          /* FlowGraphTypes.Matrix */
        ), getRichTypeByFlowGraphType(
          (config == null ? void 0 : config.matrixType) || "Matrix"
          /* FlowGraphTypes.Matrix */
        ), (a) => a.transpose ? a.transpose() : Matrix.Transpose(a), "FlowGraphTransposeBlock", config);
      }
    };
    RegisterClass("FlowGraphTransposeBlock", FlowGraphTransposeBlock);
    FlowGraphDeterminantBlock = class extends FlowGraphUnaryOperationBlock {
      /**
       * Creates a new instance of the block.
       * @param config the configuration of the block
       */
      constructor(config) {
        super(getRichTypeByFlowGraphType(
          (config == null ? void 0 : config.matrixType) || "Matrix"
          /* FlowGraphTypes.Matrix */
        ), RichTypeNumber, (a) => a.determinant(), "FlowGraphDeterminantBlock", config);
      }
    };
    RegisterClass("FlowGraphDeterminantBlock", FlowGraphDeterminantBlock);
    FlowGraphInvertMatrixBlock = class extends FlowGraphUnaryOperationBlock {
      /**
       * Creates a new instance of the inverse block.
       * @param config the configuration of the block
       */
      constructor(config) {
        super(getRichTypeByFlowGraphType(
          (config == null ? void 0 : config.matrixType) || "Matrix"
          /* FlowGraphTypes.Matrix */
        ), getRichTypeByFlowGraphType(
          (config == null ? void 0 : config.matrixType) || "Matrix"
          /* FlowGraphTypes.Matrix */
        ), (a) => a.inverse ? a.inverse() : Matrix.Invert(a), "FlowGraphInvertMatrixBlock", config);
      }
    };
    RegisterClass("FlowGraphInvertMatrixBlock", FlowGraphInvertMatrixBlock);
    FlowGraphMatrixMultiplicationBlock = class extends FlowGraphBinaryOperationBlock {
      /**
       * Creates a new instance of the multiplication block.
       * Note - this is similar to the math multiplication if not using matrix per-component multiplication.
       * @param config the configuration of the block
       */
      constructor(config) {
        super(getRichTypeByFlowGraphType(
          (config == null ? void 0 : config.matrixType) || "Matrix"
          /* FlowGraphTypes.Matrix */
        ), getRichTypeByFlowGraphType(
          (config == null ? void 0 : config.matrixType) || "Matrix"
          /* FlowGraphTypes.Matrix */
        ), getRichTypeByFlowGraphType(
          (config == null ? void 0 : config.matrixType) || "Matrix"
          /* FlowGraphTypes.Matrix */
        ), (a, b) => b.multiply(a), "FlowGraphMatrixMultiplicationBlock", config);
      }
    };
    RegisterClass("FlowGraphMatrixMultiplicationBlock", FlowGraphMatrixMultiplicationBlock);
    FlowGraphMatrixDecomposeBlock = class extends FlowGraphBlock {
      constructor(config) {
        super(config);
        this.input = this.registerDataInput("input", RichTypeMatrix);
        this.position = this.registerDataOutput("position", RichTypeVector3);
        this.rotationQuaternion = this.registerDataOutput("rotationQuaternion", RichTypeQuaternion);
        this.scaling = this.registerDataOutput("scaling", RichTypeVector3);
        this.isValid = this.registerDataOutput("isValid", RichTypeBoolean, false);
      }
      _updateOutputs(context) {
        const cachedExecutionId = context._getExecutionVariable(this, "executionId", -1);
        const cachedPosition = context._getExecutionVariable(this, "cachedPosition", null);
        const cachedRotation = context._getExecutionVariable(this, "cachedRotation", null);
        const cachedScaling = context._getExecutionVariable(this, "cachedScaling", null);
        if (cachedExecutionId === context.executionId && cachedPosition && cachedRotation && cachedScaling) {
          this.position.setValue(cachedPosition, context);
          this.rotationQuaternion.setValue(cachedRotation, context);
          this.scaling.setValue(cachedScaling, context);
        } else {
          const matrix = this.input.getValue(context);
          const position = cachedPosition || new Vector3();
          const rotation = cachedRotation || new Quaternion();
          const scaling = cachedScaling || new Vector3();
          const m3 = Math.round(matrix.m[3] * 1e4) / 1e4;
          const m7 = Math.round(matrix.m[7] * 1e4) / 1e4;
          const m11 = Math.round(matrix.m[11] * 1e4) / 1e4;
          const m15 = Math.round(matrix.m[15] * 1e4) / 1e4;
          if (m3 !== 0 || m7 !== 0 || m11 !== 0 || m15 !== 1) {
            this.isValid.setValue(false, context);
            this.position.setValue(Vector3.Zero(), context);
            this.rotationQuaternion.setValue(Quaternion.Identity(), context);
            this.scaling.setValue(Vector3.One(), context);
            return;
          }
          const valid = matrix.decompose(scaling, rotation, position);
          this.isValid.setValue(valid, context);
          this.position.setValue(position, context);
          this.rotationQuaternion.setValue(rotation, context);
          this.scaling.setValue(scaling, context);
          context._setExecutionVariable(this, "cachedPosition", position);
          context._setExecutionVariable(this, "cachedRotation", rotation);
          context._setExecutionVariable(this, "cachedScaling", scaling);
          context._setExecutionVariable(this, "executionId", context.executionId);
        }
      }
      getClassName() {
        return "FlowGraphMatrixDecompose";
      }
    };
    RegisterClass("FlowGraphMatrixDecompose", FlowGraphMatrixDecomposeBlock);
    FlowGraphMatrixComposeBlock = class extends FlowGraphBlock {
      constructor(config) {
        super(config);
        this.position = this.registerDataInput("position", RichTypeVector3);
        this.rotationQuaternion = this.registerDataInput("rotationQuaternion", RichTypeQuaternion);
        this.scaling = this.registerDataInput("scaling", RichTypeVector3);
        this.value = this.registerDataOutput("value", RichTypeMatrix);
      }
      _updateOutputs(context) {
        const cachedExecutionId = context._getExecutionVariable(this, "executionId", -1);
        const cachedMatrix = context._getExecutionVariable(this, "cachedMatrix", null);
        if (cachedExecutionId === context.executionId && cachedMatrix) {
          this.value.setValue(cachedMatrix, context);
        } else {
          const matrix = Matrix.Compose(this.scaling.getValue(context), this.rotationQuaternion.getValue(context), this.position.getValue(context));
          this.value.setValue(matrix, context);
          context._setExecutionVariable(this, "cachedMatrix", matrix);
          context._setExecutionVariable(this, "executionId", context.executionId);
        }
      }
      getClassName() {
        return "FlowGraphMatrixCompose";
      }
    };
    RegisterClass("FlowGraphMatrixCompose", FlowGraphMatrixComposeBlock);
  }
});

export {
  FlowGraphTransposeBlock,
  FlowGraphDeterminantBlock,
  FlowGraphInvertMatrixBlock,
  FlowGraphMatrixMultiplicationBlock,
  FlowGraphMatrixDecomposeBlock,
  FlowGraphMatrixComposeBlock,
  init_flowGraphMatrixMathBlocks
};
//# sourceMappingURL=chunk-7GU3RIMZ.js.map
