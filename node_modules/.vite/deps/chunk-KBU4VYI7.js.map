{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts", "../../../dev/core/src/PostProcesses/thinPassPostProcess.ts", "../../../dev/core/src/PostProcesses/passPostProcess.ts", "../../../dev/core/src/Misc/textureTools.ts"],
  "sourcesContent": ["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     * @returns the area\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Clamp(r, 0, max);\r\n                        g = Clamp(g, 0, max);\r\n                        b = Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, EffectWrapperCreationOptions, AbstractEngine } from \"core/index\";\r\nimport { EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * PassPostProcess which produces an output the same as it's input\r\n */\r\nexport class ThinPassPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"pass\";\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/pass.fragment\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/pass.fragment\")]));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n\r\n    /**\r\n     * Constructs a new pass post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinPassPostProcess.FragmentUrl,\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)\r\n */\r\nexport class ThinPassCubePostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"passCube\";\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/passCube.fragment\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/passCube.fragment\")]));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n\r\n    /**\r\n     * Creates the PassCubePostProcess\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinPassCubePostProcess.FragmentUrl,\r\n            defines: \"#define POSITIVEX\",\r\n        });\r\n    }\r\n\r\n    private _face = 0;\r\n\r\n    /**\r\n     * Gets or sets the cube face to display.\r\n     *  * 0 is +X\r\n     *  * 1 is -X\r\n     *  * 2 is +Y\r\n     *  * 3 is -Y\r\n     *  * 4 is +Z\r\n     *  * 5 is -Z\r\n     */\r\n    public get face(): number {\r\n        return this._face;\r\n    }\r\n\r\n    public set face(value: number) {\r\n        if (value < 0 || value > 5) {\r\n            return;\r\n        }\r\n\r\n        this._face = value;\r\n        switch (this._face) {\r\n            case 0:\r\n                this.updateEffect(\"#define POSITIVEX\");\r\n                break;\r\n            case 1:\r\n                this.updateEffect(\"#define NEGATIVEX\");\r\n                break;\r\n            case 2:\r\n                this.updateEffect(\"#define POSITIVEY\");\r\n                break;\r\n            case 3:\r\n                this.updateEffect(\"#define NEGATIVEY\");\r\n                break;\r\n            case 4:\r\n                this.updateEffect(\"#define POSITIVEZ\");\r\n                break;\r\n            case 5:\r\n                this.updateEffect(\"#define NEGATIVEZ\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport { ThinPassCubePostProcess, ThinPassPostProcess } from \"./thinPassPostProcess\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * PassPostProcess which produces an output the same as it's input\r\n */\r\nexport class PassPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PassPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates the PassPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinPassPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinPassPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PassPostProcess\", PassPostProcess);\r\n\r\n/**\r\n * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)\r\n */\r\nexport class PassCubePostProcess extends PostProcess {\r\n    /**\r\n     * Gets or sets the cube face to display.\r\n     *  * 0 is +X\r\n     *  * 1 is -X\r\n     *  * 2 is +Y\r\n     *  * 3 is -Y\r\n     *  * 4 is +Z\r\n     *  * 5 is -Z\r\n     */\r\n    @serialize()\r\n    public get face(): number {\r\n        return this._effectWrapper.face;\r\n    }\r\n\r\n    public set face(value: number) {\r\n        this._effectWrapper.face = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassCubePostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PassCubePostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinPassCubePostProcess;\r\n\r\n    /**\r\n     * Creates the PassCubePostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinPassPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinPassCubePostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassCubePostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nAbstractEngine._RescalePostProcessFactory = (engine: AbstractEngine) => {\r\n    return new PassPostProcess(\"rescale\", 1, null, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, engine, false, Constants.TEXTURETYPE_UNSIGNED_BYTE);\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { ShaderLanguage } from \"core/Materials\";\r\n\r\n/**\r\n * Uses the GPU to create a copy texture rescaled at a given size\r\n * @param texture Texture to copy from\r\n * @param width defines the desired width\r\n * @param height defines the desired height\r\n * @param useBilinearMode defines if bilinear mode has to be used\r\n * @returns the generated texture\r\n */\r\nexport function CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n    const scene = <Scene>texture.getScene();\r\n    const engine = scene.getEngine();\r\n\r\n    const rtt = new RenderTargetTexture(\r\n        \"resized\" + texture.name,\r\n        { width: width, height: height },\r\n        scene,\r\n        !texture.noMipmap,\r\n        true,\r\n        (<InternalTexture>texture._texture).type,\r\n        false,\r\n        texture.samplingMode,\r\n        false\r\n    );\r\n\r\n    rtt.wrapU = texture.wrapU;\r\n    rtt.wrapV = texture.wrapV;\r\n    rtt.uOffset = texture.uOffset;\r\n    rtt.vOffset = texture.vOffset;\r\n    rtt.uScale = texture.uScale;\r\n    rtt.vScale = texture.vScale;\r\n    rtt.uAng = texture.uAng;\r\n    rtt.vAng = texture.vAng;\r\n    rtt.wAng = texture.wAng;\r\n    rtt.coordinatesIndex = texture.coordinatesIndex;\r\n    rtt.level = texture.level;\r\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n    (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    const passPostProcess = new PassPostProcess(\r\n        \"pass\",\r\n        1,\r\n        null,\r\n        useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE,\r\n        engine,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    );\r\n    passPostProcess.externalTextureSamplerBinding = true;\r\n    passPostProcess.onEffectCreatedObservable.addOnce((e) => {\r\n        e.executeWhenCompiled(() => {\r\n            passPostProcess.onApply = function (effect) {\r\n                effect.setTexture(\"textureSampler\", texture);\r\n            };\r\n\r\n            const internalTexture = rtt.renderTarget;\r\n\r\n            if (internalTexture) {\r\n                scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n                engine.unBindFramebuffer(internalTexture);\r\n                rtt.disposeFramebufferObjects();\r\n                passPostProcess.dispose();\r\n\r\n                rtt.getInternalTexture()!.isReady = true;\r\n            }\r\n        });\r\n    });\r\n\r\n    return rtt;\r\n}\r\n\r\n/**\r\n * Apply a post process to a texture\r\n * @param postProcessName name of the fragment post process\r\n * @param internalTexture the texture to encode\r\n * @param scene the scene hosting the texture\r\n * @param type type of the output texture. If not provided, use the one from internalTexture\r\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n * @param format format of the output texture. If not provided, use the one from internalTexture\r\n * @param width width of the output texture. If not provided, use the one from internalTexture\r\n * @param height height of the output texture. If not provided, use the one from internalTexture\r\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n */\r\nexport function ApplyPostProcess(\r\n    postProcessName: string,\r\n    internalTexture: InternalTexture,\r\n    scene: Scene,\r\n    type?: number,\r\n    samplingMode?: number,\r\n    format?: number,\r\n    width?: number,\r\n    height?: number\r\n): Promise<InternalTexture> {\r\n    // Gets everything ready.\r\n    const engine = internalTexture.getEngine() as AbstractEngine;\r\n\r\n    internalTexture.isReady = false;\r\n\r\n    samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n    type = type ?? internalTexture.type;\r\n    format = format ?? internalTexture.format;\r\n    width = width ?? internalTexture.width;\r\n    height = height ?? internalTexture.height;\r\n\r\n    if (type === -1) {\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        // Create the post process\r\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\r\n        postProcess.externalTextureSamplerBinding = true;\r\n\r\n        // Hold the output of the decoding.\r\n        const encodedTexture = engine.createRenderTargetTexture(\r\n            { width: width as number, height: height as number },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format,\r\n            }\r\n        );\r\n\r\n        postProcess.onEffectCreatedObservable.addOnce((e) => {\r\n            e.executeWhenCompiled(() => {\r\n                // PP Render Pass\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", internalTexture);\r\n                    effect.setFloat2(\"scale\", 1, 1);\r\n                };\r\n                scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._releaseTexture(internalTexture);\r\n                if (postProcess) {\r\n                    postProcess.dispose();\r\n                }\r\n\r\n                // Internal Swap\r\n                encodedTexture._swapAndDie(internalTexture);\r\n\r\n                // Ready to get rolling again.\r\n                internalTexture.type = type!;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                internalTexture.isReady = true;\r\n\r\n                resolve(internalTexture);\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\nlet floatView: Float32Array;\r\nlet int32View: Int32Array;\r\n/**\r\n * Converts a number to half float\r\n * @param value number to convert\r\n * @returns converted number\r\n */\r\nexport function ToHalfFloat(value: number): number {\r\n    if (!floatView) {\r\n        floatView = new Float32Array(1);\r\n        int32View = new Int32Array(floatView.buffer);\r\n    }\r\n\r\n    floatView[0] = value;\r\n    const x = int32View[0];\r\n\r\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n     * half, return signed zero. */\r\n    if (e < 103) {\r\n        return bits;\r\n    }\r\n\r\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n    if (e > 142) {\r\n        bits |= 0x7c00;\r\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n         * not Inf, so make sure we set one mantissa bit too. */\r\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\r\n        return bits;\r\n    }\r\n\r\n    /* If exponent underflows but not too much, return a denormal */\r\n    if (e < 113) {\r\n        m |= 0x0800;\r\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n         * to 1, which is OK. */\r\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n        return bits;\r\n    }\r\n\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Converts a half float to a number\r\n * @param value half float to convert\r\n * @returns converted half float\r\n */\r\nexport function FromHalfFloat(value: number): number {\r\n    const s = (value & 0x8000) >> 15;\r\n    const e = (value & 0x7c00) >> 10;\r\n    const f = value & 0x03ff;\r\n\r\n    if (e === 0) {\r\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1f) {\r\n        return f ? NaN : (s ? -1 : 1) * Infinity;\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\nconst ProcessAsync = async (texture: BaseTexture, width: number, height: number, face: number, lod: number): Promise<Uint8Array> => {\r\n    const scene = texture.getScene()!;\r\n    const engine = scene.getEngine();\r\n\r\n    if (!engine.isWebGPU) {\r\n        if (texture.isCube) {\r\n            await import(\"../Shaders/lodCube.fragment\");\r\n        } else {\r\n            await import(\"../Shaders/lod.fragment\");\r\n        }\r\n    } else {\r\n        if (texture.isCube) {\r\n            await import(\"../ShadersWGSL/lodCube.fragment\");\r\n        } else {\r\n            await import(\"../ShadersWGSL/lod.fragment\");\r\n        }\r\n    }\r\n\r\n    let lodPostProcess: PostProcess;\r\n\r\n    if (!texture.isCube) {\r\n        lodPostProcess = new PostProcess(\"lod\", \"lod\", {\r\n            uniforms: [\"lod\", \"gamma\"],\r\n            samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,\r\n            engine,\r\n            shaderLanguage: engine.isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n        });\r\n    } else {\r\n        const faceDefines = [\"#define POSITIVEX\", \"#define NEGATIVEX\", \"#define POSITIVEY\", \"#define NEGATIVEY\", \"#define POSITIVEZ\", \"#define NEGATIVEZ\"];\r\n        lodPostProcess = new PostProcess(\"lodCube\", \"lodCube\", {\r\n            uniforms: [\"lod\", \"gamma\"],\r\n            samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,\r\n            engine,\r\n            defines: faceDefines[face],\r\n            shaderLanguage: engine.isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n        });\r\n    }\r\n\r\n    await new Promise((resolve) => {\r\n        lodPostProcess.onEffectCreatedObservable.addOnce((e) => {\r\n            e.executeWhenCompiled(() => {\r\n                resolve(0);\r\n            });\r\n        });\r\n    });\r\n\r\n    const rtt = new RenderTargetTexture(\"temp\", { width: width, height: height }, scene, false);\r\n\r\n    lodPostProcess.onApply = function (effect) {\r\n        effect.setTexture(\"textureSampler\", texture);\r\n        effect.setFloat(\"lod\", lod);\r\n        effect.setInt(\"gamma\", texture.gammaSpace ? 1 : 0);\r\n    };\r\n\r\n    const internalTexture = texture.getInternalTexture();\r\n\r\n    try {\r\n        if (rtt.renderTarget && internalTexture) {\r\n            const samplingMode = internalTexture.samplingMode;\r\n            if (lod !== 0) {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);\r\n            } else {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST);\r\n            }\r\n\r\n            scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);\r\n            texture.updateSamplingMode(samplingMode);\r\n\r\n            //Reading datas from WebGL\r\n            const bufferView = await engine.readPixels(0, 0, width, height);\r\n            const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);\r\n\r\n            // Unbind\r\n            engine.unBindFramebuffer(rtt.renderTarget);\r\n\r\n            return data;\r\n        } else {\r\n            throw Error(\"Render to texture failed.\");\r\n        }\r\n    } finally {\r\n        rtt.dispose();\r\n        lodPostProcess.dispose();\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n * @param texture the source texture\r\n * @param width the width of the result, which does not have to match the source texture width\r\n * @param height the height of the result, which does not have to match the source texture height\r\n * @param face if the texture has multiple faces, the face index to use for the source\r\n * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n * @returns the 8-bit texture data\r\n */\r\nexport async function GetTextureDataAsync(texture: BaseTexture, width: number, height: number, face: number = 0, lod: number = 0): Promise<Uint8Array> {\r\n    if (!texture.isReady() && texture._texture) {\r\n        await new Promise((resolve, reject) => {\r\n            if (texture._texture === null) {\r\n                reject(0);\r\n                return;\r\n            }\r\n            texture._texture.onLoadedObservable.addOnce(() => {\r\n                resolve(0);\r\n            });\r\n        });\r\n    }\r\n    return await ProcessAsync(texture, width, height, face, lod);\r\n}\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const TextureTools = {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @returns the generated texture\r\n     */\r\n    CreateResizedCopy,\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    ApplyPostProcess,\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    ToHalfFloat,\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    FromHalfFloat,\r\n\r\n    /**\r\n     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n     * @param texture the source texture\r\n     * @param width the width of the result, which does not have to match the source texture width\r\n     * @param height the height of the result, which does not have to match the source texture height\r\n     * @param face if the texture has multiple faces, the face index to use for the source\r\n     * @param channels a filter for which of the RGBA channels to return in the result\r\n     * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n     * @returns the 8-bit texture data\r\n     */\r\n    GetTextureDataAsync,\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
