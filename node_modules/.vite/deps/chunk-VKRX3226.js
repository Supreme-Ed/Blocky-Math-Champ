import {
  init_depth_fragment
} from "./chunk-NYYRCEFE.js";
import {
  init_depth_vertex
} from "./chunk-FJO5PYLJ.js";
import {
  Light,
  init_light
} from "./chunk-5FM3JMTN.js";
import {
  Engine,
  PostProcess,
  init_engine,
  init_postProcess
} from "./chunk-JTGDYYBG.js";
import {
  EffectWrapper,
  init_effectRenderer
} from "./chunk-4WIVT75W.js";
import {
  RenderTargetTexture,
  init_renderTargetTexture
} from "./chunk-BAFVKOIM.js";
import {
  PostProcessManager,
  RenderingManager,
  init_postProcessManager,
  init_renderingManager
} from "./chunk-PFANPAXU.js";
import {
  EffectFallbacks,
  init_effectFallbacks
} from "./chunk-MTXAMDYK.js";
import {
  Texture,
  init_texture
} from "./chunk-OM2XJLAR.js";
import {
  BoundingInfo,
  init_boundingInfo
} from "./chunk-T32XCSIZ.js";
import {
  BindBonesParameters,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  PrepareDefinesAndAttributesForMorphTargets,
  PushAttributesForInstances,
  addClipPlaneUniforms,
  bindClipPlane,
  init_clipPlaneMaterialHelper,
  init_materialHelper_functions,
  prepareStringDefinesForClipPlanes
} from "./chunk-LIM4KBOY.js";
import {
  DrawWrapper,
  init_drawWrapper
} from "./chunk-7JV5HNOV.js";
import {
  VertexBuffer,
  init_buffer
} from "./chunk-V4TBJFFE.js";
import {
  Camera,
  init_camera
} from "./chunk-VOJLNPRP.js";
import {
  SerializationHelper,
  init_decorators_serialization
} from "./chunk-5WVONG5F.js";
import {
  __decorate,
  init_decorators,
  init_tslib_es6,
  serialize,
  serializeAsVector2
} from "./chunk-IZLWPSPC.js";
import {
  Matrix,
  Vector2,
  Vector3,
  init_math_vector
} from "./chunk-3KKXJTKL.js";
import {
  _WarnImport,
  init_devTools
} from "./chunk-WRMUGWS2.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-F6F2OSPP.js";
import {
  Observable,
  init_observable
} from "./chunk-DIMHUU43.js";
import {
  Logger,
  init_logger
} from "./chunk-CLHHKTPI.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-IU6YKOYY.js";
import {
  Color4,
  init_math_color
} from "./chunk-FBNFE7ZR.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-D6A73UHJ.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/PostProcesses/thinBlurPostProcess.js
var ThinBlurPostProcess;
var init_thinBlurPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinBlurPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinBlurPostProcess = class _ThinBlurPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(Promise.all([import("./kernelBlur.fragment-62PSKAVI.js"), import("./kernelBlur.vertex-NG7YEIOH.js")]));
        } else {
          list.push(Promise.all([import("./kernelBlur.fragment-5NR6UEUR.js"), import("./kernelBlur.vertex-BMJUI3IY.js")]));
        }
      }
      /**
       * Constructs a new blur post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param direction Direction in which to apply the blur
       * @param kernel Kernel size of the blur
       * @param options Options to configure the effect
       */
      constructor(name2, engine = null, direction, kernel, options) {
        const blockCompilationFinal = !!(options == null ? void 0 : options.blockCompilation);
        super({
          ...options,
          name: name2,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinBlurPostProcess.FragmentUrl,
          uniforms: _ThinBlurPostProcess.Uniforms,
          samplers: _ThinBlurPostProcess.Samplers,
          vertexUrl: _ThinBlurPostProcess.VertexUrl,
          blockCompilation: true
        });
        this._packedFloat = false;
        this._staticDefines = "";
        this.textureWidth = 0;
        this.textureHeight = 0;
        this._staticDefines = options ? Array.isArray(options.defines) ? options.defines.join("\n") : options.defines || "" : "";
        this.options.blockCompilation = blockCompilationFinal;
        if (direction !== void 0) {
          this.direction = direction;
        }
        if (kernel !== void 0) {
          this.kernel = kernel;
        }
      }
      /**
       * Sets the length in pixels of the blur sample region
       */
      set kernel(v) {
        if (this._idealKernel === v) {
          return;
        }
        v = Math.max(v, 1);
        this._idealKernel = v;
        this._kernel = this._nearestBestKernel(v);
        if (!this.options.blockCompilation) {
          this._updateParameters();
        }
      }
      /**
       * Gets the length in pixels of the blur sample region
       */
      get kernel() {
        return this._idealKernel;
      }
      /**
       * Sets whether or not the blur needs to unpack/repack floats
       */
      set packedFloat(v) {
        if (this._packedFloat === v) {
          return;
        }
        this._packedFloat = v;
        if (!this.options.blockCompilation) {
          this._updateParameters();
        }
      }
      /**
       * Gets whether or not the blur is unpacking/repacking floats
       */
      get packedFloat() {
        return this._packedFloat;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        this._drawWrapper.effect.setFloat2("delta", 1 / this.textureWidth * this.direction.x, 1 / this.textureHeight * this.direction.y);
      }
      /** @internal */
      _updateParameters(onCompiled, onError) {
        const N = this._kernel;
        const centerIndex = (N - 1) / 2;
        let offsets = [];
        let weights = [];
        let totalWeight = 0;
        for (let i = 0; i < N; i++) {
          const u = i / (N - 1);
          const w = this._gaussianWeight(u * 2 - 1);
          offsets[i] = i - centerIndex;
          weights[i] = w;
          totalWeight += w;
        }
        for (let i = 0; i < weights.length; i++) {
          weights[i] /= totalWeight;
        }
        const linearSamplingWeights = [];
        const linearSamplingOffsets = [];
        const linearSamplingMap = [];
        for (let i = 0; i <= centerIndex; i += 2) {
          const j = Math.min(i + 1, Math.floor(centerIndex));
          const singleCenterSample = i === j;
          if (singleCenterSample) {
            linearSamplingMap.push({ o: offsets[i], w: weights[i] });
          } else {
            const sharedCell = j === centerIndex;
            const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);
            const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
            if (offsetLinear === 0) {
              linearSamplingMap.push({ o: offsets[i], w: weights[i] });
              linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });
            } else {
              linearSamplingMap.push({ o: offsetLinear, w: weightLinear });
              linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });
            }
          }
        }
        for (let i = 0; i < linearSamplingMap.length; i++) {
          linearSamplingOffsets[i] = linearSamplingMap[i].o;
          linearSamplingWeights[i] = linearSamplingMap[i].w;
        }
        offsets = linearSamplingOffsets;
        weights = linearSamplingWeights;
        const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === 1 ? 1 : 0);
        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1;
        let varyingCount = Math.min(offsets.length, freeVaryingVec2);
        let defines = "";
        defines += this._staticDefines;
        if (this._staticDefines.indexOf("DOF") != -1) {
          defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}
`;
          varyingCount--;
        }
        for (let i = 0; i < varyingCount; i++) {
          defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}
`;
          defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}
`;
        }
        let depCount = 0;
        for (let i = freeVaryingVec2; i < offsets.length; i++) {
          defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}
`;
          defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}
`;
          depCount++;
        }
        if (this.packedFloat) {
          defines += `#define PACKEDFLOAT 1`;
        }
        this.options.blockCompilation = false;
        this.updateEffect(defines, null, null, {
          varyingCount,
          depCount
        }, onCompiled, onError);
      }
      /**
       * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
       * Other odd kernels optimize correctly but require proportionally more samples, even kernels are
       * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
       * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
       * The gaps between physical kernels are compensated for in the weighting of the samples
       * @param idealKernel Ideal blur kernel.
       * @returns Nearest best kernel.
       */
      _nearestBestKernel(idealKernel) {
        const v = Math.round(idealKernel);
        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {
          if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {
            return Math.max(k, 3);
          }
        }
        return Math.max(v, 3);
      }
      /**
       * Calculates the value of a Gaussian distribution with sigma 3 at a given point.
       * @param x The point on the Gaussian distribution to sample.
       * @returns the value of the Gaussian function at x.
       */
      _gaussianWeight(x) {
        const sigma = 1 / 3;
        const denominator = Math.sqrt(2 * Math.PI) * sigma;
        const exponent = -(x * x / (2 * sigma * sigma));
        const weight = 1 / denominator * Math.exp(exponent);
        return weight;
      }
      /**
       * Generates a string that can be used as a floating point number in GLSL.
       * @param x Value to print.
       * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).
       * @returns GLSL float string.
       */
      _glslFloat(x, decimalFigures = 8) {
        return x.toFixed(decimalFigures).replace(/0+$/, "");
      }
    };
    ThinBlurPostProcess.VertexUrl = "kernelBlur";
    ThinBlurPostProcess.FragmentUrl = "kernelBlur";
    ThinBlurPostProcess.Uniforms = ["delta", "direction"];
    ThinBlurPostProcess.Samplers = ["circleOfConfusionSampler"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js
var BlurPostProcess;
var init_blurPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_texture();
    init_typeStore();
    init_decorators();
    init_decorators_serialization();
    init_thinBlurPostProcess();
    BlurPostProcess = class _BlurPostProcess extends PostProcess {
      /** The direction in which to blur the image. */
      get direction() {
        return this._effectWrapper.direction;
      }
      set direction(value) {
        this._effectWrapper.direction = value;
      }
      /**
       * Sets the length in pixels of the blur sample region
       */
      set kernel(v) {
        this._effectWrapper.kernel = v;
      }
      /**
       * Gets the length in pixels of the blur sample region
       */
      get kernel() {
        return this._effectWrapper.kernel;
      }
      /**
       * Sets whether or not the blur needs to unpack/repack floats
       */
      set packedFloat(v) {
        this._effectWrapper.packedFloat = v;
      }
      /**
       * Gets whether or not the blur is unpacking/repacking floats
       */
      get packedFloat() {
        return this._effectWrapper.packedFloat;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "BlurPostProcess" string
       */
      getClassName() {
        return "BlurPostProcess";
      }
      /**
       * Creates a new instance BlurPostProcess
       * @param name The name of the effect.
       * @param direction The direction in which to blur the image.
       * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.
       * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param defines
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
       */
      constructor(name2, direction, kernel, options, camera = null, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, defines = "", blockCompilation = false, textureFormat = 5) {
        const blockCompilationFinal = typeof options === "number" ? blockCompilation : !!options.blockCompilation;
        const localOptions = {
          uniforms: ThinBlurPostProcess.Uniforms,
          samplers: ThinBlurPostProcess.Samplers,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          vertexUrl: ThinBlurPostProcess.VertexUrl,
          indexParameters: { varyingCount: 0, depCount: 0 },
          textureFormat,
          defines,
          ...options,
          blockCompilation: true
        };
        super(name2, ThinBlurPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinBlurPostProcess(name2, engine, void 0, void 0, localOptions) : void 0,
          ...localOptions
        });
        this._effectWrapper.options.blockCompilation = blockCompilationFinal;
        this.direction = direction;
        this.onApplyObservable.add(() => {
          this._effectWrapper.textureWidth = this._outputTexture ? this._outputTexture.width : this.width;
          this._effectWrapper.textureHeight = this._outputTexture ? this._outputTexture.height : this.height;
        });
        this.kernel = kernel;
      }
      updateEffect(_defines = null, _uniforms = null, _samplers = null, _indexParameters, onCompiled, onError) {
        this._effectWrapper._updateParameters(onCompiled, onError);
      }
      /**
       * @internal
       */
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new _BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, void 0, false);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    __decorate([
      serializeAsVector2()
    ], BlurPostProcess.prototype, "direction", null);
    __decorate([
      serialize()
    ], BlurPostProcess.prototype, "kernel", null);
    __decorate([
      serialize()
    ], BlurPostProcess.prototype, "packedFloat", null);
    RegisterClass("BABYLON.BlurPostProcess", BlurPostProcess);
  }
});

// node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js
var ShadowGenerator;
var init_shadowGenerator = __esm({
  "node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js"() {
    init_math_vector();
    init_math_color();
    init_buffer();
    init_light();
    init_texture();
    init_renderTargetTexture();
    init_postProcess();
    init_blurPostProcess();
    init_observable();
    init_devTools();
    init_effectFallbacks();
    init_renderingManager();
    init_drawWrapper();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    ShadowGenerator = class _ShadowGenerator {
      /**
       * Gets the bias: offset applied on the depth preventing acnea (in light direction).
       */
      get bias() {
        return this._bias;
      }
      /**
       * Sets the bias: offset applied on the depth preventing acnea (in light direction).
       */
      set bias(bias) {
        this._bias = bias;
      }
      /**
       * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
       */
      get normalBias() {
        return this._normalBias;
      }
      /**
       * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
       */
      set normalBias(normalBias) {
        this._normalBias = normalBias;
      }
      /**
       * Gets the blur box offset: offset applied during the blur pass.
       * Only useful if useKernelBlur = false
       */
      get blurBoxOffset() {
        return this._blurBoxOffset;
      }
      /**
       * Sets the blur box offset: offset applied during the blur pass.
       * Only useful if useKernelBlur = false
       */
      set blurBoxOffset(value) {
        if (this._blurBoxOffset === value) {
          return;
        }
        this._blurBoxOffset = value;
        this._disposeBlurPostProcesses();
      }
      /**
       * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
       * 2 means half of the size.
       */
      get blurScale() {
        return this._blurScale;
      }
      /**
       * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
       * 2 means half of the size.
       */
      set blurScale(value) {
        if (this._blurScale === value) {
          return;
        }
        this._blurScale = value;
        this._disposeBlurPostProcesses();
      }
      /**
       * Gets the blur kernel: kernel size of the blur pass.
       * Only useful if useKernelBlur = true
       */
      get blurKernel() {
        return this._blurKernel;
      }
      /**
       * Sets the blur kernel: kernel size of the blur pass.
       * Only useful if useKernelBlur = true
       */
      set blurKernel(value) {
        if (this._blurKernel === value) {
          return;
        }
        this._blurKernel = value;
        this._disposeBlurPostProcesses();
      }
      /**
       * Gets whether the blur pass is a kernel blur (if true) or box blur.
       * Only useful in filtered mode (useBlurExponentialShadowMap...)
       */
      get useKernelBlur() {
        return this._useKernelBlur;
      }
      /**
       * Sets whether the blur pass is a kernel blur (if true) or box blur.
       * Only useful in filtered mode (useBlurExponentialShadowMap...)
       */
      set useKernelBlur(value) {
        if (this._useKernelBlur === value) {
          return;
        }
        this._useKernelBlur = value;
        this._disposeBlurPostProcesses();
      }
      /**
       * Gets the depth scale used in ESM mode.
       */
      get depthScale() {
        return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
      }
      /**
       * Sets the depth scale used in ESM mode.
       * This can override the scale stored on the light.
       */
      set depthScale(value) {
        this._depthScale = value;
      }
      _validateFilter(filter) {
        return filter;
      }
      /**
       * Gets the current mode of the shadow generator (normal, PCF, ESM...).
       * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
       */
      get filter() {
        return this._filter;
      }
      /**
       * Sets the current mode of the shadow generator (normal, PCF, ESM...).
       * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
       */
      set filter(value) {
        value = this._validateFilter(value);
        if (this._light.needCube()) {
          if (value === _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
            this.useExponentialShadowMap = true;
            return;
          } else if (value === _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
            this.useCloseExponentialShadowMap = true;
            return;
          } else if (value === _ShadowGenerator.FILTER_PCF || value === _ShadowGenerator.FILTER_PCSS) {
            this.usePoissonSampling = true;
            return;
          }
        }
        if (value === _ShadowGenerator.FILTER_PCF || value === _ShadowGenerator.FILTER_PCSS) {
          if (!this._scene.getEngine()._features.supportShadowSamplers) {
            this.usePoissonSampling = true;
            return;
          }
        }
        if (this._filter === value) {
          return;
        }
        this._filter = value;
        this._disposeBlurPostProcesses();
        this._applyFilterValues();
        this._light._markMeshesAsLightDirty();
      }
      /**
       * Gets if the current filter is set to Poisson Sampling.
       */
      get usePoissonSampling() {
        return this.filter === _ShadowGenerator.FILTER_POISSONSAMPLING;
      }
      /**
       * Sets the current filter to Poisson Sampling.
       */
      set usePoissonSampling(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_POISSONSAMPLING);
        if (!value && this.filter !== _ShadowGenerator.FILTER_POISSONSAMPLING) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to ESM.
       */
      get useExponentialShadowMap() {
        return this.filter === _ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;
      }
      /**
       * Sets the current filter is to ESM.
       */
      set useExponentialShadowMap(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);
        if (!value && this.filter !== _ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to filtered ESM.
       */
      get useBlurExponentialShadowMap() {
        return this.filter === _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;
      }
      /**
       * Gets if the current filter is set to filtered  ESM.
       */
      set useBlurExponentialShadowMap(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);
        if (!value && this.filter !== _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to "close ESM" (using the inverse of the
       * exponential to prevent steep falloff artifacts).
       */
      get useCloseExponentialShadowMap() {
        return this.filter === _ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;
      }
      /**
       * Sets the current filter to "close ESM" (using the inverse of the
       * exponential to prevent steep falloff artifacts).
       */
      set useCloseExponentialShadowMap(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);
        if (!value && this.filter !== _ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
       * exponential to prevent steep falloff artifacts).
       */
      get useBlurCloseExponentialShadowMap() {
        return this.filter === _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
      }
      /**
       * Sets the current filter to filtered "close ESM" (using the inverse of the
       * exponential to prevent steep falloff artifacts).
       */
      set useBlurCloseExponentialShadowMap(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
        if (!value && this.filter !== _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to "PCF" (percentage closer filtering).
       */
      get usePercentageCloserFiltering() {
        return this.filter === _ShadowGenerator.FILTER_PCF;
      }
      /**
       * Sets the current filter to "PCF" (percentage closer filtering).
       */
      set usePercentageCloserFiltering(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_PCF);
        if (!value && this.filter !== _ShadowGenerator.FILTER_PCF) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets the PCF or PCSS Quality.
       * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
       */
      get filteringQuality() {
        return this._filteringQuality;
      }
      /**
       * Sets the PCF or PCSS Quality.
       * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
       */
      set filteringQuality(filteringQuality) {
        if (this._filteringQuality === filteringQuality) {
          return;
        }
        this._filteringQuality = filteringQuality;
        this._disposeBlurPostProcesses();
        this._applyFilterValues();
        this._light._markMeshesAsLightDirty();
      }
      /**
       * Gets if the current filter is set to "PCSS" (contact hardening).
       */
      get useContactHardeningShadow() {
        return this.filter === _ShadowGenerator.FILTER_PCSS;
      }
      /**
       * Sets the current filter to "PCSS" (contact hardening).
       */
      set useContactHardeningShadow(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_PCSS);
        if (!value && this.filter !== _ShadowGenerator.FILTER_PCSS) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
       * Using a ratio helps keeping shape stability independently of the map size.
       *
       * It does not account for the light projection as it was having too much
       * instability during the light setup or during light position changes.
       *
       * Only valid if useContactHardeningShadow is true.
       */
      get contactHardeningLightSizeUVRatio() {
        return this._contactHardeningLightSizeUVRatio;
      }
      /**
       * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
       * Using a ratio helps keeping shape stability independently of the map size.
       *
       * It does not account for the light projection as it was having too much
       * instability during the light setup or during light position changes.
       *
       * Only valid if useContactHardeningShadow is true.
       */
      set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio) {
        this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
      }
      /** Gets or sets the actual darkness of a shadow */
      get darkness() {
        return this._darkness;
      }
      set darkness(value) {
        this.setDarkness(value);
      }
      /**
       * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
       * 0 means strongest and 1 would means no shadow.
       * @returns the darkness.
       */
      getDarkness() {
        return this._darkness;
      }
      /**
       * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
       * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
       * @returns the shadow generator allowing fluent coding.
       */
      setDarkness(darkness) {
        if (darkness >= 1) {
          this._darkness = 1;
        } else if (darkness <= 0) {
          this._darkness = 0;
        } else {
          this._darkness = darkness;
        }
        return this;
      }
      /** Gets or sets the ability to have transparent shadow */
      get transparencyShadow() {
        return this._transparencyShadow;
      }
      set transparencyShadow(value) {
        this.setTransparencyShadow(value);
      }
      /**
       * Sets the ability to have transparent shadow (boolean).
       * @param transparent True if transparent else False
       * @returns the shadow generator allowing fluent coding
       */
      setTransparencyShadow(transparent) {
        this._transparencyShadow = transparent;
        return this;
      }
      /**
       * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
       * @returns The render target texture if present otherwise, null
       */
      getShadowMap() {
        return this._shadowMap;
      }
      /**
       * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
       * @returns The render target texture if the shadow map is present otherwise, null
       */
      getShadowMapForRendering() {
        if (this._shadowMap2) {
          return this._shadowMap2;
        }
        return this._shadowMap;
      }
      /**
       * Gets the class name of that object
       * @returns "ShadowGenerator"
       */
      getClassName() {
        return _ShadowGenerator.CLASSNAME;
      }
      /**
       * Helper function to add a mesh and its descendants to the list of shadow casters.
       * @param mesh Mesh to add
       * @param includeDescendants boolean indicating if the descendants should be added. Default to true
       * @returns the Shadow Generator itself
       */
      addShadowCaster(mesh, includeDescendants = true) {
        if (!this._shadowMap) {
          return this;
        }
        if (!this._shadowMap.renderList) {
          this._shadowMap.renderList = [];
        }
        if (this._shadowMap.renderList.indexOf(mesh) === -1) {
          this._shadowMap.renderList.push(mesh);
        }
        if (includeDescendants) {
          for (const childMesh of mesh.getChildMeshes()) {
            if (this._shadowMap.renderList.indexOf(childMesh) === -1) {
              this._shadowMap.renderList.push(childMesh);
            }
          }
        }
        return this;
      }
      /**
       * Helper function to remove a mesh and its descendants from the list of shadow casters
       * @param mesh Mesh to remove
       * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
       * @returns the Shadow Generator itself
       */
      removeShadowCaster(mesh, includeDescendants = true) {
        if (!this._shadowMap || !this._shadowMap.renderList) {
          return this;
        }
        const index = this._shadowMap.renderList.indexOf(mesh);
        if (index !== -1) {
          this._shadowMap.renderList.splice(index, 1);
        }
        if (includeDescendants) {
          for (const child of mesh.getChildren()) {
            this.removeShadowCaster(child);
          }
        }
        return this;
      }
      /**
       * Returns the associated light object.
       * @returns the light generating the shadow
       */
      getLight() {
        return this._light;
      }
      /**
       * Gets the shader language used in this generator.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      _getCamera() {
        return this._camera ?? this._scene.activeCamera;
      }
      /**
       * Gets or sets the size of the texture what stores the shadows
       */
      get mapSize() {
        return this._mapSize;
      }
      set mapSize(size) {
        this._mapSize = size;
        this._light._markMeshesAsLightDirty();
        this.recreateShadowMap();
      }
      /**
       * Creates a ShadowGenerator object.
       * A ShadowGenerator is the required tool to use the shadows.
       * Each light casting shadows needs to use its own ShadowGenerator.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows
       * @param mapSize The size of the texture what stores the shadows. Example : 1024.
       * @param light The light object generating the shadows.
       * @param usefullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
       * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it
       * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: false)
       * @param forceGLSL defines a boolean indicating if the shader must be compiled in GLSL even if we are using WebGPU
       */
      constructor(mapSize, light, usefullFloatFirst, camera, useRedTextureType, forceGLSL = false) {
        this.onBeforeShadowMapRenderObservable = new Observable();
        this.onAfterShadowMapRenderObservable = new Observable();
        this.onBeforeShadowMapRenderMeshObservable = new Observable();
        this.onAfterShadowMapRenderMeshObservable = new Observable();
        this.doNotSerialize = false;
        this._bias = 5e-5;
        this._normalBias = 0;
        this._blurBoxOffset = 1;
        this._blurScale = 2;
        this._blurKernel = 1;
        this._useKernelBlur = false;
        this._filter = _ShadowGenerator.FILTER_NONE;
        this._filteringQuality = _ShadowGenerator.QUALITY_HIGH;
        this._contactHardeningLightSizeUVRatio = 0.1;
        this._darkness = 0;
        this._transparencyShadow = false;
        this.enableSoftTransparentShadow = false;
        this.useOpacityTextureForTransparentShadow = false;
        this.frustumEdgeFalloff = 0;
        this._shaderLanguage = 0;
        this.forceBackFacesOnly = false;
        this._lightDirection = Vector3.Zero();
        this._viewMatrix = Matrix.Zero();
        this._projectionMatrix = Matrix.Zero();
        this._transformMatrix = Matrix.Zero();
        this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._currentFaceIndex = 0;
        this._currentFaceIndexCache = 0;
        this._defaultTextureMatrix = Matrix.Identity();
        this._shadersLoaded = false;
        this._mapSize = mapSize;
        this._light = light;
        this._scene = light.getScene();
        this._camera = camera ?? null;
        this._useRedTextureType = !!useRedTextureType;
        this._initShaderSourceAsync(forceGLSL);
        let shadowGenerators = light._shadowGenerators;
        if (!shadowGenerators) {
          shadowGenerators = light._shadowGenerators = /* @__PURE__ */ new Map();
        }
        shadowGenerators.set(this._camera, this);
        this.id = light.id;
        this._useUBO = this._scene.getEngine().supportsUniformBuffers;
        if (this._useUBO) {
          this._sceneUBOs = [];
          this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`));
        }
        _ShadowGenerator._SceneComponentInitialization(this._scene);
        const caps = this._scene.getEngine().getCaps();
        if (!usefullFloatFirst) {
          if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
            this._textureType = 2;
          } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
            this._textureType = 1;
          } else {
            this._textureType = 0;
          }
        } else {
          if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
            this._textureType = 1;
          } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
            this._textureType = 2;
          } else {
            this._textureType = 0;
          }
        }
        this._initializeGenerator();
        this._applyFilterValues();
      }
      _initializeGenerator() {
        this._light._markMeshesAsLightDirty();
        this._initializeShadowMap();
      }
      _createTargetRenderTexture() {
        const engine = this._scene.getEngine();
        if (engine._features.supportDepthStencilTexture) {
          this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), void 0, false, false, void 0, this._useRedTextureType ? 6 : 5);
          this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true, void 0, void 0, void 0, `DepthStencilForShadowGenerator-${this._light.name}`);
        } else {
          this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
        }
        this._shadowMap.noPrePassRenderer = true;
      }
      _initializeShadowMap() {
        this._createTargetRenderTexture();
        if (this._shadowMap === null) {
          return;
        }
        this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._shadowMap.anisotropicFilteringLevel = 1;
        this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._shadowMap.renderParticles = false;
        this._shadowMap.ignoreCameraViewport = true;
        if (this._storedUniqueId) {
          this._shadowMap.uniqueId = this._storedUniqueId;
        }
        this._shadowMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => this._renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes);
        this._shadowMap.customIsReadyFunction = (mesh, _refreshRate, preWarm) => {
          if (!preWarm || !mesh.subMeshes) {
            return true;
          }
          let isReady = true;
          for (const subMesh of mesh.subMeshes) {
            const renderingMesh = subMesh.getRenderingMesh();
            const scene = this._scene;
            const engine2 = scene.getEngine();
            const material = subMesh.getMaterial();
            if (!material || subMesh.verticesCount === 0 || this.customAllowRendering && !this.customAllowRendering(subMesh)) {
              continue;
            }
            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
            if (batch.mustReturn) {
              continue;
            }
            const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
            const isTransparent = material.needAlphaBlendingForMesh(renderingMesh);
            isReady = this.isReady(subMesh, hardwareInstancedRendering, isTransparent) && isReady;
          }
          return isReady;
        };
        const engine = this._scene.getEngine();
        this._shadowMap.onBeforeBindObservable.add(() => {
          var _a;
          this._currentSceneUBO = this._scene.getSceneUniformBuffer();
          (_a = engine._debugPushGroup) == null ? void 0 : _a.call(engine, `shadow map generation for pass id ${engine.currentRenderPassId}`, 1);
        });
        this._shadowMap.onBeforeRenderObservable.add((faceIndex) => {
          if (this._sceneUBOs) {
            this._scene.setSceneUniformBuffer(this._sceneUBOs[0]);
          }
          this._currentFaceIndex = faceIndex;
          if (this._filter === _ShadowGenerator.FILTER_PCF) {
            engine.setColorWrite(false);
          }
          this.getTransformMatrix();
          this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);
          if (this._useUBO) {
            this._scene.getSceneUniformBuffer().unbindEffect();
            this._scene.finalizeSceneUbo();
          }
        });
        this._shadowMap.onAfterUnbindObservable.add(() => {
          var _a, _b;
          if (this._sceneUBOs) {
            this._scene.setSceneUniformBuffer(this._currentSceneUBO);
          }
          this._scene.updateTransformMatrix();
          if (this._filter === _ShadowGenerator.FILTER_PCF) {
            engine.setColorWrite(true);
          }
          if (!this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {
            (_a = engine._debugPopGroup) == null ? void 0 : _a.call(engine, 1);
            return;
          }
          const shadowMap = this.getShadowMapForRendering();
          if (shadowMap) {
            this._scene.postProcessManager.directRender(this._blurPostProcesses, shadowMap.renderTarget, true);
            engine.unBindFramebuffer(shadowMap.renderTarget, true);
          }
          (_b = engine._debugPopGroup) == null ? void 0 : _b.call(engine, 1);
        });
        const clearZero = new Color4(0, 0, 0, 0);
        const clearOne = new Color4(1, 1, 1, 1);
        this._shadowMap.onClearObservable.add((engine2) => {
          if (this._filter === _ShadowGenerator.FILTER_PCF) {
            engine2.clear(clearOne, false, true, false);
          } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
            engine2.clear(clearZero, true, true, false);
          } else {
            engine2.clear(clearOne, true, true, false);
          }
        });
        this._shadowMap.onResizeObservable.add((rtt) => {
          this._storedUniqueId = this._shadowMap.uniqueId;
          this._mapSize = rtt.getRenderSize();
          this._light._markMeshesAsLightDirty();
          this.recreateShadowMap();
        });
        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
          this._shadowMap.setRenderingAutoClearDepthStencil(i, false);
        }
      }
      async _initShaderSourceAsync(forceGLSL = false) {
        const engine = this._scene.getEngine();
        if (engine.isWebGPU && !forceGLSL && !_ShadowGenerator.ForceGLSL) {
          this._shaderLanguage = 1;
          await Promise.all([
            import("./shadowMap.fragment-ATFJIJEC.js"),
            import("./shadowMap.vertex-QXJ5VD2O.js"),
            import("./depthBoxBlur.fragment-KWNXJ6U7.js"),
            import("./shadowMapFragmentSoftTransparentShadow-7T6MKQRE.js")
          ]);
        } else {
          await Promise.all([
            import("./shadowMap.fragment-OUYZLFDX.js"),
            import("./shadowMap.vertex-LI2KAAXQ.js"),
            import("./depthBoxBlur.fragment-D5O43X46.js"),
            import("./shadowMapFragmentSoftTransparentShadow-QK7A5H2M.js")
          ]);
        }
        this._shadersLoaded = true;
      }
      _initializeBlurRTTAndPostProcesses() {
        const engine = this._scene.getEngine();
        const targetSize = this._mapSize / this.blurScale;
        if (!this.useKernelBlur || this.blurScale !== 1) {
          this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType, void 0, void 0, false);
          this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
          this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
          this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        }
        if (this.useKernelBlur) {
          this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
          this._kernelBlurXPostprocess.width = targetSize;
          this._kernelBlurXPostprocess.height = targetSize;
          this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;
          this._kernelBlurXPostprocess.onApplyObservable.add((effect) => {
            effect.setTexture("textureSampler", this._shadowMap);
          });
          this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
          this._kernelBlurXPostprocess.autoClear = false;
          this._kernelBlurYPostprocess.autoClear = false;
          if (this._textureType === 0) {
            this._kernelBlurXPostprocess.packedFloat = true;
            this._kernelBlurYPostprocess.packedFloat = true;
          }
          this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
        } else {
          this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType, void 0, void 0, void 0, void 0, this._shaderLanguage);
          this._boxBlurPostprocess.externalTextureSamplerBinding = true;
          this._boxBlurPostprocess.onApplyObservable.add((effect) => {
            effect.setFloat2("screenSize", targetSize, targetSize);
            effect.setTexture("textureSampler", this._shadowMap);
          });
          this._boxBlurPostprocess.autoClear = false;
          this._blurPostProcesses = [this._boxBlurPostprocess];
        }
      }
      _renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
        let index;
        if (depthOnlySubMeshes.length) {
          for (index = 0; index < depthOnlySubMeshes.length; index++) {
            this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
          }
        }
        for (index = 0; index < opaqueSubMeshes.length; index++) {
          this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
        }
        for (index = 0; index < alphaTestSubMeshes.length; index++) {
          this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
        }
        if (this._transparencyShadow) {
          for (index = 0; index < transparentSubMeshes.length; index++) {
            this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);
          }
        } else {
          for (index = 0; index < transparentSubMeshes.length; index++) {
            transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
          }
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, mesh) {
        effect.setMatrix("viewProjection", this.getTransformMatrix());
      }
      _renderSubMeshForShadowMap(subMesh, isTransparent = false) {
        var _a;
        const renderingMesh = subMesh.getRenderingMesh();
        const effectiveMesh = subMesh.getEffectiveMesh();
        const scene = this._scene;
        const engine = scene.getEngine();
        const material = subMesh.getMaterial();
        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {
          return;
        }
        const useRHS = scene.useRightHandedSystem;
        const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
        let sideOrientation = material._getEffectiveOrientation(renderingMesh);
        if (detNeg && !useRHS || !detNeg && useRHS) {
          sideOrientation = sideOrientation === 0 ? 1 : 0;
        }
        const reverseSideOrientation = sideOrientation === 0;
        engine.setState(material.backFaceCulling, void 0, void 0, reverseSideOrientation, material.cullBackFaces);
        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
        if (batch.mustReturn) {
          return;
        }
        const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
        if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {
          return;
        }
        if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {
          subMesh._renderId = scene.getRenderId();
          const shadowDepthWrapper = material.shadowDepthWrapper;
          const drawWrapper = (shadowDepthWrapper == null ? void 0 : shadowDepthWrapper.getEffect(subMesh, this, engine.currentRenderPassId)) ?? subMesh._getDrawWrapper();
          const effect = DrawWrapper.GetEffect(drawWrapper);
          engine.enableEffect(drawWrapper);
          if (!hardwareInstancedRendering) {
            renderingMesh._bind(subMesh, effect, material.fillMode);
          }
          this.getTransformMatrix();
          effect.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale);
          if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
            effect.setVector3("lightDataSM", this._cachedDirection);
          } else {
            effect.setVector3("lightDataSM", this._cachedPosition);
          }
          const camera = this._getCamera();
          effect.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera));
          if (isTransparent && this.enableSoftTransparentShadow) {
            effect.setFloat2("softTransparentShadowSM", effectiveMesh.visibility * material.alpha, ((_a = this._opacityTexture) == null ? void 0 : _a.getAlphaFromRGB) ? 1 : 0);
          }
          if (shadowDepthWrapper) {
            subMesh._setMainDrawWrapperOverride(drawWrapper);
            if (shadowDepthWrapper.standalone) {
              shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
            } else {
              material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
            }
            subMesh._setMainDrawWrapperOverride(null);
          } else {
            if (this._opacityTexture) {
              effect.setTexture("diffuseSampler", this._opacityTexture);
              effect.setMatrix("diffuseMatrix", this._opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);
            }
            if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
              const skeleton = renderingMesh.skeleton;
              if (skeleton.isUsingTextureForMatrices) {
                const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
                if (!boneTexture) {
                  return;
                }
                effect.setTexture("boneSampler", boneTexture);
                effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
              } else {
                effect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
              }
            }
            BindMorphTargetParameters(renderingMesh, effect);
            if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
              renderingMesh.morphTargetManager._bind(effect);
            }
            const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
            if (bvaManager && bvaManager.isEnabled) {
              bvaManager.bind(effect, hardwareInstancedRendering);
            }
            bindClipPlane(effect, material, scene);
          }
          if (!this._useUBO && !shadowDepthWrapper) {
            this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, effectiveMesh);
          }
          BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());
          this._scene.getSceneUniformBuffer().bindUniformBuffer();
          const world = effectiveMesh.getWorldMatrix();
          if (hardwareInstancedRendering) {
            effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
            effectiveMesh.transferToEffect(world);
          }
          if (this.forceBackFacesOnly) {
            engine.setState(true, 0, false, true, material.cullBackFaces);
          }
          this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
          this.onBeforeShadowMapRenderObservable.notifyObservers(effect);
          renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, worldOverride) => {
            if (effectiveMesh !== renderingMesh && !isInstance) {
              renderingMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
              renderingMesh.transferToEffect(worldOverride);
            } else {
              effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
              effectiveMesh.transferToEffect(isInstance ? worldOverride : world);
            }
          });
          if (this.forceBackFacesOnly) {
            engine.setState(true, 0, false, false, material.cullBackFaces);
          }
          this.onAfterShadowMapRenderObservable.notifyObservers(effect);
          this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
        } else {
          if (this._shadowMap) {
            this._shadowMap.resetRefreshCounter();
          }
        }
      }
      _applyFilterValues() {
        if (!this._shadowMap) {
          return;
        }
        if (this.filter === _ShadowGenerator.FILTER_NONE || this.filter === _ShadowGenerator.FILTER_PCSS) {
          this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
        } else {
          this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        }
      }
      /**
       * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
       * @param onCompiled Callback triggered at the and of the effects compilation
       * @param options Sets of optional options forcing the compilation with different modes
       */
      forceCompilation(onCompiled, options) {
        const localOptions = {
          useInstances: false,
          ...options
        };
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
        const renderList = shadowMap.renderList;
        if (!renderList) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
        const subMeshes = [];
        for (const mesh of renderList) {
          subMeshes.push(...mesh.subMeshes);
        }
        if (subMeshes.length === 0) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
        let currentIndex = 0;
        const checkReady = () => {
          var _a;
          if (!this._scene || !this._scene.getEngine()) {
            return;
          }
          while (this.isReady(subMeshes[currentIndex], localOptions.useInstances, ((_a = subMeshes[currentIndex].getMaterial()) == null ? void 0 : _a.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh())) ?? false)) {
            currentIndex++;
            if (currentIndex >= subMeshes.length) {
              if (onCompiled) {
                onCompiled(this);
              }
              return;
            }
          }
          setTimeout(checkReady, 16);
        };
        checkReady();
      }
      /**
       * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
       * @param options Sets of optional options forcing the compilation with different modes
       * @returns A promise that resolves when the compilation completes
       */
      forceCompilationAsync(options) {
        return new Promise((resolve) => {
          this.forceCompilation(() => {
            resolve();
          }, options);
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _isReadyCustomDefines(defines, subMesh, useInstances) {
      }
      _prepareShadowDefines(subMesh, useInstances, defines, isTransparent) {
        defines.push("#define SM_LIGHTTYPE_" + this._light.getClassName().toUpperCase());
        defines.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0"));
        defines.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0"));
        defines.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
        const mesh = subMesh.getMesh();
        defines.push("#define SM_NORMALBIAS " + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? "1" : "0"));
        defines.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0"));
        defines.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0"));
        defines.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && isTransparent ? "1" : "0"));
        this._isReadyCustomDefines(defines, subMesh, useInstances);
        return defines;
      }
      /**
       * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
       * @param subMesh The submesh we want to render in the shadow map
       * @param useInstances Defines whether will draw in the map using instances
       * @param isTransparent Indicates that isReady is called for a transparent subMesh
       * @returns true if ready otherwise, false
       */
      isReady(subMesh, useInstances, isTransparent) {
        if (!this._shadersLoaded) {
          return false;
        }
        const material = subMesh.getMaterial(), shadowDepthWrapper = material == null ? void 0 : material.shadowDepthWrapper;
        this._opacityTexture = null;
        if (!material) {
          return false;
        }
        const defines = [];
        this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);
        if (shadowDepthWrapper) {
          if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {
            return false;
          }
        } else {
          const subMeshEffect = subMesh._getDrawWrapper(void 0, true);
          let effect = subMeshEffect.effect;
          let cachedDefines = subMeshEffect.defines;
          const attribs = [VertexBuffer.PositionKind];
          const mesh = subMesh.getMesh();
          let useNormal = false;
          let uv1 = false;
          let uv2 = false;
          const color = false;
          if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
            attribs.push(VertexBuffer.NormalKind);
            defines.push("#define NORMAL");
            useNormal = true;
            if (mesh.nonUniformScaling) {
              defines.push("#define NONUNIFORMSCALING");
            }
          }
          const needAlphaTesting = material.needAlphaTestingForMesh(mesh);
          if (needAlphaTesting || material.needAlphaBlendingForMesh(mesh)) {
            if (this.useOpacityTextureForTransparentShadow) {
              this._opacityTexture = material.opacityTexture;
            } else {
              this._opacityTexture = material.getAlphaTestTexture();
            }
            if (this._opacityTexture) {
              if (!this._opacityTexture.isReady()) {
                return false;
              }
              const alphaCutOff = material.alphaCutOff ?? _ShadowGenerator.DEFAULT_ALPHA_CUTOFF;
              defines.push("#define ALPHATEXTURE");
              if (needAlphaTesting) {
                defines.push(`#define ALPHATESTVALUE ${alphaCutOff}${alphaCutOff % 1 === 0 ? "." : ""}`);
              }
              if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                attribs.push(VertexBuffer.UVKind);
                defines.push("#define UV1");
                uv1 = true;
              }
              if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                if (this._opacityTexture.coordinatesIndex === 1) {
                  attribs.push(VertexBuffer.UV2Kind);
                  defines.push("#define UV2");
                  uv2 = true;
                }
              }
            }
          }
          const fallbacks = new EffectFallbacks();
          if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            if (mesh.numBoneInfluencers > 4) {
              attribs.push(VertexBuffer.MatricesIndicesExtraKind);
              attribs.push(VertexBuffer.MatricesWeightsExtraKind);
            }
            const skeleton = mesh.skeleton;
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            if (mesh.numBoneInfluencers > 0) {
              fallbacks.addCPUSkinningFallback(0, mesh);
            }
            if (skeleton.isUsingTextureForMatrices) {
              defines.push("#define BONETEXTURE");
            } else {
              defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
            }
          } else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
          }
          const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
            mesh.morphTargetManager,
            defines,
            attribs,
            mesh,
            true,
            // usePositionMorph
            useNormal,
            // useNormalMorph
            false,
            // useTangentMorph
            uv1,
            // useUVMorph
            uv2,
            // useUV2Morph
            color
            // useColorMorph
          ) : 0;
          prepareStringDefinesForClipPlanes(material, this._scene, defines);
          if (useInstances) {
            defines.push("#define INSTANCES");
            PushAttributesForInstances(attribs);
            if (subMesh.getRenderingMesh().hasThinInstances) {
              defines.push("#define THIN_INSTANCES");
            }
          }
          if (this.customShaderOptions) {
            if (this.customShaderOptions.defines) {
              for (const define of this.customShaderOptions.defines) {
                if (defines.indexOf(define) === -1) {
                  defines.push(define);
                }
              }
            }
          }
          const bvaManager = mesh.bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
            if (useInstances) {
              attribs.push("bakedVertexAnimationSettingsInstanced");
            }
          }
          const join = defines.join("\n");
          if (cachedDefines !== join) {
            cachedDefines = join;
            let shaderName = "shadowMap";
            const uniforms = [
              "world",
              "mBones",
              "viewProjection",
              "diffuseMatrix",
              "lightDataSM",
              "depthValuesSM",
              "biasAndScaleSM",
              "morphTargetInfluences",
              "morphTargetCount",
              "boneTextureWidth",
              "softTransparentShadowSM",
              "morphTargetTextureInfo",
              "morphTargetTextureIndices",
              "bakedVertexAnimationSettings",
              "bakedVertexAnimationTextureSizeInverted",
              "bakedVertexAnimationTime",
              "bakedVertexAnimationTexture"
            ];
            const samplers = ["diffuseSampler", "boneSampler", "morphTargets", "bakedVertexAnimationTexture"];
            const uniformBuffers = ["Scene", "Mesh"];
            addClipPlaneUniforms(uniforms);
            if (this.customShaderOptions) {
              shaderName = this.customShaderOptions.shaderName;
              if (this.customShaderOptions.attributes) {
                for (const attrib of this.customShaderOptions.attributes) {
                  if (attribs.indexOf(attrib) === -1) {
                    attribs.push(attrib);
                  }
                }
              }
              if (this.customShaderOptions.uniforms) {
                for (const uniform of this.customShaderOptions.uniforms) {
                  if (uniforms.indexOf(uniform) === -1) {
                    uniforms.push(uniform);
                  }
                }
              }
              if (this.customShaderOptions.samplers) {
                for (const sampler of this.customShaderOptions.samplers) {
                  if (samplers.indexOf(sampler) === -1) {
                    samplers.push(sampler);
                  }
                }
              }
            }
            const engine = this._scene.getEngine();
            effect = engine.createEffect(shaderName, {
              attributes: attribs,
              uniformsNames: uniforms,
              uniformBuffersNames: uniformBuffers,
              samplers,
              defines: join,
              fallbacks,
              onCompiled: null,
              onError: null,
              indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
              shaderLanguage: this._shaderLanguage
            }, engine);
            subMeshEffect.setEffect(effect, cachedDefines);
          }
          if (!effect.isReady()) {
            return false;
          }
        }
        if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
          if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
            this._initializeBlurRTTAndPostProcesses();
          }
        }
        if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
          return false;
        }
        if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
          return false;
        }
        if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
          return false;
        }
        return true;
      }
      /**
       * Prepare all the defines in a material relying on a shadow map at the specified light index.
       * @param defines Defines of the material we want to update
       * @param lightIndex Index of the light in the enabled light list of the material
       */
      prepareDefines(defines, lightIndex) {
        const scene = this._scene;
        const light = this._light;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
          return;
        }
        defines["SHADOW" + lightIndex] = true;
        if (this.useContactHardeningShadow) {
          defines["SHADOWPCSS" + lightIndex] = true;
          if (this._filteringQuality === _ShadowGenerator.QUALITY_LOW) {
            defines["SHADOWLOWQUALITY" + lightIndex] = true;
          } else if (this._filteringQuality === _ShadowGenerator.QUALITY_MEDIUM) {
            defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
          }
        } else if (this.usePercentageCloserFiltering) {
          defines["SHADOWPCF" + lightIndex] = true;
          if (this._filteringQuality === _ShadowGenerator.QUALITY_LOW) {
            defines["SHADOWLOWQUALITY" + lightIndex] = true;
          } else if (this._filteringQuality === _ShadowGenerator.QUALITY_MEDIUM) {
            defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
          }
        } else if (this.usePoissonSampling) {
          defines["SHADOWPOISSON" + lightIndex] = true;
        } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
          defines["SHADOWESM" + lightIndex] = true;
        } else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
          defines["SHADOWCLOSEESM" + lightIndex] = true;
        }
        if (light.needCube()) {
          defines["SHADOWCUBE" + lightIndex] = true;
        }
      }
      /**
       * Binds the shadow related information inside of an effect (information like near, far, darkness...
       * defined in the generator but impacting the effect).
       * @param lightIndex Index of the light in the enabled light list of the material owning the effect
       * @param effect The effect we are binding the information for
       */
      bindShadowLight(lightIndex, effect) {
        const light = this._light;
        const scene = this._scene;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
          return;
        }
        const camera = this._getCamera();
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          return;
        }
        if (!light.needCube()) {
          effect.setMatrix("lightMatrix" + lightIndex, this.getTransformMatrix());
        }
        const shadowMapForRendering = this.getShadowMapForRendering();
        if (this._filter === _ShadowGenerator.FILTER_PCF) {
          effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMapForRendering);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
        } else if (this._filter === _ShadowGenerator.FILTER_PCSS) {
          effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMapForRendering);
          effect.setTexture("depthTexture" + lightIndex, shadowMapForRendering);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
        } else {
          effect.setTexture("shadowTexture" + lightIndex, shadowMapForRendering);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
        }
        light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
      }
      /**
       * Gets the view matrix used to render the shadow map.
       */
      get viewMatrix() {
        return this._viewMatrix;
      }
      /**
       * Gets the projection matrix used to render the shadow map.
       */
      get projectionMatrix() {
        return this._projectionMatrix;
      }
      /**
       * Gets the transformation matrix used to project the meshes into the map from the light point of view.
       * (eq to shadow projection matrix * light transform matrix)
       * @returns The transform matrix used to create the shadow map
       */
      getTransformMatrix() {
        const scene = this._scene;
        if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
          return this._transformMatrix;
        }
        this._currentRenderId = scene.getRenderId();
        this._currentFaceIndexCache = this._currentFaceIndex;
        let lightPosition = this._light.position;
        if (this._light.computeTransformedInformation()) {
          lightPosition = this._light.transformedPosition;
        }
        Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
          this._lightDirection.z = 1e-13;
        }
        if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
          this._cachedPosition.copyFrom(lightPosition);
          this._cachedDirection.copyFrom(this._lightDirection);
          Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
          const shadowMap = this.getShadowMap();
          if (shadowMap) {
            const renderList = shadowMap.renderList;
            if (renderList) {
              this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
            }
          }
          this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        }
        return this._transformMatrix;
      }
      /**
       * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
       * Cube and 2D textures for instance.
       */
      recreateShadowMap() {
        const shadowMap = this._shadowMap;
        if (!shadowMap) {
          return;
        }
        const renderList = shadowMap.renderList;
        this._disposeRTTandPostProcesses();
        this._initializeGenerator();
        this.filter = this._filter;
        this._applyFilterValues();
        if (renderList) {
          if (!this._shadowMap.renderList) {
            this._shadowMap.renderList = [];
          }
          for (const mesh of renderList) {
            this._shadowMap.renderList.push(mesh);
          }
        } else {
          this._shadowMap.renderList = null;
        }
      }
      _disposeBlurPostProcesses() {
        if (this._shadowMap2) {
          this._shadowMap2.dispose();
          this._shadowMap2 = null;
        }
        if (this._boxBlurPostprocess) {
          this._boxBlurPostprocess.dispose();
          this._boxBlurPostprocess = null;
        }
        if (this._kernelBlurXPostprocess) {
          this._kernelBlurXPostprocess.dispose();
          this._kernelBlurXPostprocess = null;
        }
        if (this._kernelBlurYPostprocess) {
          this._kernelBlurYPostprocess.dispose();
          this._kernelBlurYPostprocess = null;
        }
        this._blurPostProcesses = [];
      }
      _disposeRTTandPostProcesses() {
        if (this._shadowMap) {
          this._shadowMap.dispose();
          this._shadowMap = null;
        }
        this._disposeBlurPostProcesses();
      }
      _disposeSceneUBOs() {
        if (this._sceneUBOs) {
          for (const ubo of this._sceneUBOs) {
            ubo.dispose();
          }
          this._sceneUBOs = [];
        }
      }
      /**
       * Disposes the ShadowGenerator.
       * Returns nothing.
       */
      dispose() {
        this._disposeRTTandPostProcesses();
        this._disposeSceneUBOs();
        if (this._light) {
          if (this._light._shadowGenerators) {
            const iterator = this._light._shadowGenerators.entries();
            for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
              const [camera, shadowGenerator] = entry.value;
              if (shadowGenerator === this) {
                this._light._shadowGenerators.delete(camera);
              }
            }
            if (this._light._shadowGenerators.size === 0) {
              this._light._shadowGenerators = null;
            }
          }
          this._light._markMeshesAsLightDirty();
        }
        this.onBeforeShadowMapRenderMeshObservable.clear();
        this.onBeforeShadowMapRenderObservable.clear();
        this.onAfterShadowMapRenderMeshObservable.clear();
        this.onAfterShadowMapRenderObservable.clear();
      }
      /**
       * Serializes the shadow generator setup to a json object.
       * @returns The serialized JSON object
       */
      serialize() {
        var _a;
        const serializationObject = {};
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          return serializationObject;
        }
        serializationObject.className = this.getClassName();
        serializationObject.lightId = this._light.id;
        serializationObject.cameraId = (_a = this._camera) == null ? void 0 : _a.id;
        serializationObject.id = this.id;
        serializationObject.mapSize = shadowMap.getRenderSize();
        serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
        serializationObject.darkness = this.getDarkness();
        serializationObject.transparencyShadow = this._transparencyShadow;
        serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
        serializationObject.bias = this.bias;
        serializationObject.normalBias = this.normalBias;
        serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
        serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
        serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
        serializationObject.filteringQuality = this.filteringQuality;
        serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
        serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.usePoissonSampling = this.usePoissonSampling;
        serializationObject.depthScale = this.depthScale;
        serializationObject.blurBoxOffset = this.blurBoxOffset;
        serializationObject.blurKernel = this.blurKernel;
        serializationObject.blurScale = this.blurScale;
        serializationObject.useKernelBlur = this.useKernelBlur;
        serializationObject.renderList = [];
        if (shadowMap.renderList) {
          for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
            const mesh = shadowMap.renderList[meshIndex];
            serializationObject.renderList.push(mesh.id);
          }
        }
        return serializationObject;
      }
      /**
       * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
       * @param parsedShadowGenerator The JSON object to parse
       * @param scene The scene to create the shadow map for
       * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator
       * @returns The parsed shadow generator
       */
      static Parse(parsedShadowGenerator, scene, constr) {
        const light = scene.getLightById(parsedShadowGenerator.lightId);
        const camera = parsedShadowGenerator.cameraId !== void 0 ? scene.getCameraById(parsedShadowGenerator.cameraId) : null;
        const shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light, camera) : new _ShadowGenerator(parsedShadowGenerator.mapSize, light, void 0, camera);
        const shadowMap = shadowGenerator.getShadowMap();
        for (let meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {
          const meshes = scene.getMeshesById(parsedShadowGenerator.renderList[meshIndex]);
          meshes.forEach(function(mesh) {
            if (!shadowMap) {
              return;
            }
            if (!shadowMap.renderList) {
              shadowMap.renderList = [];
            }
            shadowMap.renderList.push(mesh);
          });
        }
        if (parsedShadowGenerator.id !== void 0) {
          shadowGenerator.id = parsedShadowGenerator.id;
        }
        shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;
        if (parsedShadowGenerator.darkness !== void 0) {
          shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
        }
        if (parsedShadowGenerator.transparencyShadow) {
          shadowGenerator.setTransparencyShadow(true);
        }
        if (parsedShadowGenerator.frustumEdgeFalloff !== void 0) {
          shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
        }
        if (parsedShadowGenerator.bias !== void 0) {
          shadowGenerator.bias = parsedShadowGenerator.bias;
        }
        if (parsedShadowGenerator.normalBias !== void 0) {
          shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
        }
        if (parsedShadowGenerator.usePercentageCloserFiltering) {
          shadowGenerator.usePercentageCloserFiltering = true;
        } else if (parsedShadowGenerator.useContactHardeningShadow) {
          shadowGenerator.useContactHardeningShadow = true;
        } else if (parsedShadowGenerator.usePoissonSampling) {
          shadowGenerator.usePoissonSampling = true;
        } else if (parsedShadowGenerator.useExponentialShadowMap) {
          shadowGenerator.useExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
          shadowGenerator.useBlurExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
          shadowGenerator.useCloseExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
          shadowGenerator.useBlurCloseExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useVarianceShadowMap) {
          shadowGenerator.useExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
          shadowGenerator.useBlurExponentialShadowMap = true;
        }
        if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== void 0) {
          shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
        }
        if (parsedShadowGenerator.filteringQuality !== void 0) {
          shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
        }
        if (parsedShadowGenerator.depthScale) {
          shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
        }
        if (parsedShadowGenerator.blurScale) {
          shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
        }
        if (parsedShadowGenerator.blurBoxOffset) {
          shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
        }
        if (parsedShadowGenerator.useKernelBlur) {
          shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
        }
        if (parsedShadowGenerator.blurKernel) {
          shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
        }
        return shadowGenerator;
      }
    };
    ShadowGenerator.CLASSNAME = "ShadowGenerator";
    ShadowGenerator.ForceGLSL = false;
    ShadowGenerator.FILTER_NONE = 0;
    ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;
    ShadowGenerator.FILTER_POISSONSAMPLING = 2;
    ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
    ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
    ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
    ShadowGenerator.FILTER_PCF = 6;
    ShadowGenerator.FILTER_PCSS = 7;
    ShadowGenerator.QUALITY_HIGH = 0;
    ShadowGenerator.QUALITY_MEDIUM = 1;
    ShadowGenerator.QUALITY_LOW = 2;
    ShadowGenerator.DEFAULT_ALPHA_CUTOFF = 0.5;
    ShadowGenerator._SceneComponentInitialization = (_) => {
      throw _WarnImport("ShadowGeneratorSceneComponent");
    };
  }
});

// node_modules/@babylonjs/core/Rendering/depthRenderer.js
var DepthRenderer;
var init_depthRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/depthRenderer.js"() {
    init_math_color();
    init_buffer();
    init_texture();
    init_renderTargetTexture();
    init_camera();
    init_depth_fragment();
    init_depth_vertex();
    init_devTools();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_effectFallbacks();
    DepthRenderer = class _DepthRenderer {
      /**
       * Gets the shader language used in this material.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer
       * @param mesh mesh or array of meshes
       * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.
       */
      setMaterialForRendering(mesh, material) {
        this._depthMap.setMaterialForRendering(mesh, material);
      }
      /**
       * Instantiates a depth renderer
       * @param scene The scene the renderer belongs to
       * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)
       * @param camera The camera to be used to render the depth map (default: scene's active camera)
       * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z
       * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)
       * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)
       * @param name Name of the render target (default: DepthRenderer)
       */
      constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name2) {
        this._shaderLanguage = 0;
        this.enabled = true;
        this.forceDepthWriteTransparentMeshes = false;
        this.useOnlyInActiveCamera = false;
        this.reverseCulling = false;
        this._shadersLoaded = false;
        this._scene = scene;
        this._storeNonLinearDepth = storeNonLinearDepth;
        this._storeCameraSpaceZ = storeCameraSpaceZ;
        this.isPacked = type === 0;
        if (this.isPacked) {
          this.clearColor = new Color4(1, 1, 1, 1);
        } else {
          this.clearColor = new Color4(storeCameraSpaceZ ? 1e8 : 1, 0, 0, 1);
        }
        this._initShaderSourceAsync();
        _DepthRenderer._SceneComponentInitialization(this._scene);
        const engine = scene.getEngine();
        this._camera = camera;
        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {
          if (type === 1 && !engine._caps.textureFloatLinearFiltering) {
            samplingMode = Texture.NEAREST_SAMPLINGMODE;
          }
          if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {
            samplingMode = Texture.NEAREST_SAMPLINGMODE;
          }
        }
        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;
        this._depthMap = new RenderTargetTexture(name2 ?? "DepthRenderer", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, void 0, void 0, void 0, format);
        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._depthMap.refreshRate = 1;
        this._depthMap.renderParticles = false;
        this._depthMap.renderList = null;
        this._depthMap.noPrePassRenderer = true;
        this._depthMap.activeCamera = this._camera;
        this._depthMap.ignoreCameraViewport = true;
        this._depthMap.useCameraPostProcesses = false;
        this._depthMap.onClearObservable.add((engine2) => {
          engine2.clear(this.clearColor, true, true, true);
        });
        this._depthMap.onBeforeBindObservable.add(() => {
          var _a;
          (_a = engine._debugPushGroup) == null ? void 0 : _a.call(engine, "depth renderer", 1);
        });
        this._depthMap.onAfterUnbindObservable.add(() => {
          var _a;
          (_a = engine._debugPopGroup) == null ? void 0 : _a.call(engine, 1);
        });
        this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
          if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
            for (let i = 0; i < mesh.subMeshes.length; ++i) {
              const subMesh = mesh.subMeshes[i];
              const renderingMesh = subMesh.getRenderingMesh();
              const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
              const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
              if (!this.isReady(subMesh, hardwareInstancedRendering)) {
                return false;
              }
            }
          }
          return true;
        };
        const renderSubMesh = (subMesh) => {
          var _a;
          const renderingMesh = subMesh.getRenderingMesh();
          const effectiveMesh = subMesh.getEffectiveMesh();
          const scene2 = this._scene;
          const engine2 = scene2.getEngine();
          const material = subMesh.getMaterial();
          effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
          if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene2.getRenderId()) {
            return;
          }
          const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
          let sideOrientation = material._getEffectiveOrientation(renderingMesh);
          if (detNeg) {
            sideOrientation = sideOrientation === 0 ? 1 : 0;
          }
          const reverseSideOrientation = sideOrientation === 0;
          engine2.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          if (batch.mustReturn) {
            return;
          }
          const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
          const camera2 = this._camera || scene2.activeCamera;
          if (this.isReady(subMesh, hardwareInstancedRendering) && camera2) {
            subMesh._renderId = scene2.getRenderId();
            const renderingMaterial = (_a = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) == null ? void 0 : _a[engine2.currentRenderPassId];
            let drawWrapper = subMesh._getDrawWrapper();
            if (!drawWrapper && renderingMaterial) {
              drawWrapper = renderingMaterial._getDrawWrapper();
            }
            const cameraIsOrtho = camera2.mode === Camera.ORTHOGRAPHIC_CAMERA;
            if (!drawWrapper) {
              return;
            }
            const effect = drawWrapper.effect;
            engine2.enableEffect(drawWrapper);
            if (!hardwareInstancedRendering) {
              renderingMesh._bind(subMesh, effect, material.fillMode);
            }
            if (!renderingMaterial) {
              effect.setMatrix("viewProjection", scene2.getTransformMatrix());
              effect.setMatrix("world", effectiveMesh.getWorldMatrix());
              if (this._storeCameraSpaceZ) {
                effect.setMatrix("view", scene2.getViewMatrix());
              }
            } else {
              renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
            }
            let minZ, maxZ;
            if (cameraIsOrtho) {
              minZ = !engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
              maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
            } else {
              minZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? camera2.minZ : engine2.isNDCHalfZRange ? 0 : camera2.minZ;
              maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : camera2.maxZ;
            }
            effect.setFloat2("depthValues", minZ, minZ + maxZ);
            if (!renderingMaterial) {
              if (material.needAlphaTestingForMesh(effectiveMesh)) {
                const alphaTexture = material.getAlphaTestTexture();
                if (alphaTexture) {
                  effect.setTexture("diffuseSampler", alphaTexture);
                  effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
                }
              }
              BindBonesParameters(renderingMesh, effect);
              bindClipPlane(effect, material, scene2);
              BindMorphTargetParameters(renderingMesh, effect);
              if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
                renderingMesh.morphTargetManager._bind(effect);
              }
              const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
              if (bvaManager && bvaManager.isEnabled) {
                bvaManager.bind(effect, hardwareInstancedRendering);
              }
              if (material.pointsCloud) {
                effect.setFloat("pointSize", material.pointSize);
              }
            }
            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix("world", world));
          }
        };
        this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
          let index;
          if (depthOnlySubMeshes.length) {
            for (index = 0; index < depthOnlySubMeshes.length; index++) {
              renderSubMesh(depthOnlySubMeshes.data[index]);
            }
          }
          for (index = 0; index < opaqueSubMeshes.length; index++) {
            renderSubMesh(opaqueSubMeshes.data[index]);
          }
          for (index = 0; index < alphaTestSubMeshes.length; index++) {
            renderSubMesh(alphaTestSubMeshes.data[index]);
          }
          if (this.forceDepthWriteTransparentMeshes) {
            for (index = 0; index < transparentSubMeshes.length; index++) {
              renderSubMesh(transparentSubMeshes.data[index]);
            }
          } else {
            for (index = 0; index < transparentSubMeshes.length; index++) {
              transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
            }
          }
        };
      }
      async _initShaderSourceAsync(forceGLSL = false) {
        const engine = this._scene.getEngine();
        if (engine.isWebGPU && !forceGLSL && !_DepthRenderer.ForceGLSL) {
          this._shaderLanguage = 1;
          await Promise.all([import("./depth.vertex-F7UC3RFS.js"), import("./depth.fragment-UDEZJNYC.js")]);
        } else {
          await Promise.all([import("./depth.vertex-HQR7IYQZ.js"), import("./depth.fragment-HZD6GU6R.js")]);
        }
        this._shadersLoaded = true;
      }
      /**
       * Creates the depth rendering effect and checks if the effect is ready.
       * @param subMesh The submesh to be used to render the depth map of
       * @param useInstances If multiple world instances should be used
       * @returns if the depth renderer is ready to render the depth map
       */
      isReady(subMesh, useInstances) {
        var _a;
        if (!this._shadersLoaded) {
          return false;
        }
        const engine = this._scene.getEngine();
        const mesh = subMesh.getMesh();
        const scene = mesh.getScene();
        const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) == null ? void 0 : _a[engine.currentRenderPassId];
        if (renderingMaterial) {
          return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
        }
        const material = subMesh.getMaterial();
        if (!material || material.disableDepthWrite) {
          return false;
        }
        const defines = [];
        const attribs = [VertexBuffer.PositionKind];
        let uv1 = false;
        let uv2 = false;
        const color = false;
        if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {
          defines.push("#define ALPHATEST");
          if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
            uv1 = true;
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
            attribs.push(VertexBuffer.UV2Kind);
            defines.push("#define UV2");
            uv2 = true;
          }
        }
        const fallbacks = new EffectFallbacks();
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (mesh.numBoneInfluencers > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
          defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
          if (mesh.numBoneInfluencers > 0) {
            fallbacks.addCPUSkinningFallback(0, mesh);
          }
          const skeleton = mesh.skeleton;
          if (skeleton.isUsingTextureForMatrices) {
            defines.push("#define BONETEXTURE");
          } else {
            defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
          }
        } else {
          defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
          mesh.morphTargetManager,
          defines,
          attribs,
          mesh,
          true,
          // usePositionMorph
          false,
          // useNormalMorph
          false,
          // useTangentMorph
          uv1,
          // useUVMorph
          uv2,
          // useUV2Morph
          color
          // useColorMorph
        ) : 0;
        if (material.pointsCloud) {
          defines.push("#define POINTSIZE");
        }
        if (useInstances) {
          defines.push("#define INSTANCES");
          PushAttributesForInstances(attribs);
          if (subMesh.getRenderingMesh().hasThinInstances) {
            defines.push("#define THIN_INSTANCES");
          }
        }
        const bvaManager = mesh.bakedVertexAnimationManager;
        if (bvaManager && bvaManager.isEnabled) {
          defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
          if (useInstances) {
            attribs.push("bakedVertexAnimationSettingsInstanced");
          }
        }
        if (this._storeNonLinearDepth) {
          defines.push("#define NONLINEARDEPTH");
        }
        if (this._storeCameraSpaceZ) {
          defines.push("#define STORE_CAMERASPACE_Z");
        }
        if (this.isPacked) {
          defines.push("#define PACKED");
        }
        prepareStringDefinesForClipPlanes(material, scene, defines);
        const drawWrapper = subMesh._getDrawWrapper(void 0, true);
        const cachedDefines = drawWrapper.defines;
        const join = defines.join("\n");
        if (cachedDefines !== join) {
          const uniforms = [
            "world",
            "mBones",
            "boneTextureWidth",
            "pointSize",
            "viewProjection",
            "view",
            "diffuseMatrix",
            "depthValues",
            "morphTargetInfluences",
            "morphTargetCount",
            "morphTargetTextureInfo",
            "morphTargetTextureIndices",
            "bakedVertexAnimationSettings",
            "bakedVertexAnimationTextureSizeInverted",
            "bakedVertexAnimationTime",
            "bakedVertexAnimationTexture"
          ];
          const samplers = ["diffuseSampler", "morphTargets", "boneSampler", "bakedVertexAnimationTexture"];
          addClipPlaneUniforms(uniforms);
          drawWrapper.setEffect(engine.createEffect("depth", {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: [],
            samplers,
            defines: join,
            fallbacks,
            onCompiled: null,
            onError: null,
            indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
            shaderLanguage: this._shaderLanguage
          }, engine), join);
        }
        return drawWrapper.effect.isReady();
      }
      /**
       * Gets the texture which the depth map will be written to.
       * @returns The depth map texture
       */
      getDepthMap() {
        return this._depthMap;
      }
      /**
       * Disposes of the depth renderer.
       */
      dispose() {
        const keysToDelete = [];
        for (const key in this._scene._depthRenderer) {
          const depthRenderer = this._scene._depthRenderer[key];
          if (depthRenderer === this) {
            keysToDelete.push(key);
          }
        }
        if (keysToDelete.length > 0) {
          this._depthMap.dispose();
          for (const key of keysToDelete) {
            delete this._scene._depthRenderer[key];
          }
        }
      }
    };
    DepthRenderer.ForceGLSL = false;
    DepthRenderer._SceneComponentInitialization = (_) => {
      throw _WarnImport("DepthRendererSceneComponent");
    };
  }
});

// node_modules/@babylonjs/core/Shaders/minmaxRedux.fragment.js
var name, shader;
var init_minmaxRedux_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/minmaxRedux.fragment.js"() {
    init_shaderStore();
    name = "minmaxReduxPixelShader";
    shader = `varying vec2 vUV;uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform sampler2D sourceTexture;uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(sourceTexture,coord,0).r;float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;float minz=min(min(min(f1,f2),f3),f4);
#ifdef DEPTH_REDUX
float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#else
float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(MAIN)
uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(f1.x,f2.x);float maxz=max(f1.y,f2.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(LAST)
void main(void)
{glFragColor=vec4(0.);if (true) { 
discard;}}
#endif
`;
    if (!ShaderStore.ShadersStore[name]) {
      ShaderStore.ShadersStore[name] = shader;
    }
  }
});

// node_modules/@babylonjs/core/Misc/minMaxReducer.js
var MinMaxReducer;
var init_minMaxReducer = __esm({
  "node_modules/@babylonjs/core/Misc/minMaxReducer.js"() {
    init_observable();
    init_postProcess();
    init_postProcessManager();
    init_minmaxRedux_fragment();
    MinMaxReducer = class {
      /**
       * Creates a min/max reducer
       * @param camera The camera to use for the post processes
       */
      constructor(camera) {
        this.onAfterReductionPerformed = new Observable();
        this._forceFullscreenViewport = true;
        this._activated = false;
        this._camera = camera;
        this._postProcessManager = new PostProcessManager(camera.getScene());
        this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {
          this._postProcessManager._rebuild();
        });
      }
      /**
       * Gets the texture used to read the values from.
       */
      get sourceTexture() {
        return this._sourceTexture;
      }
      /**
       * Sets the source texture to read the values from.
       * One must indicate if the texture is a depth texture or not through the depthRedux parameter
       * because in such textures '1' value must not be taken into account to compute the maximum
       * as this value is used to clear the texture.
       * Note that the computation is not activated by calling this function, you must call activate() for that!
       * @param sourceTexture The texture to read the values from. The values should be in the red channel.
       * @param depthRedux Indicates if the texture is a depth texture or not
       * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)
       * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
       */
      setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
        if (sourceTexture === this._sourceTexture) {
          return;
        }
        this.dispose(false);
        this._sourceTexture = sourceTexture;
        this._reductionSteps = [];
        this._forceFullscreenViewport = forceFullscreenViewport;
        const scene = this._camera.getScene();
        const reductionInitial = new PostProcess(
          "Initial reduction phase",
          "minmaxRedux",
          // shader
          ["texSize"],
          ["sourceTexture"],
          // textures
          1,
          // options
          null,
          // camera
          1,
          // sampling
          scene.getEngine(),
          // engine
          false,
          // reusable
          "#define INITIAL" + (depthRedux ? "\n#define DEPTH_REDUX" : ""),
          // defines
          type,
          void 0,
          void 0,
          void 0,
          7
        );
        reductionInitial.autoClear = false;
        reductionInitial.forceFullscreenViewport = forceFullscreenViewport;
        let w = this._sourceTexture.getRenderWidth(), h = this._sourceTexture.getRenderHeight();
        reductionInitial.onApply = /* @__PURE__ */ ((w2, h2) => {
          return (effect) => {
            effect.setTexture("sourceTexture", this._sourceTexture);
            effect.setFloat2("texSize", w2, h2);
          };
        })(w, h);
        this._reductionSteps.push(reductionInitial);
        let index = 1;
        while (w > 1 || h > 1) {
          w = Math.max(Math.round(w / 2), 1);
          h = Math.max(Math.round(h / 2), 1);
          const reduction = new PostProcess(
            "Reduction phase " + index,
            "minmaxRedux",
            // shader
            ["texSize"],
            null,
            { width: w, height: h },
            // options
            null,
            // camera
            1,
            // sampling
            scene.getEngine(),
            // engine
            false,
            // reusable
            "#define " + (w == 1 && h == 1 ? "LAST" : w == 1 || h == 1 ? "ONEBEFORELAST" : "MAIN"),
            // defines
            type,
            void 0,
            void 0,
            void 0,
            7
          );
          reduction.autoClear = false;
          reduction.forceFullscreenViewport = forceFullscreenViewport;
          reduction.onApply = /* @__PURE__ */ ((w2, h2) => {
            return (effect) => {
              if (w2 == 1 || h2 == 1) {
                effect.setInt2("texSize", w2, h2);
              } else {
                effect.setFloat2("texSize", w2, h2);
              }
            };
          })(w, h);
          this._reductionSteps.push(reduction);
          index++;
          if (w == 1 && h == 1) {
            const func = (w2, h2, reduction2) => {
              const buffer = new Float32Array(4 * w2 * h2), minmax = { min: 0, max: 0 };
              return () => {
                scene.getEngine()._readTexturePixels(reduction2.inputTexture.texture, w2, h2, -1, 0, buffer, false);
                minmax.min = buffer[0];
                minmax.max = buffer[1];
                this.onAfterReductionPerformed.notifyObservers(minmax);
              };
            };
            reduction.onAfterRenderObservable.add(func(w, h, reduction));
          }
        }
      }
      /**
       * Defines the refresh rate of the computation.
       * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
       */
      get refreshRate() {
        return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
      }
      set refreshRate(value) {
        if (this._sourceTexture) {
          this._sourceTexture.refreshRate = value;
        }
      }
      /**
       * Gets the activation status of the reducer
       */
      get activated() {
        return this._activated;
      }
      /**
       * Activates the reduction computation.
       * When activated, the observers registered in onAfterReductionPerformed are
       * called after the computation is performed
       */
      activate() {
        if (this._onAfterUnbindObserver || !this._sourceTexture) {
          return;
        }
        this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {
          var _a, _b;
          const engine = this._camera.getScene().getEngine();
          (_a = engine._debugPushGroup) == null ? void 0 : _a.call(engine, `min max reduction`, 1);
          this._reductionSteps[0].activate(this._camera);
          this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport);
          engine.unBindFramebuffer(this._reductionSteps[0].inputTexture, false);
          (_b = engine._debugPopGroup) == null ? void 0 : _b.call(engine, 1);
        });
        this._activated = true;
      }
      /**
       * Deactivates the reduction computation.
       */
      deactivate() {
        if (!this._onAfterUnbindObserver || !this._sourceTexture) {
          return;
        }
        this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
        this._onAfterUnbindObserver = null;
        this._activated = false;
      }
      /**
       * Disposes the min/max reducer
       * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
       */
      dispose(disposeAll = true) {
        if (disposeAll) {
          this.onAfterReductionPerformed.clear();
          if (this._onContextRestoredObserver) {
            this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
            this._onContextRestoredObserver = null;
          }
        }
        this.deactivate();
        if (this._reductionSteps) {
          for (let i = 0; i < this._reductionSteps.length; ++i) {
            this._reductionSteps[i].dispose();
          }
          this._reductionSteps = null;
        }
        if (this._postProcessManager && disposeAll) {
          this._postProcessManager.dispose();
        }
        this._sourceTexture = null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/depthReducer.js
var DepthReducer;
var init_depthReducer = __esm({
  "node_modules/@babylonjs/core/Misc/depthReducer.js"() {
    init_depthRenderer();
    init_minMaxReducer();
    DepthReducer = class extends MinMaxReducer {
      /**
       * Gets the depth renderer used for the computation.
       * Note that the result is null if you provide your own renderer when calling setDepthRenderer.
       */
      get depthRenderer() {
        return this._depthRenderer;
      }
      /**
       * Creates a depth reducer
       * @param camera The camera used to render the depth texture
       */
      constructor(camera) {
        super(camera);
      }
      /**
       * Sets the depth renderer to use to generate the depth map
       * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically
       * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)
       * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
       */
      setDepthRenderer(depthRenderer = null, type = 2, forceFullscreenViewport = true) {
        const scene = this._camera.getScene();
        if (this._depthRenderer) {
          delete scene._depthRenderer[this._depthRendererId];
          this._depthRenderer.dispose();
          this._depthRenderer = null;
        }
        if (depthRenderer === null) {
          if (!scene._depthRenderer) {
            scene._depthRenderer = {};
          }
          depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, 1);
          depthRenderer.enabled = false;
          this._depthRendererId = "minmax" + this._camera.id;
          scene._depthRenderer[this._depthRendererId] = depthRenderer;
        }
        super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);
      }
      /**
       * @internal
       */
      setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
        super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);
      }
      /**
       * Activates the reduction computation.
       * When activated, the observers registered in onAfterReductionPerformed are
       * called after the computation is performed
       */
      activate() {
        if (this._depthRenderer) {
          this._depthRenderer.enabled = true;
        }
        super.activate();
      }
      /**
       * Deactivates the reduction computation.
       */
      deactivate() {
        super.deactivate();
        if (this._depthRenderer) {
          this._depthRenderer.enabled = false;
        }
      }
      /**
       * Disposes the depth reducer
       * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
       */
      dispose(disposeAll = true) {
        super.dispose(disposeAll);
        if (this._depthRenderer && disposeAll) {
          const scene = this._depthRenderer.getDepthMap().getScene();
          if (scene) {
            delete scene._depthRenderer[this._depthRendererId];
          }
          this._depthRenderer.dispose();
          this._depthRenderer = null;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js
var UpDir, ZeroVec, tmpv1, tmpv2, tmpMatrix, CascadedShadowGenerator;
var init_cascadedShadowGenerator = __esm({
  "node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js"() {
    init_math_vector();
    init_renderTargetTexture();
    init_devTools();
    init_shadowGenerator();
    init_boundingInfo();
    init_depthReducer();
    init_logger();
    init_engineStore();
    UpDir = Vector3.Up();
    ZeroVec = Vector3.Zero();
    tmpv1 = new Vector3();
    tmpv2 = new Vector3();
    tmpMatrix = new Matrix();
    CascadedShadowGenerator = class _CascadedShadowGenerator extends ShadowGenerator {
      _validateFilter(filter) {
        if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {
          return filter;
        }
        Logger.Error('Unsupported filter "' + filter + '"!');
        return ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets or set the number of cascades used by the CSM.
       */
      get numCascades() {
        return this._numCascades;
      }
      set numCascades(value) {
        value = Math.min(Math.max(value, _CascadedShadowGenerator.MIN_CASCADES_COUNT), _CascadedShadowGenerator.MAX_CASCADES_COUNT);
        if (value === this._numCascades) {
          return;
        }
        this._numCascades = value;
        this.recreateShadowMap();
        this._recreateSceneUBOs();
      }
      /**
       * Enables or disables the shadow casters bounding info computation.
       * If your shadow casters don't move, you can disable this feature.
       * If it is enabled, the bounding box computation is done every frame.
       */
      get freezeShadowCastersBoundingInfo() {
        return this._freezeShadowCastersBoundingInfo;
      }
      set freezeShadowCastersBoundingInfo(freeze) {
        if (this._freezeShadowCastersBoundingInfoObservable && freeze) {
          this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
          this._freezeShadowCastersBoundingInfoObservable = null;
        }
        if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {
          this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(() => this._computeShadowCastersBoundingInfo());
        }
        this._freezeShadowCastersBoundingInfo = freeze;
        if (freeze) {
          this._computeShadowCastersBoundingInfo();
        }
      }
      _computeShadowCastersBoundingInfo() {
        this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._scbiMax.copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        if (this._shadowMap && this._shadowMap.renderList) {
          const renderList = this._shadowMap.renderList;
          for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
            const mesh = renderList[meshIndex];
            if (!mesh) {
              continue;
            }
            const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
            this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
            this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
          }
        }
        this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
      }
      /**
       * Gets or sets the shadow casters bounding info.
       * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo
       * so that the system won't overwrite the bounds you provide
       */
      get shadowCastersBoundingInfo() {
        return this._shadowCastersBoundingInfo;
      }
      set shadowCastersBoundingInfo(boundingInfo) {
        this._shadowCastersBoundingInfo = boundingInfo;
      }
      /**
       * Sets the minimal and maximal distances to use when computing the cascade breaks.
       *
       * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.
       * If you don't know these values, simply leave them to their defaults and don't call this function.
       * @param min minimal distance for the breaks (default to 0.)
       * @param max maximal distance for the breaks (default to 1.)
       */
      setMinMaxDistance(min, max) {
        if (this._minDistance === min && this._maxDistance === max) {
          return;
        }
        if (min > max) {
          min = 0;
          max = 1;
        }
        if (min < 0) {
          min = 0;
        }
        if (max > 1) {
          max = 1;
        }
        this._minDistance = min;
        this._maxDistance = max;
        this._breaksAreDirty = true;
      }
      /** Gets the minimal distance used in the cascade break computation */
      get minDistance() {
        return this._minDistance;
      }
      /** Gets the maximal distance used in the cascade break computation */
      get maxDistance() {
        return this._maxDistance;
      }
      /**
       * Gets the class name of that object
       * @returns "CascadedShadowGenerator"
       */
      getClassName() {
        return _CascadedShadowGenerator.CLASSNAME;
      }
      /**
       * Gets a cascade minimum extents
       * @param cascadeIndex index of the cascade
       * @returns the minimum cascade extents
       */
      getCascadeMinExtents(cascadeIndex) {
        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;
      }
      /**
       * Gets a cascade maximum extents
       * @param cascadeIndex index of the cascade
       * @returns the maximum cascade extents
       */
      getCascadeMaxExtents(cascadeIndex) {
        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;
      }
      /**
       * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.
       * It defaults to camera.maxZ
       */
      get shadowMaxZ() {
        if (!this._getCamera()) {
          return 0;
        }
        return this._shadowMaxZ;
      }
      /**
       * Sets the shadow max z distance.
       */
      set shadowMaxZ(value) {
        const camera = this._getCamera();
        if (!camera) {
          this._shadowMaxZ = value;
          return;
        }
        if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ && camera.maxZ !== 0) {
          return;
        }
        this._shadowMaxZ = value;
        this._light._markMeshesAsLightDirty();
        this._breaksAreDirty = true;
      }
      /**
       * Gets or sets the debug flag.
       * When enabled, the cascades are materialized by different colors on the screen.
       */
      get debug() {
        return this._debug;
      }
      set debug(dbg) {
        this._debug = dbg;
        this._light._markMeshesAsLightDirty();
      }
      /**
       * Gets or sets the depth clamping value.
       *
       * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted
       * to account for the shadow casters far away.
       *
       * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.
       */
      get depthClamp() {
        return this._depthClamp;
      }
      set depthClamp(value) {
        this._depthClamp = value;
      }
      /**
       * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).
       * It defaults to 0.1 (10% blending).
       */
      get cascadeBlendPercentage() {
        return this._cascadeBlendPercentage;
      }
      set cascadeBlendPercentage(value) {
        this._cascadeBlendPercentage = value;
        this._light._markMeshesAsLightDirty();
      }
      /**
       * Gets or set the lambda parameter.
       * This parameter is used to split the camera frustum and create the cascades.
       * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.
       * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.
       */
      get lambda() {
        return this._lambda;
      }
      set lambda(value) {
        const lambda = Math.min(Math.max(value, 0), 1);
        if (this._lambda == lambda) {
          return;
        }
        this._lambda = lambda;
        this._breaksAreDirty = true;
      }
      /**
       * Gets the view matrix corresponding to a given cascade
       * @param cascadeNum cascade to retrieve the view matrix from
       * @returns the cascade view matrix
       */
      getCascadeViewMatrix(cascadeNum) {
        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;
      }
      /**
       * Gets the projection matrix corresponding to a given cascade
       * @param cascadeNum cascade to retrieve the projection matrix from
       * @returns the cascade projection matrix
       */
      getCascadeProjectionMatrix(cascadeNum) {
        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;
      }
      /**
       * Gets the transformation matrix corresponding to a given cascade
       * @param cascadeNum cascade to retrieve the transformation matrix from
       * @returns the cascade transformation matrix
       */
      getCascadeTransformMatrix(cascadeNum) {
        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;
      }
      /**
       * Sets the depth renderer to use when autoCalcDepthBounds is enabled.
       *
       * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.
       *
       * You should call this function if you already have a depth renderer enabled in your scene, to avoid
       * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!
       * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created
       */
      setDepthRenderer(depthRenderer) {
        this._depthRenderer = depthRenderer;
        if (this._depthReducer) {
          this._depthReducer.setDepthRenderer(this._depthRenderer);
        }
      }
      /**
       * Gets or sets the autoCalcDepthBounds property.
       *
       * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one
       * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the
       * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.
       * It can greatly enhance the shadow quality, at the expense of more GPU works.
       * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.
       */
      get autoCalcDepthBounds() {
        return this._autoCalcDepthBounds;
      }
      set autoCalcDepthBounds(value) {
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        this._autoCalcDepthBounds = value;
        if (!value) {
          if (this._depthReducer) {
            this._depthReducer.deactivate();
          }
          this.setMinMaxDistance(0, 1);
          return;
        }
        if (!this._depthReducer) {
          this._depthReducer = new DepthReducer(camera);
          this._depthReducer.onAfterReductionPerformed.add((minmax) => {
            let min = minmax.min, max = minmax.max;
            if (min >= max) {
              min = 0;
              max = 1;
            }
            if (min != this._minDistance || max != this._maxDistance) {
              this.setMinMaxDistance(min, max);
            }
          });
          this._depthReducer.setDepthRenderer(this._depthRenderer);
        }
        this._depthReducer.activate();
      }
      /**
       * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true
       * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
       * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible
       * for setting the refresh rate on the renderer yourself!
       */
      get autoCalcDepthBoundsRefreshRate() {
        var _a, _b;
        return ((_b = (_a = this._depthReducer) == null ? void 0 : _a.depthRenderer) == null ? void 0 : _b.getDepthMap().refreshRate) ?? -1;
      }
      set autoCalcDepthBoundsRefreshRate(value) {
        var _a;
        if ((_a = this._depthReducer) == null ? void 0 : _a.depthRenderer) {
          this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;
        }
      }
      /**
       * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.
       * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if
       * you change the camera near/far planes!
       */
      splitFrustum() {
        this._breaksAreDirty = true;
      }
      _splitFrustum() {
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        const near = camera.minZ, far = camera.maxZ || this._shadowMaxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;
        const minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;
        const range = maxZ - minZ, ratio = maxZ / minZ;
        for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {
          const p = (cascadeIndex + 1) / this._numCascades, log = minZ * ratio ** p, uniform = minZ + range * p;
          const d = this._lambda * (log - uniform) + uniform;
          this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;
          this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;
          this._viewSpaceFrustumsZ[cascadeIndex] = d;
          this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;
        }
        this._breaksAreDirty = false;
      }
      _computeMatrices() {
        const scene = this._scene;
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);
        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
          this._lightDirection.z = 1e-13;
        }
        this._cachedDirection.copyFrom(this._lightDirection);
        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;
        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
          this._computeFrustumInWorldSpace(cascadeIndex);
          this._computeCascadeFrustum(cascadeIndex);
          this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1);
          this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);
          Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);
          let viewMinZ = 0, viewMaxZ = tmpv1.z;
          const boundingInfo = this._shadowCastersBoundingInfo;
          boundingInfo.update(this._viewMatrices[cascadeIndex]);
          const castersViewMinZ = boundingInfo.boundingBox.minimumWorld.z;
          const castersViewMaxZ = boundingInfo.boundingBox.maximumWorld.z;
          if (castersViewMinZ > viewMaxZ) {
          } else {
            if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {
              viewMinZ = Math.min(viewMinZ, castersViewMinZ);
              if (this.filter !== ShadowGenerator.FILTER_PCSS) {
                viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);
              }
            } else {
              viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);
              viewMinZ = Math.max(viewMinZ, castersViewMinZ);
              viewMaxZ = Math.max(viewMinZ + 1, viewMaxZ);
            }
          }
          Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? viewMaxZ : viewMinZ, useReverseDepthBuffer ? viewMinZ : viewMaxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);
          this._cascadeMinExtents[cascadeIndex].z = viewMinZ;
          this._cascadeMaxExtents[cascadeIndex].z = viewMaxZ;
          this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
          Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1);
          tmpv1.scaleInPlace(this._mapSize / 2);
          tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z));
          tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize);
          Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0, tmpMatrix);
          this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix, this._projectionMatrices[cascadeIndex]);
          this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
          this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);
        }
      }
      // Get the 8 points of the view frustum in world space
      _computeFrustumInWorldSpace(cascadeIndex) {
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;
        const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;
        camera.getViewMatrix();
        const cameraInfiniteFarPlane = camera.maxZ === 0;
        const saveCameraMaxZ = camera.maxZ;
        if (cameraInfiniteFarPlane) {
          camera.maxZ = this._shadowMaxZ;
          camera.getProjectionMatrix(true);
        }
        const invViewProj = Matrix.Invert(camera.getTransformationMatrix());
        if (cameraInfiniteFarPlane) {
          camera.maxZ = saveCameraMaxZ;
          camera.getProjectionMatrix(true);
        }
        const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
        for (let cornerIndex = 0; cornerIndex < _CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++cornerIndex) {
          tmpv1.copyFrom(_CascadedShadowGenerator._FrustumCornersNDCSpace[(cornerIndex + cornerIndexOffset) % _CascadedShadowGenerator._FrustumCornersNDCSpace.length]);
          if (isNDCHalfZRange && tmpv1.z === -1) {
            tmpv1.z = 0;
          }
          Vector3.TransformCoordinatesToRef(tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
        }
        for (let cornerIndex = 0; cornerIndex < _CascadedShadowGenerator._FrustumCornersNDCSpace.length / 2; ++cornerIndex) {
          tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
          tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist);
          tmpv1.scaleInPlace(splitDist);
          tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
          this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);
          this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);
        }
      }
      _computeCascadeFrustum(cascadeIndex) {
        this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cascadeMaxExtents[cascadeIndex].copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
          this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
        }
        this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);
        if (this.stabilizeCascades) {
          let sphereRadius = 0;
          for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
            const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();
            sphereRadius = Math.max(sphereRadius, dist);
          }
          sphereRadius = Math.ceil(sphereRadius * 16) / 16;
          this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);
          this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);
        } else {
          const lightCameraPos = this._frustumCenter[cascadeIndex];
          this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1);
          Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix);
          for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
            Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix, tmpv1);
            this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);
            this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);
          }
        }
      }
      _recreateSceneUBOs() {
        this._disposeSceneUBOs();
        if (this._sceneUBOs) {
          for (let i = 0; i < this._numCascades; ++i) {
            this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${i})`));
          }
        }
      }
      /**
       *  Support test.
       */
      static get IsSupported() {
        const engine = EngineStore.LastCreatedEngine;
        if (!engine) {
          return false;
        }
        return engine._features.supportCSM;
      }
      /**
       * Creates a Cascaded Shadow Generator object.
       * A ShadowGenerator is the required tool to use the shadows.
       * Each directional light casting shadows needs to use its own ShadowGenerator.
       * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
       * @param mapSize The size of the texture what stores the shadows. Example : 1024.
       * @param light The directional light object generating the shadows.
       * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
       * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it
       * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: true)
       */
      constructor(mapSize, light, usefulFloatFirst, camera, useRedTextureType = true) {
        if (!_CascadedShadowGenerator.IsSupported) {
          Logger.Error("CascadedShadowMap is not supported by the current engine.");
          return;
        }
        super(mapSize, light, usefulFloatFirst, camera, useRedTextureType);
        this.usePercentageCloserFiltering = true;
      }
      _initializeGenerator() {
        var _a;
        this.penumbraDarkness = this.penumbraDarkness ?? 1;
        this._numCascades = this._numCascades ?? _CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;
        this.stabilizeCascades = this.stabilizeCascades ?? false;
        this._freezeShadowCastersBoundingInfoObservable = this._freezeShadowCastersBoundingInfoObservable ?? null;
        this.freezeShadowCastersBoundingInfo = this.freezeShadowCastersBoundingInfo ?? false;
        this._scbiMin = this._scbiMin ?? new Vector3(0, 0, 0);
        this._scbiMax = this._scbiMax ?? new Vector3(0, 0, 0);
        this._shadowCastersBoundingInfo = this._shadowCastersBoundingInfo ?? new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
        this._breaksAreDirty = this._breaksAreDirty ?? true;
        this._minDistance = this._minDistance ?? 0;
        this._maxDistance = this._maxDistance ?? 1;
        this._currentLayer = this._currentLayer ?? 0;
        this._shadowMaxZ = this._shadowMaxZ ?? ((_a = this._getCamera()) == null ? void 0 : _a.maxZ) ?? 1e4;
        this._debug = this._debug ?? false;
        this._depthClamp = this._depthClamp ?? true;
        this._cascadeBlendPercentage = this._cascadeBlendPercentage ?? 0.1;
        this._lambda = this._lambda ?? 0.5;
        this._autoCalcDepthBounds = this._autoCalcDepthBounds ?? false;
        this._recreateSceneUBOs();
        super._initializeGenerator();
      }
      _createTargetRenderTexture() {
        const engine = this._scene.getEngine();
        const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
        this._shadowMap = new RenderTargetTexture(this._light.name + "_CSMShadowMap", size, this._scene, false, true, this._textureType, false, void 0, false, false, void 0, this._useRedTextureType ? 6 : 5);
        this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true, void 0, void 0, void 0, `DepthStencilForCSMShadowGenerator-${this._light.name}`);
        this._shadowMap.noPrePassRenderer = true;
      }
      _initializeShadowMap() {
        super._initializeShadowMap();
        if (this._shadowMap === null) {
          return;
        }
        this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);
        this._viewSpaceFrustumsZ = new Array(this._numCascades);
        this._frustumLengths = new Array(this._numCascades);
        this._lightSizeUVCorrection = new Array(this._numCascades * 2);
        this._depthCorrection = new Array(this._numCascades);
        this._cascades = [];
        this._viewMatrices = [];
        this._projectionMatrices = [];
        this._transformMatrices = [];
        this._cascadeMinExtents = [];
        this._cascadeMaxExtents = [];
        this._frustumCenter = [];
        this._shadowCameraPos = [];
        this._frustumCornersWorldSpace = [];
        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
          this._cascades[cascadeIndex] = {
            prevBreakDistance: 0,
            breakDistance: 0
          };
          this._viewMatrices[cascadeIndex] = Matrix.Zero();
          this._projectionMatrices[cascadeIndex] = Matrix.Zero();
          this._transformMatrices[cascadeIndex] = Matrix.Zero();
          this._cascadeMinExtents[cascadeIndex] = new Vector3();
          this._cascadeMaxExtents[cascadeIndex] = new Vector3();
          this._frustumCenter[cascadeIndex] = new Vector3();
          this._shadowCameraPos[cascadeIndex] = new Vector3();
          this._frustumCornersWorldSpace[cascadeIndex] = new Array(_CascadedShadowGenerator._FrustumCornersNDCSpace.length);
          for (let i = 0; i < _CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++i) {
            this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();
          }
        }
        const engine = this._scene.getEngine();
        this._shadowMap.onBeforeBindObservable.clear();
        this._shadowMap.onBeforeRenderObservable.clear();
        this._shadowMap.onBeforeRenderObservable.add((layer) => {
          if (this._sceneUBOs) {
            this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);
          }
          this._currentLayer = layer;
          if (this._filter === ShadowGenerator.FILTER_PCF) {
            engine.setColorWrite(false);
          }
          this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));
          if (this._useUBO) {
            this._scene.getSceneUniformBuffer().unbindEffect();
            this._scene.finalizeSceneUbo();
          }
        });
        this._shadowMap.onBeforeBindObservable.add(() => {
          var _a;
          this._currentSceneUBO = this._scene.getSceneUniformBuffer();
          (_a = engine._debugPushGroup) == null ? void 0 : _a.call(engine, `cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);
          if (this._breaksAreDirty) {
            this._splitFrustum();
          }
          this._computeMatrices();
        });
        this._splitFrustum();
      }
      _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {
        effect.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
      }
      _isReadyCustomDefines(defines) {
        defines.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? "1" : "0"));
      }
      /**
       * Prepare all the defines in a material relying on a shadow map at the specified light index.
       * @param defines Defines of the material we want to update
       * @param lightIndex Index of the light in the enabled light list of the material
       */
      prepareDefines(defines, lightIndex) {
        super.prepareDefines(defines, lightIndex);
        const scene = this._scene;
        const light = this._light;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
          return;
        }
        defines["SHADOWCSM" + lightIndex] = true;
        defines["SHADOWCSMDEBUG" + lightIndex] = this.debug;
        defines["SHADOWCSMNUM_CASCADES" + lightIndex] = this.numCascades;
        defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = scene.useRightHandedSystem;
        const camera = this._getCamera();
        if (camera && this._shadowMaxZ <= (camera.maxZ || this._shadowMaxZ)) {
          defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = true;
        }
        if (this.cascadeBlendPercentage === 0) {
          defines["SHADOWCSMNOBLEND" + lightIndex] = true;
        }
      }
      /**
       * Binds the shadow related information inside of an effect (information like near, far, darkness...
       * defined in the generator but impacting the effect).
       * @param lightIndex Index of the light in the enabled light list of the material owning the effect
       * @param effect The effect we are binfing the information for
       */
      bindShadowLight(lightIndex, effect) {
        const light = this._light;
        const scene = this._scene;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
          return;
        }
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          return;
        }
        const width = shadowMap.getSize().width;
        effect.setMatrices("lightMatrix" + lightIndex, this._transformMatricesAsArray);
        effect.setArray("viewFrustumZ" + lightIndex, this._viewSpaceFrustumsZ);
        effect.setFloat("cascadeBlendFactor" + lightIndex, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage);
        effect.setArray("frustumLengths" + lightIndex, this._frustumLengths);
        if (this._filter === ShadowGenerator.FILTER_PCF) {
          effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMap);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
        } else if (this._filter === ShadowGenerator.FILTER_PCSS) {
          for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
            this._lightSizeUVCorrection[cascadeIndex * 2 + 0] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x);
            this._lightSizeUVCorrection[cascadeIndex * 2 + 1] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y);
            this._depthCorrection[cascadeIndex] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
          }
          effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMap);
          effect.setTexture("depthTexture" + lightIndex, shadowMap);
          effect.setArray2("lightSizeUVCorrection" + lightIndex, this._lightSizeUVCorrection);
          effect.setArray("depthCorrection" + lightIndex, this._depthCorrection);
          effect.setFloat("penumbraDarkness" + lightIndex, this.penumbraDarkness);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);
        } else {
          effect.setTexture("shadowTexture" + lightIndex, shadowMap);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
        }
        light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
      }
      /**
       * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.
       * (eq to view projection * shadow projection matrices)
       * @returns The transform matrix used to create the shadow map
       */
      getTransformMatrix() {
        return this.getCascadeTransformMatrix(0);
      }
      /**
       * Disposes the ShadowGenerator.
       * Returns nothing.
       */
      dispose() {
        super.dispose();
        if (this._freezeShadowCastersBoundingInfoObservable) {
          this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
          this._freezeShadowCastersBoundingInfoObservable = null;
        }
        if (this._depthReducer) {
          this._depthReducer.dispose();
          this._depthReducer = null;
        }
      }
      /**
       * Serializes the shadow generator setup to a json object.
       * @returns The serialized JSON object
       */
      serialize() {
        const serializationObject = super.serialize();
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          return serializationObject;
        }
        serializationObject.numCascades = this._numCascades;
        serializationObject.debug = this._debug;
        serializationObject.stabilizeCascades = this.stabilizeCascades;
        serializationObject.lambda = this._lambda;
        serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;
        serializationObject.depthClamp = this._depthClamp;
        serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;
        serializationObject.shadowMaxZ = this._shadowMaxZ;
        serializationObject.penumbraDarkness = this.penumbraDarkness;
        serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;
        serializationObject.minDistance = this.minDistance;
        serializationObject.maxDistance = this.maxDistance;
        serializationObject.renderList = [];
        if (shadowMap.renderList) {
          for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
            const mesh = shadowMap.renderList[meshIndex];
            serializationObject.renderList.push(mesh.id);
          }
        }
        return serializationObject;
      }
      /**
       * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
       * @param parsedShadowGenerator The JSON object to parse
       * @param scene The scene to create the shadow map for
       * @returns The parsed shadow generator
       */
      static Parse(parsedShadowGenerator, scene) {
        const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new _CascadedShadowGenerator(mapSize, light, void 0, camera));
        if (parsedShadowGenerator.numCascades !== void 0) {
          shadowGenerator.numCascades = parsedShadowGenerator.numCascades;
        }
        if (parsedShadowGenerator.debug !== void 0) {
          shadowGenerator.debug = parsedShadowGenerator.debug;
        }
        if (parsedShadowGenerator.stabilizeCascades !== void 0) {
          shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;
        }
        if (parsedShadowGenerator.lambda !== void 0) {
          shadowGenerator.lambda = parsedShadowGenerator.lambda;
        }
        if (parsedShadowGenerator.cascadeBlendPercentage !== void 0) {
          shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;
        }
        if (parsedShadowGenerator.depthClamp !== void 0) {
          shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;
        }
        if (parsedShadowGenerator.autoCalcDepthBounds !== void 0) {
          shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;
        }
        if (parsedShadowGenerator.shadowMaxZ !== void 0) {
          shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;
        }
        if (parsedShadowGenerator.penumbraDarkness !== void 0) {
          shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;
        }
        if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== void 0) {
          shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;
        }
        if (parsedShadowGenerator.minDistance !== void 0 && parsedShadowGenerator.maxDistance !== void 0) {
          shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);
        }
        return shadowGenerator;
      }
    };
    CascadedShadowGenerator._FrustumCornersNDCSpace = [
      new Vector3(-1, 1, -1),
      new Vector3(1, 1, -1),
      new Vector3(1, -1, -1),
      new Vector3(-1, -1, -1),
      new Vector3(-1, 1, 1),
      new Vector3(1, 1, 1),
      new Vector3(1, -1, 1),
      new Vector3(-1, -1, 1)
    ];
    CascadedShadowGenerator.CLASSNAME = "CascadedShadowGenerator";
    CascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;
    CascadedShadowGenerator.MIN_CASCADES_COUNT = 2;
    CascadedShadowGenerator.MAX_CASCADES_COUNT = 4;
    CascadedShadowGenerator._SceneComponentInitialization = (_) => {
      throw _WarnImport("ShadowGeneratorSceneComponent");
    };
  }
});

export {
  ThinBlurPostProcess,
  init_thinBlurPostProcess,
  BlurPostProcess,
  init_blurPostProcess,
  ShadowGenerator,
  init_shadowGenerator,
  DepthRenderer,
  init_depthRenderer,
  MinMaxReducer,
  init_minMaxReducer,
  DepthReducer,
  init_depthReducer,
  CascadedShadowGenerator,
  init_cascadedShadowGenerator
};
//# sourceMappingURL=chunk-VKRX3226.js.map
