import {
  SerializationHelper,
  init_decorators_serialization
} from "./chunk-5WVONG5F.js";
import {
  __decorate,
  init_decorators,
  init_tslib_es6,
  serialize,
  serializeAsColor4,
  serializeAsColorCurves,
  serializeAsTexture
} from "./chunk-IZLWPSPC.js";
import {
  Mix,
  init_tools_functions
} from "./chunk-K2SB273Q.js";
import {
  Observable,
  init_observable
} from "./chunk-DIMHUU43.js";
import {
  Color4,
  init_math_color
} from "./chunk-FBNFE7ZR.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-D6A73UHJ.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/Materials/colorCurves.functions.js
function PrepareUniformsForColorCurves(uniformsList) {
  uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
}
var init_colorCurves_functions = __esm({
  "node_modules/@babylonjs/core/Materials/colorCurves.functions.js"() {
  }
});

// node_modules/@babylonjs/core/Materials/colorCurves.js
var ColorCurves;
var init_colorCurves = __esm({
  "node_modules/@babylonjs/core/Materials/colorCurves.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_decorators_serialization();
    init_colorCurves_functions();
    ColorCurves = class _ColorCurves {
      constructor() {
        this._dirty = true;
        this._tempColor = new Color4(0, 0, 0, 0);
        this._globalCurve = new Color4(0, 0, 0, 0);
        this._highlightsCurve = new Color4(0, 0, 0, 0);
        this._midtonesCurve = new Color4(0, 0, 0, 0);
        this._shadowsCurve = new Color4(0, 0, 0, 0);
        this._positiveCurve = new Color4(0, 0, 0, 0);
        this._negativeCurve = new Color4(0, 0, 0, 0);
        this._globalHue = 30;
        this._globalDensity = 0;
        this._globalSaturation = 0;
        this._globalExposure = 0;
        this._highlightsHue = 30;
        this._highlightsDensity = 0;
        this._highlightsSaturation = 0;
        this._highlightsExposure = 0;
        this._midtonesHue = 30;
        this._midtonesDensity = 0;
        this._midtonesSaturation = 0;
        this._midtonesExposure = 0;
        this._shadowsHue = 30;
        this._shadowsDensity = 0;
        this._shadowsSaturation = 0;
        this._shadowsExposure = 0;
      }
      /**
       * Gets the global Hue value.
       * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
       */
      get globalHue() {
        return this._globalHue;
      }
      /**
       * Sets the global Hue value.
       * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
       */
      set globalHue(value) {
        this._globalHue = value;
        this._dirty = true;
      }
      /**
       * Gets the global Density value.
       * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
       * Values less than zero provide a filter of opposite hue.
       */
      get globalDensity() {
        return this._globalDensity;
      }
      /**
       * Sets the global Density value.
       * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
       * Values less than zero provide a filter of opposite hue.
       */
      set globalDensity(value) {
        this._globalDensity = value;
        this._dirty = true;
      }
      /**
       * Gets the global Saturation value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
       */
      get globalSaturation() {
        return this._globalSaturation;
      }
      /**
       * Sets the global Saturation value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
       */
      set globalSaturation(value) {
        this._globalSaturation = value;
        this._dirty = true;
      }
      /**
       * Gets the global Exposure value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
       */
      get globalExposure() {
        return this._globalExposure;
      }
      /**
       * Sets the global Exposure value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
       */
      set globalExposure(value) {
        this._globalExposure = value;
        this._dirty = true;
      }
      /**
       * Gets the highlights Hue value.
       * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
       */
      get highlightsHue() {
        return this._highlightsHue;
      }
      /**
       * Sets the highlights Hue value.
       * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
       */
      set highlightsHue(value) {
        this._highlightsHue = value;
        this._dirty = true;
      }
      /**
       * Gets the highlights Density value.
       * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
       * Values less than zero provide a filter of opposite hue.
       */
      get highlightsDensity() {
        return this._highlightsDensity;
      }
      /**
       * Sets the highlights Density value.
       * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
       * Values less than zero provide a filter of opposite hue.
       */
      set highlightsDensity(value) {
        this._highlightsDensity = value;
        this._dirty = true;
      }
      /**
       * Gets the highlights Saturation value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
       */
      get highlightsSaturation() {
        return this._highlightsSaturation;
      }
      /**
       * Sets the highlights Saturation value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
       */
      set highlightsSaturation(value) {
        this._highlightsSaturation = value;
        this._dirty = true;
      }
      /**
       * Gets the highlights Exposure value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
       */
      get highlightsExposure() {
        return this._highlightsExposure;
      }
      /**
       * Sets the highlights Exposure value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
       */
      set highlightsExposure(value) {
        this._highlightsExposure = value;
        this._dirty = true;
      }
      /**
       * Gets the midtones Hue value.
       * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
       */
      get midtonesHue() {
        return this._midtonesHue;
      }
      /**
       * Sets the midtones Hue value.
       * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
       */
      set midtonesHue(value) {
        this._midtonesHue = value;
        this._dirty = true;
      }
      /**
       * Gets the midtones Density value.
       * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
       * Values less than zero provide a filter of opposite hue.
       */
      get midtonesDensity() {
        return this._midtonesDensity;
      }
      /**
       * Sets the midtones Density value.
       * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
       * Values less than zero provide a filter of opposite hue.
       */
      set midtonesDensity(value) {
        this._midtonesDensity = value;
        this._dirty = true;
      }
      /**
       * Gets the midtones Saturation value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
       */
      get midtonesSaturation() {
        return this._midtonesSaturation;
      }
      /**
       * Sets the midtones Saturation value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
       */
      set midtonesSaturation(value) {
        this._midtonesSaturation = value;
        this._dirty = true;
      }
      /**
       * Gets the midtones Exposure value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
       */
      get midtonesExposure() {
        return this._midtonesExposure;
      }
      /**
       * Sets the midtones Exposure value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
       */
      set midtonesExposure(value) {
        this._midtonesExposure = value;
        this._dirty = true;
      }
      /**
       * Gets the shadows Hue value.
       * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
       */
      get shadowsHue() {
        return this._shadowsHue;
      }
      /**
       * Sets the shadows Hue value.
       * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
       */
      set shadowsHue(value) {
        this._shadowsHue = value;
        this._dirty = true;
      }
      /**
       * Gets the shadows Density value.
       * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
       * Values less than zero provide a filter of opposite hue.
       */
      get shadowsDensity() {
        return this._shadowsDensity;
      }
      /**
       * Sets the shadows Density value.
       * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
       * Values less than zero provide a filter of opposite hue.
       */
      set shadowsDensity(value) {
        this._shadowsDensity = value;
        this._dirty = true;
      }
      /**
       * Gets the shadows Saturation value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
       */
      get shadowsSaturation() {
        return this._shadowsSaturation;
      }
      /**
       * Sets the shadows Saturation value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
       */
      set shadowsSaturation(value) {
        this._shadowsSaturation = value;
        this._dirty = true;
      }
      /**
       * Gets the shadows Exposure value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
       */
      get shadowsExposure() {
        return this._shadowsExposure;
      }
      /**
       * Sets the shadows Exposure value.
       * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
       */
      set shadowsExposure(value) {
        this._shadowsExposure = value;
        this._dirty = true;
      }
      /**
       * Returns the class name
       * @returns The class name
       */
      getClassName() {
        return "ColorCurves";
      }
      /**
       * Binds the color curves to the shader.
       * @param colorCurves The color curve to bind
       * @param effect The effect to bind to
       * @param positiveUniform The positive uniform shader parameter
       * @param neutralUniform The neutral uniform shader parameter
       * @param negativeUniform The negative uniform shader parameter
       */
      static Bind(colorCurves, effect, positiveUniform = "vCameraColorCurvePositive", neutralUniform = "vCameraColorCurveNeutral", negativeUniform = "vCameraColorCurveNegative") {
        if (colorCurves._dirty) {
          colorCurves._dirty = false;
          colorCurves._getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
          colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
          colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
        }
        if (effect) {
          effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
          effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
          effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
        }
      }
      /**
       * Returns color grading data based on a hue, density, saturation and exposure value.
       * @param hue
       * @param density
       * @param saturation The saturation.
       * @param exposure The exposure.
       * @param result The result data container.
       */
      _getColorGradingDataToRef(hue, density, saturation, exposure, result) {
        if (hue == null) {
          return;
        }
        hue = _ColorCurves._Clamp(hue, 0, 360);
        density = _ColorCurves._Clamp(density, -100, 100);
        saturation = _ColorCurves._Clamp(saturation, -100, 100);
        exposure = _ColorCurves._Clamp(exposure, -100, 100);
        density = _ColorCurves._ApplyColorGradingSliderNonlinear(density);
        density *= 0.5;
        exposure = _ColorCurves._ApplyColorGradingSliderNonlinear(exposure);
        if (density < 0) {
          density *= -1;
          hue = (hue + 180) % 360;
        }
        _ColorCurves._FromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
        result.scaleToRef(2, result);
        result.a = 1 + 0.01 * saturation;
      }
      /**
       * Takes an input slider value and returns an adjusted value that provides extra control near the centre.
       * @param value The input slider value in range [-100,100].
       * @returns Adjusted value.
       */
      static _ApplyColorGradingSliderNonlinear(value) {
        value /= 100;
        let x = Math.abs(value);
        x = Math.pow(x, 2);
        if (value < 0) {
          x *= -1;
        }
        x *= 100;
        return x;
      }
      /**
       * Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).
       * @param hue The hue (H) input.
       * @param saturation The saturation (S) input.
       * @param brightness The brightness (B) input.
       * @param result
       * @result An RGBA color represented as Vector4.
       */
      static _FromHSBToRef(hue, saturation, brightness, result) {
        let h = _ColorCurves._Clamp(hue, 0, 360);
        const s = _ColorCurves._Clamp(saturation / 100, 0, 1);
        const v = _ColorCurves._Clamp(brightness / 100, 0, 1);
        if (s === 0) {
          result.r = v;
          result.g = v;
          result.b = v;
        } else {
          h /= 60;
          const i = Math.floor(h);
          const f = h - i;
          const p = v * (1 - s);
          const q = v * (1 - s * f);
          const t = v * (1 - s * (1 - f));
          switch (i) {
            case 0:
              result.r = v;
              result.g = t;
              result.b = p;
              break;
            case 1:
              result.r = q;
              result.g = v;
              result.b = p;
              break;
            case 2:
              result.r = p;
              result.g = v;
              result.b = t;
              break;
            case 3:
              result.r = p;
              result.g = q;
              result.b = v;
              break;
            case 4:
              result.r = t;
              result.g = p;
              result.b = v;
              break;
            default:
              result.r = v;
              result.g = p;
              result.b = q;
              break;
          }
        }
        result.a = 1;
      }
      /**
       * Returns a value clamped between min and max
       * @param value The value to clamp
       * @param min The minimum of value
       * @param max The maximum of value
       * @returns The clamped value.
       */
      static _Clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
      /**
       * Clones the current color curve instance.
       * @returns The cloned curves
       */
      clone() {
        return SerializationHelper.Clone(() => new _ColorCurves(), this);
      }
      /**
       * Serializes the current color curve instance to a json representation.
       * @returns a JSON representation
       */
      serialize() {
        return SerializationHelper.Serialize(this);
      }
      /**
       * Parses the color curve from a json representation.
       * @param source the JSON source to parse
       * @returns The parsed curves
       */
      static Parse(source) {
        return SerializationHelper.Parse(() => new _ColorCurves(), source, null, null);
      }
    };
    ColorCurves.PrepareUniforms = PrepareUniformsForColorCurves;
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_globalHue", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_globalDensity", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_globalSaturation", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_globalExposure", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_highlightsHue", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_highlightsDensity", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_highlightsSaturation", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_highlightsExposure", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_midtonesHue", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_midtonesDensity", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_midtonesSaturation", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_midtonesExposure", void 0);
    SerializationHelper._ColorCurvesParser = ColorCurves.Parse;
  }
});

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.functions.js
function PrepareUniformsForImageProcessing(uniforms, defines) {
  if (defines.EXPOSURE) {
    uniforms.push("exposureLinear");
  }
  if (defines.CONTRAST) {
    uniforms.push("contrast");
  }
  if (defines.COLORGRADING) {
    uniforms.push("colorTransformSettings");
  }
  if (defines.VIGNETTE || defines.DITHER) {
    uniforms.push("vInverseScreenSize");
  }
  if (defines.VIGNETTE) {
    uniforms.push("vignetteSettings1");
    uniforms.push("vignetteSettings2");
  }
  if (defines.COLORCURVES) {
    PrepareUniformsForColorCurves(uniforms);
  }
  if (defines.DITHER) {
    uniforms.push("ditherIntensity");
  }
}
function PrepareSamplersForImageProcessing(samplersList, defines) {
  if (defines.COLORGRADING) {
    samplersList.push("txColorTransform");
  }
}
var init_imageProcessingConfiguration_functions = __esm({
  "node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.functions.js"() {
    init_colorCurves_functions();
  }
});

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js
var ImageProcessingConfiguration;
var init_imageProcessingConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_math_color();
    init_colorCurves();
    init_tools_functions();
    init_decorators_serialization();
    init_imageProcessingConfiguration_functions();
    init_typeStore();
    ImageProcessingConfiguration = class _ImageProcessingConfiguration {
      constructor() {
        this.colorCurves = new ColorCurves();
        this._colorCurvesEnabled = false;
        this._colorGradingEnabled = false;
        this._colorGradingWithGreenDepth = true;
        this._colorGradingBGR = true;
        this._exposure = 1;
        this._toneMappingEnabled = false;
        this._toneMappingType = _ImageProcessingConfiguration.TONEMAPPING_STANDARD;
        this._contrast = 1;
        this.vignetteStretch = 0;
        this.vignetteCenterX = 0;
        this.vignetteCenterY = 0;
        this.vignetteWeight = 1.5;
        this.vignetteColor = new Color4(0, 0, 0, 0);
        this.vignetteCameraFov = 0.5;
        this._vignetteBlendMode = _ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY;
        this._vignetteEnabled = false;
        this._ditheringEnabled = false;
        this._ditheringIntensity = 1 / 255;
        this._skipFinalColorClamp = false;
        this._applyByPostProcess = false;
        this._isEnabled = true;
        this.outputTextureWidth = 0;
        this.outputTextureHeight = 0;
        this.onUpdateParameters = new Observable();
      }
      /**
       * Gets whether the color curves effect is enabled.
       */
      get colorCurvesEnabled() {
        return this._colorCurvesEnabled;
      }
      /**
       * Sets whether the color curves effect is enabled.
       */
      set colorCurvesEnabled(value) {
        if (this._colorCurvesEnabled === value) {
          return;
        }
        this._colorCurvesEnabled = value;
        this._updateParameters();
      }
      /**
       * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
       */
      get colorGradingTexture() {
        return this._colorGradingTexture;
      }
      /**
       * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
       */
      set colorGradingTexture(value) {
        if (this._colorGradingTexture === value) {
          return;
        }
        this._colorGradingTexture = value;
        this._updateParameters();
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      get colorGradingEnabled() {
        return this._colorGradingEnabled;
      }
      /**
       * Sets whether the color grading effect is enabled.
       */
      set colorGradingEnabled(value) {
        if (this._colorGradingEnabled === value) {
          return;
        }
        this._colorGradingEnabled = value;
        this._updateParameters();
      }
      /**
       * Gets whether the color grading effect is using a green depth for the 3d Texture.
       */
      get colorGradingWithGreenDepth() {
        return this._colorGradingWithGreenDepth;
      }
      /**
       * Sets whether the color grading effect is using a green depth for the 3d Texture.
       */
      set colorGradingWithGreenDepth(value) {
        if (this._colorGradingWithGreenDepth === value) {
          return;
        }
        this._colorGradingWithGreenDepth = value;
        this._updateParameters();
      }
      /**
       * Gets whether the color grading texture contains BGR values.
       */
      get colorGradingBGR() {
        return this._colorGradingBGR;
      }
      /**
       * Sets whether the color grading texture contains BGR values.
       */
      set colorGradingBGR(value) {
        if (this._colorGradingBGR === value) {
          return;
        }
        this._colorGradingBGR = value;
        this._updateParameters();
      }
      /**
       * Gets the Exposure used in the effect.
       */
      get exposure() {
        return this._exposure;
      }
      /**
       * Sets the Exposure used in the effect.
       */
      set exposure(value) {
        if (this._exposure === value) {
          return;
        }
        this._exposure = value;
        this._updateParameters();
      }
      /**
       * Gets whether the tone mapping effect is enabled.
       */
      get toneMappingEnabled() {
        return this._toneMappingEnabled;
      }
      /**
       * Sets whether the tone mapping effect is enabled.
       */
      set toneMappingEnabled(value) {
        if (this._toneMappingEnabled === value) {
          return;
        }
        this._toneMappingEnabled = value;
        this._updateParameters();
      }
      /**
       * Gets the type of tone mapping effect.
       */
      get toneMappingType() {
        return this._toneMappingType;
      }
      /**
       * Sets the type of tone mapping effect used in BabylonJS.
       */
      set toneMappingType(value) {
        if (this._toneMappingType === value) {
          return;
        }
        this._toneMappingType = value;
        this._updateParameters();
      }
      /**
       * Gets the contrast used in the effect.
       */
      get contrast() {
        return this._contrast;
      }
      /**
       * Sets the contrast used in the effect.
       */
      set contrast(value) {
        if (this._contrast === value) {
          return;
        }
        this._contrast = value;
        this._updateParameters();
      }
      /**
       * Back Compat: Vignette center Y Offset.
       * @deprecated use vignetteCenterY instead
       */
      get vignetteCentreY() {
        return this.vignetteCenterY;
      }
      set vignetteCentreY(value) {
        this.vignetteCenterY = value;
      }
      /**
       * Back Compat: Vignette center X Offset.
       * @deprecated use vignetteCenterX instead
       */
      get vignetteCentreX() {
        return this.vignetteCenterX;
      }
      set vignetteCentreX(value) {
        this.vignetteCenterX = value;
      }
      /**
       * Gets the vignette blend mode allowing different kind of effect.
       */
      get vignetteBlendMode() {
        return this._vignetteBlendMode;
      }
      /**
       * Sets the vignette blend mode allowing different kind of effect.
       */
      set vignetteBlendMode(value) {
        if (this._vignetteBlendMode === value) {
          return;
        }
        this._vignetteBlendMode = value;
        this._updateParameters();
      }
      /**
       * Gets whether the vignette effect is enabled.
       */
      get vignetteEnabled() {
        return this._vignetteEnabled;
      }
      /**
       * Sets whether the vignette effect is enabled.
       */
      set vignetteEnabled(value) {
        if (this._vignetteEnabled === value) {
          return;
        }
        this._vignetteEnabled = value;
        this._updateParameters();
      }
      /**
       * Gets whether the dithering effect is enabled.
       * The dithering effect can be used to reduce banding.
       */
      get ditheringEnabled() {
        return this._ditheringEnabled;
      }
      /**
       * Sets whether the dithering effect is enabled.
       * The dithering effect can be used to reduce banding.
       */
      set ditheringEnabled(value) {
        if (this._ditheringEnabled === value) {
          return;
        }
        this._ditheringEnabled = value;
        this._updateParameters();
      }
      /**
       * Gets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.
       */
      get ditheringIntensity() {
        return this._ditheringIntensity;
      }
      /**
       * Sets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.
       */
      set ditheringIntensity(value) {
        if (this._ditheringIntensity === value) {
          return;
        }
        this._ditheringIntensity = value;
        this._updateParameters();
      }
      /**
       * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader
       * Applies to PBR materials.
       */
      get skipFinalColorClamp() {
        return this._skipFinalColorClamp;
      }
      /**
       * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader
       * Applies to PBR materials.
       */
      set skipFinalColorClamp(value) {
        if (this._skipFinalColorClamp === value) {
          return;
        }
        this._skipFinalColorClamp = value;
        this._updateParameters();
      }
      /**
       * Gets whether the image processing is applied through a post process or not.
       */
      get applyByPostProcess() {
        return this._applyByPostProcess;
      }
      /**
       * Sets whether the image processing is applied through a post process or not.
       */
      set applyByPostProcess(value) {
        if (this._applyByPostProcess === value) {
          return;
        }
        this._applyByPostProcess = value;
        this._updateParameters();
      }
      /**
       * Gets whether the image processing is enabled or not.
       */
      get isEnabled() {
        return this._isEnabled;
      }
      /**
       * Sets whether the image processing is enabled or not.
       */
      set isEnabled(value) {
        if (this._isEnabled === value) {
          return;
        }
        this._isEnabled = value;
        this._updateParameters();
      }
      /**
       * Method called each time the image processing information changes requires to recompile the effect.
       */
      _updateParameters() {
        this.onUpdateParameters.notifyObservers(this);
      }
      /**
       * Gets the current class name.
       * @returns "ImageProcessingConfiguration"
       */
      getClassName() {
        return "ImageProcessingConfiguration";
      }
      /**
       * Prepare the list of defines associated to the shader.
       * @param defines the list of defines to complete
       * @param forPostProcess Define if we are currently in post process mode or not
       */
      prepareDefines(defines, forPostProcess = false) {
        if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
          defines.VIGNETTE = false;
          defines.TONEMAPPING = 0;
          defines.CONTRAST = false;
          defines.EXPOSURE = false;
          defines.COLORCURVES = false;
          defines.COLORGRADING = false;
          defines.COLORGRADING3D = false;
          defines.DITHER = false;
          defines.IMAGEPROCESSING = false;
          defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
          defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
          return;
        }
        defines.VIGNETTE = this.vignetteEnabled;
        defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === _ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY;
        defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
        if (!this._toneMappingEnabled) {
          defines.TONEMAPPING = 0;
        } else {
          switch (this._toneMappingType) {
            case _ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL:
              defines.TONEMAPPING = 3;
              break;
            case _ImageProcessingConfiguration.TONEMAPPING_ACES:
              defines.TONEMAPPING = 2;
              break;
            default:
              defines.TONEMAPPING = 1;
              break;
          }
        }
        defines.CONTRAST = this.contrast !== 1;
        defines.EXPOSURE = this.exposure !== 1;
        defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
        defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
        if (defines.COLORGRADING) {
          defines.COLORGRADING3D = this.colorGradingTexture.is3D;
        } else {
          defines.COLORGRADING3D = false;
        }
        defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
        defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
        defines.DITHER = this._ditheringEnabled;
        defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
        defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
        defines.IMAGEPROCESSING = defines.VIGNETTE || !!defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING || defines.DITHER;
      }
      /**
       * Returns true if all the image processing information are ready.
       * @returns True if ready, otherwise, false
       */
      isReady() {
        return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
      }
      /**
       * Binds the image processing to the shader.
       * @param effect The effect to bind to
       * @param overrideAspectRatio Override the aspect ratio of the effect
       */
      bind(effect, overrideAspectRatio) {
        if (this._colorCurvesEnabled && this.colorCurves) {
          ColorCurves.Bind(this.colorCurves, effect);
        }
        if (this._vignetteEnabled || this._ditheringEnabled) {
          const inverseWidth = 1 / (this.outputTextureWidth || effect.getEngine().getRenderWidth());
          const inverseHeight = 1 / (this.outputTextureHeight || effect.getEngine().getRenderHeight());
          effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
          if (this._ditheringEnabled) {
            effect.setFloat("ditherIntensity", 0.5 * this._ditheringIntensity);
          }
          if (this._vignetteEnabled) {
            const aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
            let vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
            let vignetteScaleX = vignetteScaleY * aspectRatio;
            const vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
            vignetteScaleX = Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
            vignetteScaleY = Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
            effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCenterX, -vignetteScaleY * this.vignetteCenterY);
            const vignettePower = -2 * this.vignetteWeight;
            effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
          }
        }
        effect.setFloat("exposureLinear", this.exposure);
        effect.setFloat("contrast", this.contrast);
        if (this.colorGradingTexture) {
          effect.setTexture("txColorTransform", this.colorGradingTexture);
          const textureSize = this.colorGradingTexture.getSize().height;
          effect.setFloat4(
            "colorTransformSettings",
            (textureSize - 1) / textureSize,
            // textureScale
            0.5 / textureSize,
            // textureOffset
            textureSize,
            // textureSize
            this.colorGradingTexture.level
            // weight
          );
        }
      }
      /**
       * Clones the current image processing instance.
       * @returns The cloned image processing
       */
      clone() {
        return SerializationHelper.Clone(() => new _ImageProcessingConfiguration(), this);
      }
      /**
       * Serializes the current image processing instance to a json representation.
       * @returns a JSON representation
       */
      serialize() {
        return SerializationHelper.Serialize(this);
      }
      /**
       * Parses the image processing from a json representation.
       * @param source the JSON source to parse
       * @returns The parsed image processing
       */
      static Parse(source) {
        const parsed = SerializationHelper.Parse(() => new _ImageProcessingConfiguration(), source, null, null);
        if (source.vignetteCentreX !== void 0) {
          parsed.vignetteCenterX = source.vignetteCentreX;
        }
        if (source.vignetteCentreY !== void 0) {
          parsed.vignetteCenterY = source.vignetteCentreY;
        }
        return parsed;
      }
      /**
       * Used to apply the vignette as a mix with the pixel color.
       */
      static get VIGNETTEMODE_MULTIPLY() {
        return this._VIGNETTEMODE_MULTIPLY;
      }
      /**
       * Used to apply the vignette as a replacement of the pixel color.
       */
      static get VIGNETTEMODE_OPAQUE() {
        return this._VIGNETTEMODE_OPAQUE;
      }
    };
    ImageProcessingConfiguration.TONEMAPPING_STANDARD = 0;
    ImageProcessingConfiguration.TONEMAPPING_ACES = 1;
    ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL = 2;
    ImageProcessingConfiguration.PrepareUniforms = PrepareUniformsForImageProcessing;
    ImageProcessingConfiguration.PrepareSamplers = PrepareSamplersForImageProcessing;
    ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY = 0;
    ImageProcessingConfiguration._VIGNETTEMODE_OPAQUE = 1;
    __decorate([
      serializeAsColorCurves()
    ], ImageProcessingConfiguration.prototype, "colorCurves", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_colorCurvesEnabled", void 0);
    __decorate([
      serializeAsTexture("colorGradingTexture")
    ], ImageProcessingConfiguration.prototype, "_colorGradingTexture", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_colorGradingEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_colorGradingWithGreenDepth", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_colorGradingBGR", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_exposure", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_toneMappingEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_toneMappingType", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_contrast", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteStretch", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteCenterX", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteCenterY", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteWeight", void 0);
    __decorate([
      serializeAsColor4()
    ], ImageProcessingConfiguration.prototype, "vignetteColor", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteCameraFov", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_vignetteBlendMode", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_vignetteEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_ditheringEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_ditheringIntensity", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_skipFinalColorClamp", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_applyByPostProcess", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_isEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "outputTextureWidth", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "outputTextureHeight", void 0);
    SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;
    RegisterClass("BABYLON.ImageProcessingConfiguration", ImageProcessingConfiguration);
  }
});

export {
  ColorCurves,
  init_colorCurves,
  PrepareUniformsForImageProcessing,
  PrepareSamplersForImageProcessing,
  init_imageProcessingConfiguration_functions,
  ImageProcessingConfiguration,
  init_imageProcessingConfiguration
};
//# sourceMappingURL=chunk-MWHX2QIB.js.map
