import {
  FlowGraphExecutionBlockWithOutSignal,
  init_flowGraphExecutionBlockWithOutSignal
} from "./chunk-AZ5WND6M.js";
import {
  __esm
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babylonjs/core/FlowGraph/flowGraphAsyncExecutionBlock.js
var FlowGraphAsyncExecutionBlock;
var init_flowGraphAsyncExecutionBlock = __esm({
  "node_modules/@babylonjs/core/FlowGraph/flowGraphAsyncExecutionBlock.js"() {
    init_flowGraphExecutionBlockWithOutSignal();
    FlowGraphAsyncExecutionBlock = class extends FlowGraphExecutionBlockWithOutSignal {
      constructor(config, events) {
        super(config);
        this._eventsSignalOutputs = {};
        this.done = this._registerSignalOutput("done");
        events == null ? void 0 : events.forEach((eventName) => {
          this._eventsSignalOutputs[eventName] = this._registerSignalOutput(eventName + "Event");
        });
      }
      /**
       * @internal
       * This function can be overridden to execute any
       * logic that should be executed on every frame
       * while the async task is pending.
       * @param context the context in which it is running
       */
      _executeOnTick(_context) {
      }
      /**
       * @internal
       * @param context
       */
      _startPendingTasks(context) {
        if (context._getExecutionVariable(this, "_initialized", false)) {
          this._cancelPendingTasks(context);
          this._resetAfterCanceled(context);
        }
        this._preparePendingTasks(context);
        context._addPendingBlock(this);
        this.out._activateSignal(context);
        context._setExecutionVariable(this, "_initialized", true);
      }
      _resetAfterCanceled(context) {
        context._deleteExecutionVariable(this, "_initialized");
        context._removePendingBlock(this);
      }
    };
  }
});

export {
  FlowGraphAsyncExecutionBlock,
  init_flowGraphAsyncExecutionBlock
};
//# sourceMappingURL=chunk-RKHV4AVU.js.map
