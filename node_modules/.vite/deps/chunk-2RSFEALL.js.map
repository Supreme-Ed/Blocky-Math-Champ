{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/WebGPU/webgpuPerfCounter.ts", "../../../dev/core/src/Compute/computeShader.ts", "../../../dev/core/src/Buffers/storageBuffer.ts", "../../../dev/core/src/ShadersWGSL/boundingInfo.compute.ts", "../../../dev/core/src/Culling/Helper/computeShaderBoundingHelper.ts"],
  "sourcesContent": ["import { PerfCounter } from \"../../Misc/perfCounter\";\r\n\r\n/**\r\n * Class used to define a WebGPU performance counter\r\n */\r\nexport class WebGPUPerfCounter {\r\n    private _gpuTimeInFrameId = -1;\r\n\r\n    /**\r\n     * The GPU time in nanoseconds spent in the last frame\r\n     */\r\n    public counter = new PerfCounter();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addDuration(currentFrameId: number, duration: number) {\r\n        if (currentFrameId < this._gpuTimeInFrameId) {\r\n            return;\r\n        }\r\n        if (this._gpuTimeInFrameId !== currentFrameId) {\r\n            this.counter._fetchResult();\r\n            this.counter.fetchNewFrame();\r\n            this.counter.addCount(duration, false);\r\n            this._gpuTimeInFrameId = currentFrameId;\r\n        } else {\r\n            this.counter.addCount(duration, false);\r\n        }\r\n    }\r\n}\r\n", "import type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { WebGPUEngine } from \"../Engines/webgpuEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { ComputeEffect, IComputeEffectCreationOptions, IComputeShaderPath } from \"./computeEffect\";\r\nimport type { ComputeBindingMapping } from \"../Engines/Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator\";\r\nimport type { IComputeContext } from \"./IComputeContext\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport type { ExternalTexture } from \"core/Materials/Textures/externalTexture\";\r\nimport type { VideoTexture } from \"core/Materials/Textures/videoTexture\";\r\nimport { WebGPUPerfCounter } from \"core/Engines/WebGPU/webgpuPerfCounter\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { _retryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * Defines the options associated with the creation of a compute shader.\r\n */\r\nexport interface IComputeShaderOptions {\r\n    /**\r\n     * list of bindings mapping (key is property name, value is binding location)\r\n     * Must be provided because browsers don't support reflection for wgsl shaders yet (so there's no way to query the binding/group from a variable name)\r\n     * TODO: remove this when browsers support reflection for wgsl shaders\r\n     */\r\n    bindingsMapping: ComputeBindingMapping;\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\ntype ComputeBindingListInternal = { [key: string]: { type: ComputeBindingType; object: any; indexInGroupEntries?: number; buffer?: Nullable<DataBuffer> } };\r\n\r\n/**\r\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\r\n */\r\nexport class ComputeShader {\r\n    private _engine: AbstractEngine;\r\n    private _shaderPath: IComputeShaderPath | string;\r\n    private _options: IComputeShaderOptions;\r\n    private _effect: ComputeEffect;\r\n    private _cachedDefines: string;\r\n    private _bindings: ComputeBindingListInternal = {};\r\n    private _samplers: { [key: string]: TextureSampler } = {};\r\n    private _context: IComputeContext;\r\n    private _contextIsDirty = false;\r\n\r\n    /**\r\n     * Gets the unique id of the compute shader\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * The name of the shader\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The options used to create the shader\r\n     */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * The shaderPath used to create the shader\r\n     */\r\n    public get shaderPath() {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * When set to true, dispatch won't call isReady anymore and won't check if the underlying GPU resources should be (re)created because of a change in the inputs (texture, uniform buffer, etc.)\r\n     * If you know that your inputs did not change since last time dispatch was called and that isReady() returns true, set this flag to true to improve performance\r\n     */\r\n    @serialize()\r\n    public fastMode = false;\r\n\r\n    /**\r\n     * Callback triggered when the shader is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Gets the GPU time spent running the compute shader for the last frame rendered (in nanoseconds).\r\n     * You have to enable the \"timestamp-query\" extension in the engine constructor options and set engine.enableGPUTimingMeasurements = true.\r\n     */\r\n    public readonly gpuTimeInFrame?: WebGPUPerfCounter;\r\n\r\n    /**\r\n     * Instantiates a new compute shader.\r\n     * @param name Defines the name of the compute shader in the scene\r\n     * @param engine Defines the engine the compute shader belongs to\r\n     * @param shaderPath Defines the route to the shader code in one of three ways:\r\n     *  * object: \\{ compute: \"custom\" \\}, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\r\n     *  * object: \\{ computeElement: \"HTMLElementId\" \\}, used with shader code in script tags\r\n     *  * object: \\{ computeSource: \"compute shader code string\" \\}, where the string contains the shader code\r\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, engine: AbstractEngine, shaderPath: IComputeShaderPath | string, options: Partial<IComputeShaderOptions> = {}) {\r\n        this.name = name;\r\n        this._engine = engine;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n        if ((engine as WebGPUEngine).enableGPUTimingMeasurements) {\r\n            this.gpuTimeInFrame = new WebGPUPerfCounter();\r\n        }\r\n\r\n        if (!this._engine.getCaps().supportComputeShaders) {\r\n            Logger.Error(\"This engine does not support compute shaders!\");\r\n            return;\r\n        }\r\n        if (!options.bindingsMapping) {\r\n            Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\r\n            return;\r\n        }\r\n\r\n        this._context = engine.createComputeContext()!;\r\n        this._shaderPath = shaderPath;\r\n        this._options = {\r\n            bindingsMapping: {},\r\n            defines: [],\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ComputeShader\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ComputeShader\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture, bindSampler = true): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._bindings[name] = {\r\n            type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture || current.type !== this._bindings[name].type;\r\n    }\r\n\r\n    /**\r\n     * Binds a storage texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setStorageTexture(name: string, texture: BaseTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds an external texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.ExternalTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a video texture to the shader (by binding the external texture attached to this video)\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @returns true if the video texture was successfully bound, else false. false will be returned if the current engine does not support external textures\r\n     */\r\n    public setVideoTexture(name: string, texture: VideoTexture) {\r\n        if (texture.externalTexture) {\r\n            this.setExternalTexture(name, texture.externalTexture);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Binds a uniform buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer | DataBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeShader._BufferIsDataBuffer(buffer) ? ComputeBindingType.DataBuffer : ComputeBindingType.UniformBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a storage buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer | DataBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeShader._BufferIsDataBuffer(buffer) ? ComputeBindingType.DataBuffer : ComputeBindingType.StorageBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a texture sampler to the shader\r\n     * @param name Binding name of the sampler\r\n     * @param sampler Sampler to bind\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || !sampler.compareSampler(current.object);\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.Sampler,\r\n            object: sampler,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\r\n     * @returns true if the compute shader is ready to be executed\r\n     */\r\n    public isReady(): boolean {\r\n        let effect = this._effect;\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key],\r\n                type = binding.type,\r\n                object = binding.object;\r\n\r\n            switch (type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const texture = object as BaseTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n                case ComputeBindingType.ExternalTexture: {\r\n                    const texture = object as ExternalTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const shaderName = this._shaderPath;\r\n\r\n        if (this._options.defines) {\r\n            for (let index = 0; index < this._options.defines.length; index++) {\r\n                defines.push(this._options.defines[index]);\r\n            }\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            effect = this._engine.createComputeEffect(shaderName, <IComputeEffectCreationOptions>{\r\n                defines: join,\r\n                entryPoint: this._options.entryPoint,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n            });\r\n\r\n            this._effect = effect;\r\n        }\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatch(x: number, y?: number, z?: number): boolean {\r\n        if (!this.fastMode && !this._checkContext()) {\r\n            return false;\r\n        }\r\n        this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping, this.gpuTimeInFrame);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader.\r\n     * @param buffer Buffer containing the number of workgroups to execute on the X, Y and Z dimensions\r\n     * @param offset Offset in the buffer where the workgroup counts are stored (default: 0)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatchIndirect(buffer: StorageBuffer | DataBuffer, offset: number = 0): boolean {\r\n        if (!this.fastMode && !this._checkContext()) {\r\n            return false;\r\n        }\r\n        const dataBuffer = ComputeShader._BufferIsDataBuffer(buffer) ? buffer : buffer.getBuffer();\r\n        this._engine.computeDispatchIndirect(this._effect, this._context, this._bindings, dataBuffer, offset, this._options.bindingsMapping, this.gpuTimeInFrame);\r\n        return true;\r\n    }\r\n\r\n    private _checkContext(): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\r\n        // Also, if the actual (gpu) buffer used by a uniform buffer has changed, we must clear the compute context so that it is recreated with the updated value\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n\r\n            if (!this._options.bindingsMapping[key]) {\r\n                throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\r\n            }\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture: {\r\n                    const sampler = this._samplers[key];\r\n                    const texture = binding.object as BaseTexture;\r\n\r\n                    if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\r\n                        this._samplers[key] = new TextureSampler().setParameters(\r\n                            texture.wrapU,\r\n                            texture.wrapV,\r\n                            texture.wrapR,\r\n                            texture.anisotropicFilteringLevel,\r\n                            texture._texture!.samplingMode,\r\n                            texture._texture?._comparisonFunction\r\n                        );\r\n                        this._contextIsDirty = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case ComputeBindingType.ExternalTexture: {\r\n                    // we must recreate the bind groups each time if there's an external texture, because device.importExternalTexture must be called each frame\r\n                    this._contextIsDirty = true;\r\n                    break;\r\n                }\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    const ubo = binding.object as UniformBuffer;\r\n                    if (ubo.getBuffer() !== binding.buffer) {\r\n                        binding.buffer = ubo.getBuffer();\r\n                        this._contextIsDirty = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._contextIsDirty) {\r\n            this._contextIsDirty = false;\r\n            this._context.clear();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Waits for the compute shader to be ready and executes it\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\r\n     * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\r\n     */\r\n    public dispatchWhenReady(x: number, y?: number, z?: number, delay = 10): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            _retryWithInterval(() => this.dispatch(x, y, z), resolve, undefined, delay);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes this compute shader in a JSON representation\r\n     * @returns the serialized compute shader object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.bindings = {};\r\n        serializationObject.textures = {};\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n            const object = binding.object;\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const serializedData = (object as BaseTexture).serialize();\r\n                    if (serializedData) {\r\n                        serializationObject.textures[key] = serializedData;\r\n                        serializationObject.bindings[key] = {\r\n                            type: binding.type,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a compute shader from parsed compute shader data\r\n     * @param source defines the JSON representation of the compute shader\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new compute shader\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ComputeShader {\r\n        const compute = SerializationHelper.Parse(\r\n            () => new ComputeShader(source.name, scene.getEngine() as WebGPUEngine, source.shaderPath, source.options),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        for (const key in source.textures) {\r\n            const binding = source.bindings[key];\r\n            const texture = <Texture>Texture.Parse(source.textures[key], scene, rootUrl);\r\n\r\n            if (binding.type === ComputeBindingType.Texture) {\r\n                compute.setTexture(key, texture);\r\n            } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\r\n                compute.setTexture(key, texture, false);\r\n            } else {\r\n                compute.setStorageTexture(key, texture);\r\n            }\r\n        }\r\n\r\n        return compute;\r\n    }\r\n\r\n    protected static _BufferIsDataBuffer(buffer: UniformBuffer | StorageBuffer | DataBuffer): buffer is DataBuffer {\r\n        return (buffer as DataBuffer).underlyingResource !== undefined;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\r\n", "import type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { DataArray } from \"../types\";\r\nimport type { WebGPUEngine } from \"core/Engines/webgpuEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * This class is a small wrapper around a native buffer that can be read and/or written\r\n */\r\nexport class StorageBuffer {\r\n    private _engine: WebGPUEngine;\r\n    private _buffer: DataBuffer;\r\n    private _bufferSize: number;\r\n    private _creationFlags: number;\r\n    private _label?: string;\r\n\r\n    /**\r\n     * Creates a new storage buffer instance\r\n     * @param engine The engine the buffer will be created inside\r\n     * @param size The size of the buffer in bytes\r\n     * @param creationFlags flags to use when creating the buffer (see Constants.BUFFER_CREATIONFLAG_XXX). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added.\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     */\r\n    constructor(engine: WebGPUEngine, size: number, creationFlags = Constants.BUFFER_CREATIONFLAG_READWRITE, label?: string) {\r\n        this._engine = engine;\r\n        this._label = label;\r\n        this._engine._storageBuffers.push(this);\r\n        this._create(size, creationFlags);\r\n    }\r\n\r\n    private _create(size: number, creationFlags: number): void {\r\n        this._bufferSize = size;\r\n        this._creationFlags = creationFlags;\r\n        this._buffer = this._engine.createStorageBuffer(size, creationFlags, this._label);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this._create(this._bufferSize, this._creationFlags);\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): DataBuffer {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Updates the storage buffer\r\n     * @param data the data used to update the storage buffer\r\n     * @param byteOffset the byte offset of the data (optional)\r\n     * @param byteLength the byte length of the data (optional)\r\n     */\r\n    public update(data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        this._engine.updateStorageBuffer(this._buffer, data, byteOffset, byteLength);\r\n    }\r\n\r\n    /**\r\n     * Reads data from the storage buffer\r\n     * @param offset The offset in the storage buffer to start reading from (default: 0)\r\n     * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\r\n     * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\r\n     * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately. This can speed up data retrieval, at the cost of a small perf penalty (default: false).\r\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n     */\r\n    public read(offset?: number, size?: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView> {\r\n        return this._engine.readFromStorageBuffer(this._buffer, offset, size, buffer, noDelay);\r\n    }\r\n\r\n    /**\r\n     * Disposes the storage buffer\r\n     */\r\n    public dispose(): void {\r\n        const storageBuffers = this._engine._storageBuffers;\r\n        const index = storageBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            storageBuffers[index] = storageBuffers[storageBuffers.length - 1];\r\n            storageBuffers.pop();\r\n        }\r\n\r\n        this._engine._releaseBuffer(this._buffer);\r\n        this._buffer = null as any;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"boundingInfoComputeShader\";\nconst shader = `struct Results {minX : atomic<i32>,\nminY : atomic<i32>,\nminZ : atomic<i32>,\nmaxX : atomic<i32>,\nmaxY : atomic<i32>,\nmaxZ : atomic<i32>,\ndummy1 : i32,\ndummy2 : i32,};fn floatToBits(value: f32)->i32 {return bitcast<i32>(value);}\nfn bitsToFloat(value: i32)->f32 {return bitcast<f32>(value);}\nfn atomicMinFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value>=oldValue) {break;}\nif (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}\nfn atomicMaxFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value<=oldValue) {break;}\nif (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}\nfn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>\n{let offset=i32(index) *4; \nlet m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}\nconst identity=mat4x4f(\nvec4f(1.0,0.0,0.0,0.0),\nvec4f(0.0,1.0,0.0,0.0),\nvec4f(0.0,0.0,1.0,0.0),\nvec4f(0.0,0.0,0.0,1.0)\n);struct Settings {morphTargetTextureInfo: vec3f,\nmorphTargetCount: i32,\nindexResult : u32,};@group(0) @binding(0) var<storage,read> positionBuffer : array<f32>;@group(0) @binding(1) var<storage,read_write> resultBuffer : array<Results>;@group(0) @binding(7) var<uniform> settings : Settings;\n#if NUM_BONE_INFLUENCERS>0\n@group(0) @binding(2) var boneSampler : texture_2d<f32>;@group(0) @binding(3) var<storage,read> indexBuffer : array<vec4f>;@group(0) @binding(4) var<storage,read> weightBuffer : array<vec4f>;\n#if NUM_BONE_INFLUENCERS>4\n@group(0) @binding(5) var<storage,read> indexExtraBuffer : array<vec4f>;@group(0) @binding(6) var<storage,read> weightExtraBuffer : array<vec4f>;\n#endif\n#endif\n#ifdef MORPHTARGETS\n@group(0) @binding(8) var morphTargets : texture_2d_array<f32>;@group(0) @binding(9) var<storage,read> morphTargetInfluences : array<f32>;@group(0) @binding(10) var<storage,read> morphTargetTextureIndices : array<f32>;\n#endif\n#ifdef MORPHTARGETS\nfn readVector3FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec3f\n{ \nlet vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0).xyz;}\nfn readVector4FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec4f\n{ \nlet vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0);}\n#endif\n@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {let index=global_id.x;if (index>=arrayLength(&positionBuffer)/3) {return;}\nlet position=vec3f(positionBuffer[index*3],positionBuffer[index*3+1],positionBuffer[index*3+2]);var finalWorld=identity;var positionUpdated=position;\n#if NUM_BONE_INFLUENCERS>0\nvar influence : mat4x4<f32>;let matricesIndices=indexBuffer[index];let matricesWeights=weightBuffer[index];influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif \n#if NUM_BONE_INFLUENCERS>4\nlet matricesIndicesExtra=indexExtraBuffer[index];let matricesWeightsExtra=weightExtraBuffer[index];influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.x)*matricesWeightsExtra.x;\n#if NUM_BONE_INFLUENCERS>5\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.y)*matricesWeightsExtra.y;\n#endif \n#if NUM_BONE_INFLUENCERS>6\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.z)*matricesWeightsExtra.z;\n#endif \n#if NUM_BONE_INFLUENCERS>7\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.w)*matricesWeightsExtra.w;\n#endif \n#endif \nfinalWorld=finalWorld*influence;\n#endif\n#ifdef MORPHTARGETS\nfor (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (i>=settings.morphTargetCount) {break;}\npositionUpdated=positionUpdated+(readVector3FromRawSampler(i,index)-position)*morphTargetInfluences[i];}\n#endif\nvar worldPos=finalWorld*vec4f(positionUpdated.x,positionUpdated.y,positionUpdated.z,1.0);atomicMinFloat(&resultBuffer[settings.indexResult].minX,worldPos.x);atomicMinFloat(&resultBuffer[settings.indexResult].minY,worldPos.y);atomicMinFloat(&resultBuffer[settings.indexResult].minZ,worldPos.z);atomicMaxFloat(&resultBuffer[settings.indexResult].maxX,worldPos.x);atomicMaxFloat(&resultBuffer[settings.indexResult].maxY,worldPos.y);atomicMaxFloat(&resultBuffer[settings.indexResult].maxZ,worldPos.z);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const boundingInfoComputeShaderWGSL = { name, shader };\n", "import type { IBoundingInfoHelperPlatform } from \"./IBoundingInfoHelperPlatform\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { ComputeShader } from \"core/Compute/computeShader\";\r\nimport { StorageBuffer } from \"core/Buffers/storageBuffer\";\r\nimport type { WebGPUEngine } from \"core/Engines/webgpuEngine\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { UniformBuffer } from \"core/Materials/uniformBuffer\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport type { ComputeBindingMapping } from \"core/Engines/Extensions/engine.computeShader\";\r\n\r\nimport \"../../ShadersWGSL/boundingInfo.compute\";\r\nimport { _retryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/** @internal */\r\nexport class ComputeShaderBoundingHelper implements IBoundingInfoHelperPlatform {\r\n    private _engine: AbstractEngine;\r\n    private _computeShadersCache: { [key: string]: ComputeShader } = {};\r\n    private _positionBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _indexBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _weightBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _indexExtraBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _weightExtraBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _morphTargetInfluenceBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _morphTargetTextureIndexBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _ubos: UniformBuffer[] = [];\r\n    private _uboIndex: number = 0;\r\n    private _processedMeshes: AbstractMesh[] = [];\r\n    private _computeShaders: ComputeShader[][] = [];\r\n    private _uniqueComputeShaders: Set<ComputeShader> = new Set();\r\n    private _resultBuffers: StorageBuffer[] = [];\r\n\r\n    /**\r\n     * Creates a new ComputeShaderBoundingHelper\r\n     * @param engine defines the engine to use\r\n     */\r\n    constructor(engine: AbstractEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    private _getComputeShader(defines: string[], hasBones: boolean, hasMorphs: boolean) {\r\n        let computeShader: ComputeShader;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (!this._computeShadersCache[join]) {\r\n            const bindingsMapping: ComputeBindingMapping = {\r\n                positionBuffer: { group: 0, binding: 0 },\r\n                resultBuffer: { group: 0, binding: 1 },\r\n                settings: { group: 0, binding: 7 },\r\n            };\r\n\r\n            if (hasBones) {\r\n                bindingsMapping.boneSampler = { group: 0, binding: 2 };\r\n                bindingsMapping.indexBuffer = { group: 0, binding: 3 };\r\n                bindingsMapping.weightBuffer = { group: 0, binding: 4 };\r\n                bindingsMapping.indexExtraBuffer = { group: 0, binding: 5 };\r\n                bindingsMapping.weightExtraBuffer = { group: 0, binding: 6 };\r\n            }\r\n            if (hasMorphs) {\r\n                bindingsMapping.morphTargets = { group: 0, binding: 8 };\r\n                bindingsMapping.morphTargetInfluences = { group: 0, binding: 9 };\r\n                bindingsMapping.morphTargetTextureIndices = { group: 0, binding: 10 };\r\n            }\r\n\r\n            computeShader = new ComputeShader(`boundingInfoCompute${hasBones ? \"_bones\" : \"\"}${hasMorphs ? \"_morphs\" : \"\"}`, this._engine, \"boundingInfo\", {\r\n                bindingsMapping,\r\n                defines: defines,\r\n            });\r\n            this._computeShadersCache[join] = computeShader;\r\n        } else {\r\n            computeShader = this._computeShadersCache[join];\r\n        }\r\n\r\n        return computeShader;\r\n    }\r\n\r\n    private _getUBO() {\r\n        if (this._uboIndex >= this._ubos.length) {\r\n            const ubo = new UniformBuffer(this._engine);\r\n            ubo.addFloat3(\"morphTargetTextureInfo\", 0, 0, 0);\r\n            ubo.addUniform(\"morphTargetCount\", 1);\r\n            ubo.addUniform(\"indexResult\", 1);\r\n            this._ubos.push(ubo);\r\n        }\r\n\r\n        return this._ubos[this._uboIndex++];\r\n    }\r\n\r\n    private _extractDataAndLink(computeShader: ComputeShader, mesh: Mesh, kind: string, stride: number, name: string, storageUnit: { [key: number]: StorageBuffer }) {\r\n        let buffer: StorageBuffer;\r\n        const vertexCount = mesh.getTotalVertices();\r\n        if (!storageUnit[mesh.uniqueId]) {\r\n            const dataArray = mesh.getVertexBuffer(kind)?.getFloatData(vertexCount);\r\n            buffer = new StorageBuffer(this._engine as WebGPUEngine, Float32Array.BYTES_PER_ELEMENT * vertexCount * stride);\r\n            buffer.update(dataArray!);\r\n\r\n            storageUnit[mesh.uniqueId] = buffer;\r\n        } else {\r\n            buffer = storageUnit[mesh.uniqueId];\r\n        }\r\n\r\n        computeShader.setStorageBuffer(name, buffer);\r\n    }\r\n\r\n    private _prepareStorage(computeShader: ComputeShader, name: string, id: number, storageUnit: { [key: number]: StorageBuffer }, numInfluencers: number, data: Float32Array) {\r\n        let buffer: StorageBuffer;\r\n        if (!storageUnit[id]) {\r\n            buffer = new StorageBuffer(this._engine as WebGPUEngine, Float32Array.BYTES_PER_ELEMENT * numInfluencers);\r\n\r\n            storageUnit[id] = buffer;\r\n        } else {\r\n            buffer = storageUnit[id];\r\n        }\r\n        buffer.update(data);\r\n\r\n        computeShader.setStorageBuffer(name, buffer);\r\n    }\r\n\r\n    /** @internal */\r\n    public async processAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        await this.registerMeshListAsync(meshes);\r\n        this.processMeshList();\r\n        await this.fetchResultsForMeshListAsync();\r\n    }\r\n\r\n    /** @internal */\r\n    public registerMeshListAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        this._disposeForMeshList();\r\n\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        let maxNumInfluencers = 0;\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n            const vertexCount = mesh.getTotalVertices();\r\n\r\n            if (vertexCount === 0 || !(mesh as Mesh).getVertexBuffer || !(mesh as Mesh).getVertexBuffer(VertexBuffer.PositionKind)) {\r\n                continue;\r\n            }\r\n\r\n            this._processedMeshes.push(mesh);\r\n\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.supportsPositions) {\r\n                maxNumInfluencers = Math.max(maxNumInfluencers, manager.numTargets);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this._processedMeshes.length; i++) {\r\n            const mesh = this._processedMeshes[i];\r\n            let defines = [\"\"];\r\n\r\n            let hasBones = false;\r\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n                hasBones = true;\r\n            }\r\n\r\n            const computeShaderWithoutMorph = this._getComputeShader(defines, hasBones, false);\r\n\r\n            this._uniqueComputeShaders.add(computeShaderWithoutMorph);\r\n\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.supportsPositions) {\r\n                defines = defines.slice();\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + maxNumInfluencers);\r\n\r\n                const computeShaderWithMorph = this._getComputeShader(defines, hasBones, true);\r\n\r\n                this._uniqueComputeShaders.add(computeShaderWithMorph);\r\n                this._computeShaders.push([computeShaderWithoutMorph, computeShaderWithMorph]);\r\n            } else {\r\n                this._computeShaders.push([computeShaderWithoutMorph, computeShaderWithoutMorph]);\r\n            }\r\n\r\n            // Pre-build the ubos, as they won't change if there's no morph targets\r\n            const ubo = this._getUBO();\r\n            ubo.updateUInt(\"indexResult\", i);\r\n\r\n            ubo.update();\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            _retryWithInterval(() => {\r\n                const iterator = this._uniqueComputeShaders.keys();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const computeShader = key.value;\r\n                    if (!computeShader.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }, resolve);\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public processMeshList(): void {\r\n        if (this._processedMeshes.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._uboIndex = 0;\r\n\r\n        const resultDataSize = 8 * this._processedMeshes.length;\r\n        const resultData = new Float32Array(resultDataSize);\r\n\r\n        const resultBuffer = new StorageBuffer(this._engine as WebGPUEngine, Float32Array.BYTES_PER_ELEMENT * resultDataSize);\r\n        this._resultBuffers.push(resultBuffer);\r\n\r\n        for (let i = 0; i < this._processedMeshes.length; i++) {\r\n            resultData[i * 8 + 0] = Number.POSITIVE_INFINITY;\r\n            resultData[i * 8 + 1] = Number.POSITIVE_INFINITY;\r\n            resultData[i * 8 + 2] = Number.POSITIVE_INFINITY;\r\n\r\n            resultData[i * 8 + 3] = Number.NEGATIVE_INFINITY;\r\n            resultData[i * 8 + 4] = Number.NEGATIVE_INFINITY;\r\n            resultData[i * 8 + 5] = Number.NEGATIVE_INFINITY;\r\n        }\r\n\r\n        resultBuffer.update(resultData);\r\n\r\n        for (let i = 0; i < this._processedMeshes.length; i++) {\r\n            const mesh = this._processedMeshes[i];\r\n            const vertexCount = mesh.getTotalVertices();\r\n\r\n            const [computeShaderWithoutMorph, computeShaderWithMorph] = this._computeShaders[i];\r\n\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            const hasMorphs = manager && manager.numInfluencers > 0 && manager.supportsPositions;\r\n            const computeShader = hasMorphs ? computeShaderWithMorph : computeShaderWithoutMorph;\r\n\r\n            this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.PositionKind, 3, \"positionBuffer\", this._positionBuffers);\r\n\r\n            // Bones\r\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton && mesh.skeleton.useTextureToStoreBoneMatrices) {\r\n                this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.MatricesIndicesKind, 4, \"indexBuffer\", this._indexBuffers);\r\n                this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.MatricesWeightsKind, 4, \"weightBuffer\", this._weightBuffers);\r\n                const boneSampler = mesh.skeleton.getTransformMatrixTexture(mesh);\r\n                computeShader.setTexture(\"boneSampler\", boneSampler!, false);\r\n                if (mesh.numBoneInfluencers > 4) {\r\n                    this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.MatricesIndicesExtraKind, 4, \"indexExtraBuffer\", this._indexExtraBuffers);\r\n                    this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.MatricesWeightsExtraKind, 4, \"weightExtraBuffer\", this._weightExtraBuffers);\r\n                }\r\n            }\r\n\r\n            const ubo = this._getUBO();\r\n\r\n            // Morphs\r\n            if (hasMorphs) {\r\n                const morphTargets = manager._targetStoreTexture;\r\n                computeShader.setTexture(\"morphTargets\", morphTargets!, false);\r\n\r\n                this._prepareStorage(computeShader, \"morphTargetInfluences\", mesh.uniqueId, this._morphTargetInfluenceBuffers, manager.numInfluencers, manager.influences);\r\n                this._prepareStorage(\r\n                    computeShader,\r\n                    \"morphTargetTextureIndices\",\r\n                    mesh.uniqueId,\r\n                    this._morphTargetTextureIndexBuffers,\r\n                    manager.numInfluencers,\r\n                    manager._morphTargetTextureIndices\r\n                );\r\n\r\n                ubo.updateFloat3(\"morphTargetTextureInfo\", manager._textureVertexStride, manager._textureWidth, manager._textureHeight);\r\n                ubo.updateInt(\"morphTargetCount\", manager.numInfluencers);\r\n                ubo.update();\r\n            }\r\n\r\n            computeShader.setStorageBuffer(\"resultBuffer\", resultBuffer);\r\n\r\n            computeShader.setUniformBuffer(\"settings\", ubo);\r\n\r\n            // Dispatch\r\n            computeShader.dispatch(Math.ceil(vertexCount / 256));\r\n\r\n            this._engine.flushFramebuffer();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public fetchResultsForMeshListAsync(): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            const buffers: DataBuffer[] = [];\r\n            let size = 0;\r\n            for (let i = 0; i < this._resultBuffers.length; i++) {\r\n                const buffer = this._resultBuffers[i].getBuffer();\r\n                buffers.push(buffer);\r\n                size += buffer.capacity;\r\n            }\r\n\r\n            const resultData = new Float32Array(size / Float32Array.BYTES_PER_ELEMENT);\r\n\r\n            const minimum = Vector3.Zero();\r\n            const maximum = Vector3.Zero();\r\n\r\n            const minmax = { minimum, maximum };\r\n\r\n            (this._engine as WebGPUEngine).readFromMultipleStorageBuffers(buffers, 0, undefined, resultData, true).then(() => {\r\n                let resultDataOffset = 0;\r\n                for (let j = 0; j < this._resultBuffers.length; j++) {\r\n                    for (let i = 0; i < this._processedMeshes.length; i++) {\r\n                        const mesh = this._processedMeshes[i];\r\n\r\n                        Vector3.FromArrayToRef(resultData, resultDataOffset + i * 8, minimum);\r\n                        Vector3.FromArrayToRef(resultData, resultDataOffset + i * 8 + 3, maximum);\r\n\r\n                        if (j > 0) {\r\n                            minimum.minimizeInPlace(mesh.getBoundingInfo().minimum);\r\n                            maximum.maximizeInPlace(mesh.getBoundingInfo().maximum);\r\n                        }\r\n\r\n                        mesh._refreshBoundingInfoDirect(minmax);\r\n                    }\r\n\r\n                    resultDataOffset += 8 * this._processedMeshes.length;\r\n                }\r\n\r\n                for (const resultBuffer of this._resultBuffers) {\r\n                    resultBuffer.dispose();\r\n                }\r\n\r\n                this._resultBuffers = [];\r\n                this._uboIndex = 0;\r\n\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    private _disposeCache(storageUnit: { [key: number]: StorageBuffer }) {\r\n        for (const key in storageUnit) {\r\n            storageUnit[key].dispose();\r\n        }\r\n    }\r\n\r\n    private _disposeForMeshList() {\r\n        for (const resultBuffer of this._resultBuffers) {\r\n            resultBuffer.dispose();\r\n        }\r\n        this._resultBuffers = [];\r\n        this._processedMeshes = [];\r\n        this._computeShaders = [];\r\n        this._uniqueComputeShaders = new Set();\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        this._disposeCache(this._positionBuffers);\r\n        this._positionBuffers = {};\r\n        this._disposeCache(this._indexBuffers);\r\n        this._indexBuffers = {};\r\n        this._disposeCache(this._weightBuffers);\r\n        this._weightBuffers = {};\r\n        this._disposeCache(this._morphTargetInfluenceBuffers);\r\n        this._morphTargetInfluenceBuffers = {};\r\n        this._disposeCache(this._morphTargetTextureIndexBuffers);\r\n        this._morphTargetTextureIndexBuffers = {};\r\n        for (const ubo of this._ubos) {\r\n            ubo.dispose();\r\n        }\r\n        this._ubos = [];\r\n        this._computeShadersCache = {};\r\n        this._engine = undefined!;\r\n        this._disposeForMeshList();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["name", "name"]
}
