{
  "version": 3,
  "sources": ["../../../dev/proceduralTextures/src/brick/brickProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/brick/brickProceduralTexture.ts", "../../../dev/proceduralTextures/src/cloud/cloudProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/cloud/cloudProceduralTexture.ts", "../../../dev/proceduralTextures/src/fire/fireProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/fire/fireProceduralTexture.ts", "../../../dev/proceduralTextures/src/grass/grassProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/grass/grassProceduralTexture.ts", "../../../dev/proceduralTextures/src/marble/marbleProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/marble/marbleProceduralTexture.ts", "../../../dev/proceduralTextures/src/normalMap/normalMapProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/normalMap/normalMapProceduralTexture.ts", "../../../dev/proceduralTextures/src/perlinNoise/perlinNoiseProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/perlinNoise/perlinNoiseProceduralTexture.ts", "../../../dev/proceduralTextures/src/road/roadProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/road/roadProceduralTexture.ts", "../../../dev/proceduralTextures/src/starfield/starfieldProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/starfield/starfieldProceduralTexture.ts", "../../../dev/proceduralTextures/src/wood/woodProceduralTexture.fragment.ts", "../../../dev/proceduralTextures/src/wood/woodProceduralTexture.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"brickProceduralTexturePixelShader\";\nconst shader = `precision highp float;varying vec2 vPosition;varying vec2 vUV;uniform float numberOfBricksHeight;uniform float numberOfBricksWidth;uniform vec3 brickColor;uniform vec3 jointColor;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}\nfloat noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}\nfloat fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}\nreturn total;}\nfloat roundF(float number){return sign(number)*floor(abs(number)+0.5);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{float brickW=1.0/numberOfBricksWidth;float brickH=1.0/numberOfBricksHeight;float jointWPercentage=0.01;float jointHPercentage=0.05;vec3 color=brickColor;float yi=vUV.y/brickH;float nyi=roundF(yi);float xi=vUV.x/brickW;if (mod(floor(yi),2.0)==0.0){xi=xi-0.5;}\nfloat nxi=roundF(xi);vec2 brickvUV=vec2((xi-floor(xi))/brickH,(yi-floor(yi))/ brickW);if (yi<nyi+jointHPercentage && yi>nyi-jointHPercentage){color=mix(jointColor,vec3(0.37,0.25,0.25),(yi-nyi)/jointHPercentage+0.2);}\nelse if (xi<nxi+jointWPercentage && xi>nxi-jointWPercentage){color=mix(jointColor,vec3(0.44,0.44,0.44),(xi-nxi)/jointWPercentage+0.2);}\nelse {float brickColorSwitch=mod(floor(yi)+floor(xi),3.0);if (brickColorSwitch==0.0)\ncolor=mix(color,vec3(0.33,0.33,0.33),0.3);else if (brickColorSwitch==2.0)\ncolor=mix(color,vec3(0.11,0.11,0.11),0.3);}\ngl_FragColor=vec4(color,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const brickProceduralTexturePixelShader = { name, shader };\n", "import { serialize, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport \"./brickProceduralTexture.fragment\";\r\n\r\nexport class BrickProceduralTexture extends ProceduralTexture {\r\n    private _numberOfBricksHeight: number = 15;\r\n    private _numberOfBricksWidth: number = 5;\r\n    private _jointColor = new Color3(0.72, 0.72, 0.72);\r\n    private _brickColor = new Color3(0.77, 0.47, 0.4);\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"brickProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setFloat(\"numberOfBricksHeight\", this._numberOfBricksHeight);\r\n        this.setFloat(\"numberOfBricksWidth\", this._numberOfBricksWidth);\r\n        this.setColor3(\"brickColor\", this._brickColor);\r\n        this.setColor3(\"jointColor\", this._jointColor);\r\n    }\r\n\r\n    @serialize()\r\n    public get numberOfBricksHeight(): number {\r\n        return this._numberOfBricksHeight;\r\n    }\r\n\r\n    public set numberOfBricksHeight(value: number) {\r\n        this._numberOfBricksHeight = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get numberOfBricksWidth(): number {\r\n        return this._numberOfBricksWidth;\r\n    }\r\n\r\n    public set numberOfBricksWidth(value: number) {\r\n        this._numberOfBricksWidth = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serializeAsColor3()\r\n    public get jointColor(): Color3 {\r\n        return this._jointColor;\r\n    }\r\n\r\n    public set jointColor(value: Color3) {\r\n        this._jointColor = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serializeAsColor3()\r\n    public get brickColor(): Color3 {\r\n        return this._brickColor;\r\n    }\r\n\r\n    public set brickColor(value: Color3) {\r\n        this._brickColor = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this brick procedural texture\r\n     * @returns a serialized brick procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.BrickProceduralTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Brick Procedural Texture from parsed brick procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing brick procedural texture information\r\n     * @returns a parsed Brick Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): BrickProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new BrickProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BrickProceduralTexture\", BrickProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"cloudProceduralTexturePixelShader\";\nconst shader = `precision highp float;varying vec2 vUV;uniform vec4 skyColor;uniform vec4 cloudColor;uniform float amplitude;uniform int numOctaves;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}\nfloat noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}\nfloat fbm(vec2 n) {float total=0.0,ampl=amplitude;\n#ifdef WEBGL2\nfor (int i=0; i<numOctaves; i++) {\n#else\nfor (int i=0; i<4; i++) {\n#endif\ntotal+=noise(n)*ampl;n+=n;ampl*=0.5;}\nreturn total;}\nvoid main() {vec2 p=vUV*12.0;vec4 c=mix(skyColor,cloudColor,fbm(p));gl_FragColor=c;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const cloudProceduralTexturePixelShader = { name, shader };\n", "import { serialize, serializeAsColor4 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport \"./cloudProceduralTexture.fragment\";\r\n\r\nexport class CloudProceduralTexture extends ProceduralTexture {\r\n    private _skyColor = new Color4(0.15, 0.68, 1.0, 1.0);\r\n    private _cloudColor = new Color4(1, 1, 1, 1.0);\r\n    private _amplitude = 1;\r\n    private _numOctaves = 4;\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"cloudProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setColor4(\"skyColor\", this._skyColor);\r\n        this.setColor4(\"cloudColor\", this._cloudColor);\r\n        this.setFloat(\"amplitude\", this._amplitude);\r\n        this.setInt(\"numOctaves\", this._numOctaves);\r\n    }\r\n\r\n    @serializeAsColor4()\r\n    public get skyColor(): Color4 {\r\n        return this._skyColor;\r\n    }\r\n\r\n    public set skyColor(value: Color4) {\r\n        this._skyColor = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serializeAsColor4()\r\n    public get cloudColor(): Color4 {\r\n        return this._cloudColor;\r\n    }\r\n\r\n    public set cloudColor(value: Color4) {\r\n        this._cloudColor = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get amplitude(): number {\r\n        return this._amplitude;\r\n    }\r\n\r\n    public set amplitude(value: number) {\r\n        this._amplitude = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get numOctaves(): number {\r\n        return this._numOctaves;\r\n    }\r\n\r\n    public set numOctaves(value: number) {\r\n        this._numOctaves = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this cloud procedural texture\r\n     * @returns a serialized cloud procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.CloudProceduralTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cloud Procedural Texture from parsed cloud procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing cloud procedural texture information\r\n     * @returns a parsed Cloud Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): CloudProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new CloudProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CloudProceduralTexture\", CloudProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"fireProceduralTexturePixelShader\";\nconst shader = `precision highp float;uniform float time;uniform vec3 c1;uniform vec3 c2;uniform vec3 c3;uniform vec3 c4;uniform vec3 c5;uniform vec3 c6;uniform vec2 speed;uniform float shift;uniform float alphaThreshold;varying vec2 vUV;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}\nfloat noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}\nfloat fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}\nreturn total;}\nvoid main() {vec2 p=vUV*8.0;float q=fbm(p-time*0.1);vec2 r=vec2(fbm(p+q+time*speed.x-p.x-p.y),fbm(p+q-time*speed.y));vec3 c=mix(c1,c2,fbm(p+r))+mix(c3,c4,r.x)-mix(c5,c6,r.y);vec3 color=c*cos(shift*vUV.y);float luminance=dot(color.rgb,vec3(0.3,0.59,0.11));gl_FragColor=vec4(color,luminance*alphaThreshold+(1.0-alphaThreshold));}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const fireProceduralTexturePixelShader = { name, shader };\n", "import { serialize, serializeAsVector2 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport \"./fireProceduralTexture.fragment\";\r\n\r\nexport class FireProceduralTexture extends ProceduralTexture {\r\n    private _time: number = 0.0;\r\n    private _speed = new Vector2(0.5, 0.3);\r\n    private _autoGenerateTime: boolean = true;\r\n    private _fireColors: Color3[];\r\n    private _alphaThreshold: number = 0.5;\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"fireProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this._fireColors = FireProceduralTexture.RedFireColors;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setFloat(\"time\", this._time);\r\n        this.setVector2(\"speed\", this._speed);\r\n        this.setColor3(\"c1\", this._fireColors[0]);\r\n        this.setColor3(\"c2\", this._fireColors[1]);\r\n        this.setColor3(\"c3\", this._fireColors[2]);\r\n        this.setColor3(\"c4\", this._fireColors[3]);\r\n        this.setColor3(\"c5\", this._fireColors[4]);\r\n        this.setColor3(\"c6\", this._fireColors[5]);\r\n        this.setFloat(\"alphaThreshold\", this._alphaThreshold);\r\n    }\r\n\r\n    public override render(useCameraPostProcess?: boolean) {\r\n        const scene = this.getScene();\r\n        if (this._autoGenerateTime && scene) {\r\n            this._time += scene.getAnimationRatio() * 0.03;\r\n            this.updateShaderUniforms();\r\n        }\r\n        super.render(useCameraPostProcess);\r\n    }\r\n\r\n    public static get PurpleFireColors(): Color3[] {\r\n        return [new Color3(0.5, 0.0, 1.0), new Color3(0.9, 0.0, 1.0), new Color3(0.2, 0.0, 1.0), new Color3(1.0, 0.9, 1.0), new Color3(0.1, 0.1, 1.0), new Color3(0.9, 0.9, 1.0)];\r\n    }\r\n\r\n    public static get GreenFireColors(): Color3[] {\r\n        return [new Color3(0.5, 1.0, 0.0), new Color3(0.5, 1.0, 0.0), new Color3(0.3, 0.4, 0.0), new Color3(0.5, 1.0, 0.0), new Color3(0.2, 0.0, 0.0), new Color3(0.5, 1.0, 0.0)];\r\n    }\r\n\r\n    public static get RedFireColors(): Color3[] {\r\n        return [new Color3(0.5, 0.0, 0.1), new Color3(0.9, 0.0, 0.0), new Color3(0.2, 0.0, 0.0), new Color3(1.0, 0.9, 0.0), new Color3(0.1, 0.1, 0.1), new Color3(0.9, 0.9, 0.9)];\r\n    }\r\n\r\n    public static get BlueFireColors(): Color3[] {\r\n        return [new Color3(0.1, 0.0, 0.5), new Color3(0.0, 0.0, 0.5), new Color3(0.1, 0.0, 0.2), new Color3(0.0, 0.0, 1.0), new Color3(0.1, 0.2, 0.3), new Color3(0.0, 0.2, 0.9)];\r\n    }\r\n\r\n    @serialize()\r\n    public get autoGenerateTime(): boolean {\r\n        return this._autoGenerateTime;\r\n    }\r\n\r\n    public set autoGenerateTime(value: boolean) {\r\n        this._autoGenerateTime = value;\r\n    }\r\n\r\n    public get fireColors(): Color3[] {\r\n        return this._fireColors;\r\n    }\r\n\r\n    public set fireColors(value: Color3[]) {\r\n        this._fireColors = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get time(): number {\r\n        return this._time;\r\n    }\r\n\r\n    public set time(value: number) {\r\n        this._time = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serializeAsVector2()\r\n    public get speed(): Vector2 {\r\n        return this._speed;\r\n    }\r\n\r\n    public set speed(value: Vector2) {\r\n        this._speed = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get alphaThreshold(): number {\r\n        return this._alphaThreshold;\r\n    }\r\n\r\n    public set alphaThreshold(value: number) {\r\n        this._alphaThreshold = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this fire procedural texture\r\n     * @returns a serialized fire procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.FireProceduralTexture\";\r\n\r\n        serializationObject.fireColors = [];\r\n        for (let i = 0; i < this._fireColors.length; i++) {\r\n            serializationObject.fireColors.push(this._fireColors[i].asArray());\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Fire Procedural Texture from parsed fire procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing fire procedural texture information\r\n     * @returns a parsed Fire Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): FireProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new FireProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        const colors: Color3[] = [];\r\n        for (let i = 0; i < parsedTexture.fireColors.length; i++) {\r\n            colors.push(Color3.FromArray(parsedTexture.fireColors[i]));\r\n        }\r\n\r\n        texture.fireColors = colors;\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FireProceduralTexture\", FireProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"grassProceduralTexturePixelShader\";\nconst shader = `precision highp float;varying vec2 vPosition;varying vec2 vUV;uniform vec3 herb1Color;uniform vec3 herb2Color;uniform vec3 herb3Color;uniform vec3 groundColor;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}\nfloat noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}\nfloat fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}\nreturn total;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec3 color=mix(groundColor,herb1Color,rand(gl_FragCoord.xy*4.0));color=mix(color,herb2Color,rand(gl_FragCoord.xy*8.0));color=mix(color,herb3Color,rand(gl_FragCoord.xy));color=mix(color,herb1Color,fbm(gl_FragCoord.xy*16.0));gl_FragColor=vec4(color,1.0);\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const grassProceduralTexturePixelShader = { name, shader };\n", "import { serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport \"./grassProceduralTexture.fragment\";\r\n\r\nexport class GrassProceduralTexture extends ProceduralTexture {\r\n    private _grassColors: Color3[];\r\n    private _groundColor = new Color3(1, 1, 1);\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"grassProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n\r\n        this._grassColors = [new Color3(0.29, 0.38, 0.02), new Color3(0.36, 0.49, 0.09), new Color3(0.51, 0.6, 0.28)];\r\n\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setColor3(\"herb1Color\", this._grassColors[0]);\r\n        this.setColor3(\"herb2Color\", this._grassColors[1]);\r\n        this.setColor3(\"herb3Color\", this._grassColors[2]);\r\n        this.setColor3(\"groundColor\", this._groundColor);\r\n    }\r\n\r\n    public get grassColors(): Color3[] {\r\n        return this._grassColors;\r\n    }\r\n\r\n    public set grassColors(value: Color3[]) {\r\n        this._grassColors = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serializeAsColor3()\r\n    public get groundColor(): Color3 {\r\n        return this._groundColor;\r\n    }\r\n\r\n    public set groundColor(value: Color3) {\r\n        this._groundColor = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this grass procedural texture\r\n     * @returns a serialized grass procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.GrassProceduralTexture\";\r\n\r\n        serializationObject.grassColors = [];\r\n        for (let i = 0; i < this._grassColors.length; i++) {\r\n            serializationObject.grassColors.push(this._grassColors[i].asArray());\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Grass Procedural Texture from parsed grass procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing grass procedural texture information\r\n     * @returns a parsed Grass Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): GrassProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new GrassProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        const colors: Color3[] = [];\r\n        for (let i = 0; i < parsedTexture.grassColors.length; i++) {\r\n            colors.push(Color3.FromArray(parsedTexture.grassColors[i]));\r\n        }\r\n\r\n        texture.grassColors = colors;\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GrassProceduralTexture\", GrassProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"marbleProceduralTexturePixelShader\";\nconst shader = `precision highp float;varying vec2 vPosition;varying vec2 vUV;uniform float numberOfTilesHeight;uniform float numberOfTilesWidth;uniform float amplitude;uniform vec3 marbleColor;uniform vec3 jointColor;const vec3 tileSize=vec3(1.1,1.0,1.1);const vec3 tilePct=vec3(0.98,1.0,0.98);float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}\nfloat noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}\nfloat turbulence(vec2 P)\n{float val=0.0;float freq=1.0;for (int i=0; i<4; i++)\n{val+=abs(noise(P*freq)/freq);freq*=2.07;}\nreturn val;}\nfloat roundF(float number){return sign(number)*floor(abs(number)+0.5);}\nvec3 marble_color(float x)\n{vec3 col;x=0.5*(x+1.);x=sqrt(x); \nx=sqrt(x);x=sqrt(x);col=vec3(.2+.75*x); \ncol.b*=0.95; \nreturn col;}\nvoid main()\n{float brickW=1.0/numberOfTilesWidth;float brickH=1.0/numberOfTilesHeight;float jointWPercentage=0.01;float jointHPercentage=0.01;vec3 color=marbleColor;float yi=vUV.y/brickH;float nyi=roundF(yi);float xi=vUV.x/brickW;if (mod(floor(yi),2.0)==0.0){xi=xi-0.5;}\nfloat nxi=roundF(xi);vec2 brickvUV=vec2((xi-floor(xi))/brickH,(yi-floor(yi))/brickW);if (yi<nyi+jointHPercentage && yi>nyi-jointHPercentage){color=mix(jointColor,vec3(0.37,0.25,0.25),(yi-nyi)/jointHPercentage+0.2);}\nelse if (xi<nxi+jointWPercentage && xi>nxi-jointWPercentage){color=mix(jointColor,vec3(0.44,0.44,0.44),(xi-nxi)/jointWPercentage+0.2);}\nelse {float t=6.28*brickvUV.x/(tileSize.x+noise(vec2(vUV)*6.0));t+=amplitude*turbulence(brickvUV.xy);t=sin(t);color=marble_color(t);}\ngl_FragColor=vec4(color,0.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const marbleProceduralTexturePixelShader = { name, shader };\n", "import { serialize } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport \"./marbleProceduralTexture.fragment\";\r\n\r\nexport class MarbleProceduralTexture extends ProceduralTexture {\r\n    private _numberOfTilesHeight: number = 3;\r\n    private _numberOfTilesWidth: number = 3;\r\n    private _amplitude: number = 9.0;\r\n    private _jointColor = new Color3(0.72, 0.72, 0.72);\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"marbleProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setFloat(\"numberOfTilesHeight\", this._numberOfTilesHeight);\r\n        this.setFloat(\"numberOfTilesWidth\", this._numberOfTilesWidth);\r\n        this.setFloat(\"amplitude\", this._amplitude);\r\n        this.setColor3(\"jointColor\", this._jointColor);\r\n    }\r\n\r\n    @serialize()\r\n    public get numberOfTilesHeight(): number {\r\n        return this._numberOfTilesHeight;\r\n    }\r\n\r\n    public set numberOfTilesHeight(value: number) {\r\n        this._numberOfTilesHeight = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get amplitude(): number {\r\n        return this._amplitude;\r\n    }\r\n\r\n    public set amplitude(value: number) {\r\n        this._amplitude = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get numberOfTilesWidth(): number {\r\n        return this._numberOfTilesWidth;\r\n    }\r\n\r\n    public set numberOfTilesWidth(value: number) {\r\n        this._numberOfTilesWidth = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get jointColor(): Color3 {\r\n        return this._jointColor;\r\n    }\r\n\r\n    public set jointColor(value: Color3) {\r\n        this._jointColor = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this marble procedural texture\r\n     * @returns a serialized marble procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.MarbleProceduralTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Marble Procedural Texture from parsed marble procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing marble procedural texture information\r\n     * @returns a parsed Marble Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): MarbleProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new MarbleProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MarbleProceduralTexture\", MarbleProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"normalMapProceduralTexturePixelShader\";\nconst shader = `precision highp float;uniform sampler2D baseSampler;uniform float size;varying vec2 vUV;const vec3 LUMA_COEFFICIENT=vec3(0.2126,0.7152,0.0722);float lumaAtCoord(vec2 coord)\n{vec3 pixel=texture2D(baseSampler,coord).rgb;float luma=dot(pixel,LUMA_COEFFICIENT);return luma;}\nvoid main()\n{float lumaU0=lumaAtCoord(vUV+vec2(-1.0, 0.0)/size);float lumaU1=lumaAtCoord(vUV+vec2( 1.0, 0.0)/size);float lumaV0=lumaAtCoord(vUV+vec2( 0.0,-1.0)/size);float lumaV1=lumaAtCoord(vUV+vec2( 0.0, 1.0)/size);vec2 slope=(vec2(lumaU0-lumaU1,lumaV0-lumaV1)+1.0)*0.5;gl_FragColor=vec4(slope,1.0,1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const normalMapProceduralTexturePixelShader = { name, shader };\n", "import { serializeAsTexture } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\nimport \"./normalMapProceduralTexture.fragment\";\r\n\r\nexport class NormalMapProceduralTexture extends ProceduralTexture {\r\n    private _baseTexture: Texture;\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"normalMapProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setTexture(\"baseSampler\", this._baseTexture);\r\n        this.setFloat(\"size\", this.getRenderSize() as number);\r\n    }\r\n\r\n    public override render(useCameraPostProcess?: boolean) {\r\n        super.render(useCameraPostProcess);\r\n    }\r\n\r\n    public override resize(size: any, generateMipMaps: any): void {\r\n        super.resize(size, generateMipMaps);\r\n\r\n        // We need to update the \"size\" uniform\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public override isReady(): boolean {\r\n        if (!this._baseTexture || !this._baseTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    @serializeAsTexture()\r\n    public get baseTexture(): Texture {\r\n        return this._baseTexture;\r\n    }\r\n\r\n    public set baseTexture(texture: Texture) {\r\n        this._baseTexture = texture;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this normal map procedural texture\r\n     * @returns a serialized normal map procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.NormalMapProceduralTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Normal Map Procedural Texture from parsed normal map procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing normal map procedural texture information\r\n     * @returns a parsed Normal Map Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): NormalMapProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new NormalMapProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NormalMapProceduralTexture\", NormalMapProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"perlinNoiseProceduralTexturePixelShader\";\nconst shader = `precision highp float;uniform float size;uniform float time;uniform float translationSpeed;varying vec2 vUV;float r(float n)\n{return fract(cos(n*89.42)*343.42);}\nvec2 r(vec2 n)\n{return vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); }\nfloat worley(vec2 n,float s)\n{float dis=1.0;for(int x=-1; x<=1; x++)\n{for(int y=-1; y<=1; y++)\n{vec2 p=floor(n/s)+vec2(x,y);float d=length(r(p)+vec2(x,y)-fract(n/s));if (dis>d)\ndis=d;}}\nreturn 1.0-dis;}\nvec3 hash33(vec3 p3)\n{p3=fract(p3*vec3(0.1031,0.11369,0.13787));p3+=dot(p3,p3.yxz+19.19);return -1.0+2.0*fract(vec3((p3.x+p3.y)*p3.z,(p3.x+p3.z)*p3.y,(p3.y+p3.z)*p3.x));}\nfloat perlinNoise(vec3 p)\n{vec3 pi=floor(p);vec3 pf=p-pi;vec3 w=pf*pf*(3.0-2.0*pf);return mix(\nmix(\nmix(\ndot(pf-vec3(0,0,0),hash33(pi+vec3(0,0,0))),\ndot(pf-vec3(1,0,0),hash33(pi+vec3(1,0,0))),\nw.x\n),\nmix(\ndot(pf-vec3(0,0,1),hash33(pi+vec3(0,0,1))),\ndot(pf-vec3(1,0,1),hash33(pi+vec3(1,0,1))),\nw.x\n),\nw.z\n),\nmix(\nmix(\ndot(pf-vec3(0,1,0),hash33(pi+vec3(0,1,0))),\ndot(pf-vec3(1,1,0),hash33(pi+vec3(1,1,0))),\nw.x\n),\nmix(\ndot(pf-vec3(0,1,1),hash33(pi+vec3(0,1,1))),\ndot(pf-vec3(1,1,1),hash33(pi+vec3(1,1,1))),\nw.x\n),\nw.z\n),\nw.y\n);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec2 uv=gl_FragCoord.xy+translationSpeed;float dis=(\n1.0+perlinNoise(vec3(uv/vec2(size,size),time*0.05)*8.0))\n* (1.0+(worley(uv,32.0)+ 0.5*worley(2.0*uv,32.0)+0.25*worley(4.0*uv,32.0))\n);gl_FragColor=vec4(vec3(dis/4.0),1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const perlinNoiseProceduralTexturePixelShader = { name, shader };\n", "import { serialize } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\nimport \"./perlinNoiseProceduralTexture.fragment\";\r\n\r\nexport class PerlinNoiseProceduralTexture extends ProceduralTexture {\r\n    @serialize()\r\n    public time: number = 0.0;\r\n\r\n    @serialize()\r\n    public timeScale: number = 1.0;\r\n\r\n    @serialize()\r\n    public translationSpeed: number = 1.0;\r\n\r\n    private _currentTranslation: number = 0;\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"perlinNoiseProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setFloat(\"size\", this.getRenderSize() as number);\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const deltaTime = scene.getEngine().getDeltaTime();\r\n\r\n        this.time += deltaTime;\r\n        this.setFloat(\"time\", (this.time * this.timeScale) / 1000);\r\n\r\n        this._currentTranslation += (deltaTime * this.translationSpeed) / 1000.0;\r\n        this.setFloat(\"translationSpeed\", this._currentTranslation);\r\n    }\r\n\r\n    public override render(useCameraPostProcess?: boolean) {\r\n        this.updateShaderUniforms();\r\n        super.render(useCameraPostProcess);\r\n    }\r\n\r\n    public override resize(size: any, generateMipMaps: any): void {\r\n        super.resize(size, generateMipMaps);\r\n    }\r\n\r\n    /**\r\n     * Serializes this perlin noise procedural texture\r\n     * @returns a serialized perlin noise procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.PerlinNoiseProceduralTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Perlin Noise Procedural Texture from parsed perlin noise procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing perlin noise procedural texture information\r\n     * @returns a parsed Perlin Noise Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): PerlinNoiseProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new PerlinNoiseProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PerlinNoiseProceduralTexture\", PerlinNoiseProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"roadProceduralTexturePixelShader\";\nconst shader = `precision highp float;varying vec2 vUV; \nuniform vec3 roadColor;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}\nfloat noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}\nfloat fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}\nreturn total;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfloat ratioy=mod(gl_FragCoord.y*100.0 ,fbm(vUV*2.0));vec3 color=roadColor*ratioy;gl_FragColor=vec4(color,1.0);\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const roadProceduralTexturePixelShader = { name, shader };\n", "import { serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\nimport \"./roadProceduralTexture.fragment\";\r\n\r\nexport class RoadProceduralTexture extends ProceduralTexture {\r\n    private _roadColor = new Color3(0.53, 0.53, 0.53);\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"roadProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setColor3(\"roadColor\", this._roadColor);\r\n    }\r\n\r\n    @serializeAsColor3()\r\n    public get roadColor(): Color3 {\r\n        return this._roadColor;\r\n    }\r\n\r\n    public set roadColor(value: Color3) {\r\n        this._roadColor = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this road procedural texture\r\n     * @returns a serialized road procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.RoadProceduralTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Road Procedural Texture from parsed road procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing road procedural texture information\r\n     * @returns a parsed Road Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): RoadProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new RoadProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RoadProceduralTexture\", RoadProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"starfieldProceduralTexturePixelShader\";\nconst shader = `precision highp float;\n#define volsteps 20\n#define iterations 15\nvarying vec2 vPosition;varying vec2 vUV;uniform float time;uniform float alpha;uniform float beta;uniform float zoom;uniform float formuparam;uniform float stepsize;uniform float tile;uniform float brightness;uniform float darkmatter;uniform float distfading;uniform float saturation;void main()\n{vec3 dir=vec3(vUV*zoom,1.);float localTime=time*0.0001;mat2 rot1=mat2(cos(alpha),sin(alpha),-sin(alpha),cos(alpha));mat2 rot2=mat2(cos(beta),sin(beta),-sin(beta),cos(beta));dir.xz*=rot1;dir.xy*=rot2;vec3 from_=vec3(1.,.5,0.5);from_+=vec3(-2.,localTime*2.,localTime);from_.xz*=rot1;from_.xy*=rot2;float s=0.1,fade=1.;vec3 v=vec3(0.);for (int r=0; r<volsteps; r++) {vec3 p=from_+s*dir*.5;p=abs(vec3(tile)-mod(p,vec3(tile*2.))); \nfloat pa,a=pa=0.;for (int i=0; i<iterations; i++) {p=abs(p)/dot(p,p)-formuparam; \na+=abs(length(p)-pa); \npa=length(p);}\nfloat dm=max(0.,darkmatter-a*a*.001); \na*=a*a; \nif (r>6) fade*=1.-dm; \nv+=fade;v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; \nfade*=distfading; \ns+=stepsize;}\nv=mix(vec3(length(v)),v,saturation); \ngl_FragColor=vec4(v*.01,1.);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const starfieldProceduralTexturePixelShader = { name, shader };\n", "import { serialize } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\nimport \"./starfieldProceduralTexture.fragment\";\r\n\r\nexport class StarfieldProceduralTexture extends ProceduralTexture {\r\n    private _time = 1;\r\n    private _alpha = 0.5;\r\n    private _beta = 0.8;\r\n    private _zoom = 0.8;\r\n    private _formuparam = 0.53;\r\n    private _stepsize = 0.1;\r\n    private _tile = 0.85;\r\n    private _brightness = 0.0015;\r\n    private _darkmatter = 0.4;\r\n    private _distfading = 0.73;\r\n    private _saturation = 0.85;\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"starfieldProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setFloat(\"time\", this._time);\r\n        this.setFloat(\"alpha\", this._alpha);\r\n        this.setFloat(\"beta\", this._beta);\r\n        this.setFloat(\"zoom\", this._zoom);\r\n        this.setFloat(\"formuparam\", this._formuparam);\r\n        this.setFloat(\"stepsize\", this._stepsize);\r\n        this.setFloat(\"tile\", this._tile);\r\n        this.setFloat(\"brightness\", this._brightness);\r\n        this.setFloat(\"darkmatter\", this._darkmatter);\r\n        this.setFloat(\"distfading\", this._distfading);\r\n        this.setFloat(\"saturation\", this._saturation);\r\n    }\r\n\r\n    @serialize()\r\n    public get time(): number {\r\n        return this._time;\r\n    }\r\n\r\n    public set time(value: number) {\r\n        this._time = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    public set alpha(value: number) {\r\n        this._alpha = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get beta(): number {\r\n        return this._beta;\r\n    }\r\n\r\n    public set beta(value: number) {\r\n        this._beta = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get formuparam(): number {\r\n        return this._formuparam;\r\n    }\r\n\r\n    public set formuparam(value: number) {\r\n        this._formuparam = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get stepsize(): number {\r\n        return this._stepsize;\r\n    }\r\n\r\n    public set stepsize(value: number) {\r\n        this._stepsize = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get zoom(): number {\r\n        return this._zoom;\r\n    }\r\n\r\n    public set zoom(value: number) {\r\n        this._zoom = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get tile(): number {\r\n        return this._tile;\r\n    }\r\n\r\n    public set tile(value: number) {\r\n        this._tile = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get brightness(): number {\r\n        return this._brightness;\r\n    }\r\n\r\n    public set brightness(value: number) {\r\n        this._brightness = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get darkmatter(): number {\r\n        return this._darkmatter;\r\n    }\r\n\r\n    public set darkmatter(value: number) {\r\n        this._darkmatter = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get distfading(): number {\r\n        return this._distfading;\r\n    }\r\n\r\n    public set distfading(value: number) {\r\n        this._distfading = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serialize()\r\n    public get saturation(): number {\r\n        return this._saturation;\r\n    }\r\n\r\n    public set saturation(value: number) {\r\n        this._saturation = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this starfield procedural texture\r\n     * @returns a serialized starfield procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.StarfieldProceduralTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Starfield Procedural Texture from parsed startfield procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing startfield procedural texture information\r\n     * @returns a parsed Starfield Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): StarfieldProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new StarfieldProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.StarfieldProceduralTexture\", StarfieldProceduralTexture);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"woodProceduralTexturePixelShader\";\nconst shader = `precision highp float;varying vec2 vPosition;varying vec2 vUV;uniform float ampScale;uniform vec3 woodColor;float rand(vec2 n) {return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);}\nfloat noise(vec2 n) {const vec2 d=vec2(0.0,1.0);vec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));return mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);}\nfloat fbm(vec2 n) {float total=0.0,amplitude=1.0;for (int i=0; i<4; i++) {total+=noise(n)*amplitude;n+=n;amplitude*=0.5;}\nreturn total;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfloat ratioy=mod(vUV.x*ampScale,2.0+fbm(vUV*0.8));vec3 wood=woodColor*ratioy;gl_FragColor=vec4(wood,1.0);\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const woodProceduralTexturePixelShader = { name, shader };\n", "import { serialize, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\nimport \"./woodProceduralTexture.fragment\";\r\n\r\nexport class WoodProceduralTexture extends ProceduralTexture {\r\n    private _ampScale: number = 100.0;\r\n    private _woodColor: Color3 = new Color3(0.32, 0.17, 0.09);\r\n\r\n    constructor(name: string, size: number, scene: Nullable<Scene> = null, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"woodProceduralTexture\", scene, fallbackTexture, generateMipMaps);\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    public updateShaderUniforms() {\r\n        this.setFloat(\"ampScale\", this._ampScale);\r\n        this.setColor3(\"woodColor\", this._woodColor);\r\n    }\r\n\r\n    @serialize()\r\n    public get ampScale(): number {\r\n        return this._ampScale;\r\n    }\r\n\r\n    public set ampScale(value: number) {\r\n        this._ampScale = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    @serializeAsColor3()\r\n    public get woodColor(): Color3 {\r\n        return this._woodColor;\r\n    }\r\n\r\n    public set woodColor(value: Color3) {\r\n        this._woodColor = value;\r\n        this.updateShaderUniforms();\r\n    }\r\n\r\n    /**\r\n     * Serializes this wood procedural texture\r\n     * @returns a serialized wood procedural texture object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, super.serialize());\r\n        serializationObject.customType = \"BABYLON.WoodProceduralTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Wood Procedural Texture from parsed wood procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing wood procedural texture information\r\n     * @returns a parsed Wood Procedural Texture\r\n     */\r\n    public static override Parse(parsedTexture: any, scene: Scene, rootUrl: string): WoodProceduralTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => new WoodProceduralTexture(parsedTexture.name, parsedTexture._size, scene, undefined, parsedTexture._generateMipMaps),\r\n            parsedTexture,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.WoodProceduralTexture\", WoodProceduralTexture);\r\n"],
  "mappings": "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",
  "names": ["name", "name", "shader", "name", "name", "shader", "name", "name", "shader", "name", "name", "shader", "name", "name", "shader", "name", "name", "shader", "name", "name", "shader", "name", "name", "shader", "name", "name", "shader", "name"]
}
