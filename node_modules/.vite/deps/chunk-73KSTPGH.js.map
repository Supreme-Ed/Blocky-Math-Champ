{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/flowGraphLogger.ts", "../../../dev/core/src/FlowGraph/flowGraphContext.ts", "../../../dev/core/src/FlowGraph/flowGraphSceneEventCoordinator.ts", "../../../dev/core/src/FlowGraph/flowGraph.ts", "../../../dev/core/src/FlowGraph/flowGraphCoordinator.ts"],
  "sourcesContent": ["import { Logger } from \"core/Misc/logger\";\n\nexport const enum FlowGraphAction {\n    ExecuteBlock = \"ExecuteBlock\",\n    ExecuteEvent = \"ExecuteEvent\",\n    TriggerConnection = \"TriggerConnection\",\n    ContextVariableSet = \"ContextVariableSet\",\n    GlobalVariableSet = \"GlobalVariableSet\",\n    GlobalVariableDelete = \"GlobalVariableDelete\",\n    GlobalVariableGet = \"GlobalVariableGet\",\n    AddConnection = \"AddConnection\",\n    GetConnectionValue = \"GetConnectionValue\",\n    SetConnectionValue = \"SetConnectionValue\",\n    ActivateSignal = \"ActivateSignal\",\n    ContextVariableGet = \"ContextVariableGet\",\n}\n\n/**\n * An item in the flow graph log.\n */\nexport interface IFlowGraphLogItem {\n    /**\n     * The time of the log item.\n     */\n    time?: number;\n    /**\n     * The class that triggered the log.\n     */\n    className: string;\n    /**\n     * The unique id of the block/module that triggered the log.\n     */\n    uniqueId: string;\n    /**\n     * The action that was logged.\n     */\n    action: FlowGraphAction;\n    /**\n     * The payload of the log\n     * This can be any data that is relevant to the action.\n     * For example, the value of a connection, the value of a variable, etc.\n     * This is optional.\n     */\n    payload?: any;\n}\n\n/**\n * This class will be responsible of logging the flow graph activity.\n * Note that using this class might reduce performance, as it will log every action, according to the configuration.\n * It attaches to a flow graph and uses meta-programming to replace the methods of the flow graph to add logging abilities.\n */\nexport class FlowGraphLogger {\n    /**\n     * Whether to log to the console.\n     */\n    public logToConsole: boolean = false;\n\n    /**\n     * The log cache of the flow graph.\n     * Each item is a logged item, in order of execution.\n     */\n    public log: IFlowGraphLogItem[] = [];\n\n    public addLogItem(item: IFlowGraphLogItem) {\n        if (!item.time) {\n            item.time = Date.now();\n        }\n        this.log.push(item);\n        if (this.logToConsole) {\n            const value = item.payload?.value;\n            if (typeof value === \"object\" && value.getClassName) {\n                Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split(\"-\")[0]} ${item.action} - ${JSON.stringify(value.getClassName())}: ${value.toString()}`);\n            } else {\n                Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split(\"-\")[0]} ${item.action} - ${JSON.stringify(item.payload)}`);\n            }\n        }\n    }\n\n    public getItemsOfType(action: FlowGraphAction): IFlowGraphLogItem[] {\n        return this.log.filter((i) => i.action === action);\n    }\n}\n", "import { serialize } from \"../Misc/decorators\";\r\nimport { RandomGUID } from \"../Misc/guid\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { FlowGraphAsyncExecutionBlock } from \"./flowGraphAsyncExecutionBlock\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\nimport type { FlowGraph } from \"./flowGraph\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { AssetType, FlowGraphAssetType } from \"./flowGraphAssetsContext\";\r\nimport { GetFlowGraphAssetWithType } from \"./flowGraphAssetsContext\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { FlowGraphAction, FlowGraphLogger } from \"./flowGraphLogger\";\r\nimport type { IFlowGraphOnTickEventPayload } from \"./Blocks/Event/flowGraphSceneTickEventBlock\";\r\n\r\n/**\r\n * Construction parameters for the context.\r\n */\r\nexport interface IFlowGraphContextConfiguration {\r\n    /**\r\n     * The scene that the flow graph context belongs to.\r\n     */\r\n    readonly scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph context.\r\n     */\r\n    readonly coordinator: FlowGraphCoordinator;\r\n\r\n    /**\r\n     * The assets context used by the flow graph context.\r\n     * If none is provided, a default one will be created.\r\n     */\r\n    readonly assetsContext?: IAssetContainer;\r\n}\r\n\r\n/**\r\n * Options for parsing a context.\r\n */\r\nexport interface IFlowGraphContextParseOptions {\r\n    /**\r\n     * A function that parses a value from a serialization object.\r\n     * @param key the key of the value\r\n     * @param serializationObject the object containing the value\r\n     * @param scene the current scene\r\n     * @returns\r\n     */\r\n    readonly valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The graph that the context is being parsed in.\r\n     */\r\n    readonly graph: FlowGraph;\r\n}\r\n/**\r\n * The context represents the current state and execution of the flow graph.\r\n * It contains both user-defined variables, which are derived from\r\n * a more general variable definition, and execution variables that\r\n * are set by the blocks.\r\n */\r\nexport class FlowGraphContext {\r\n    /**\r\n     * A randomly generated GUID for each context.\r\n     */\r\n    @serialize()\r\n    public uniqueId = RandomGUID();\r\n    /**\r\n     * These are the variables defined by a user.\r\n     */\r\n    private _userVariables: { [key: string]: any } = {};\r\n    /**\r\n     * These are the variables set by the blocks.\r\n     */\r\n    private _executionVariables: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * A context-specific global variables, available to all blocks in the context.\r\n     */\r\n    private _globalContextVariables: { [key: string]: any } = {};\r\n    /**\r\n     * These are the values for the data connection points\r\n     */\r\n    private _connectionValues: { [key: string]: any } = {};\r\n    /**\r\n     * These are the variables set by the graph.\r\n     */\r\n    private readonly _configuration: IFlowGraphContextConfiguration;\r\n    /**\r\n     * These are blocks that have currently pending tasks/listeners that need to be cleaned up.\r\n     */\r\n    private _pendingBlocks: FlowGraphAsyncExecutionBlock[] = [];\r\n    /**\r\n     * A monotonically increasing ID for each execution.\r\n     * Incremented for every block executed.\r\n     */\r\n    private _executionId = 0;\r\n    /**\r\n     * Observable that is triggered when a node is executed.\r\n     */\r\n    public onNodeExecutedObservable: Observable<FlowGraphBlock> = new Observable<FlowGraphBlock>();\r\n\r\n    /**\r\n     * The assets context used by the flow graph context.\r\n     * Note that it can be shared between flow graph contexts.\r\n     */\r\n    public assetsContext: IAssetContainer;\r\n\r\n    /**\r\n     * Whether to treat data as right-handed.\r\n     * This is used when serializing data from a right-handed system, while running the context in a left-handed system, for example in glTF parsing.\r\n     * Default is false.\r\n     */\r\n    public treatDataAsRightHanded = false;\r\n\r\n    private _enableLogging = false;\r\n\r\n    /**\r\n     * The logger used by the context to log actions.\r\n     */\r\n    public logger: Nullable<FlowGraphLogger>;\r\n\r\n    /**\r\n     * Enable logging on this context\r\n     */\r\n    public get enableLogging() {\r\n        return this._enableLogging;\r\n    }\r\n\r\n    public set enableLogging(value: boolean) {\r\n        if (this._enableLogging === value) {\r\n            return;\r\n        }\r\n        this._enableLogging = value;\r\n        if (this._enableLogging) {\r\n            this.logger = new FlowGraphLogger();\r\n            this.logger.logToConsole = true;\r\n        } else {\r\n            this.logger = null;\r\n        }\r\n    }\r\n\r\n    constructor(params: IFlowGraphContextConfiguration) {\r\n        this._configuration = params;\r\n        this.assetsContext = params.assetsContext ?? params.scene;\r\n    }\r\n\r\n    /**\r\n     * Check if a user-defined variable is defined.\r\n     * @param name the name of the variable\r\n     * @returns true if the variable is defined\r\n     */\r\n    public hasVariable(name: string) {\r\n        return name in this._userVariables;\r\n    }\r\n\r\n    /**\r\n     * Set a user-defined variable.\r\n     * @param name the name of the variable\r\n     * @param value the value of the variable\r\n     */\r\n    public setVariable(name: string, value: any) {\r\n        this._userVariables[name] = value;\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.ContextVariableSet,\r\n            payload: {\r\n                name,\r\n                value,\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get an assets from the assets context based on its type and index in the array\r\n     * @param type The type of the asset\r\n     * @param index The index of the asset\r\n     * @returns The asset or null if not found\r\n     */\r\n    public getAsset<T extends FlowGraphAssetType>(type: T, index: number): Nullable<AssetType<T>> {\r\n        return GetFlowGraphAssetWithType(this.assetsContext, type, index);\r\n    }\r\n\r\n    /**\r\n     * Get a user-defined variable.\r\n     * @param name the name of the variable\r\n     * @returns the value of the variable\r\n     */\r\n    public getVariable(name: string): any {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.ContextVariableGet,\r\n            payload: {\r\n                name,\r\n                value: this._userVariables[name],\r\n            },\r\n        });\r\n        return this._userVariables[name];\r\n    }\r\n\r\n    /**\r\n     * Gets all user variables map\r\n     */\r\n    public get userVariables() {\r\n        return this._userVariables;\r\n    }\r\n\r\n    /**\r\n     * Get the scene that the context belongs to.\r\n     * @returns the scene\r\n     */\r\n    public getScene() {\r\n        return this._configuration.scene;\r\n    }\r\n\r\n    private _getUniqueIdPrefixedName(obj: FlowGraphBlock, name: string): string {\r\n        return `${obj.uniqueId}_${name}`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param name name of the variable\r\n     * @param defaultValue default value to return if the variable is not defined\r\n     * @returns the variable value or the default value if the variable is not defined\r\n     */\r\n    public _getGlobalContextVariable<T>(name: string, defaultValue: T): T {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableGet,\r\n            payload: {\r\n                name,\r\n                defaultValue,\r\n                possibleValue: this._globalContextVariables[name],\r\n            },\r\n        });\r\n        if (this._hasGlobalContextVariable(name)) {\r\n            return this._globalContextVariables[name];\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a global context variable\r\n     * @internal\r\n     * @param name the name of the variable\r\n     * @param value the value of the variable\r\n     */\r\n    public _setGlobalContextVariable<T>(name: string, value: T) {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableSet,\r\n            payload: { name, value },\r\n        });\r\n        this._globalContextVariables[name] = value;\r\n    }\r\n\r\n    /**\r\n     * Delete a global context variable\r\n     * @internal\r\n     * @param name the name of the variable\r\n     */\r\n    public _deleteGlobalContextVariable(name: string) {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableDelete,\r\n            payload: { name },\r\n        });\r\n        delete this._globalContextVariables[name];\r\n    }\r\n\r\n    /**\r\n     * Check if a global context variable is defined\r\n     * @internal\r\n     * @param name the name of the variable\r\n     * @returns true if the variable is defined\r\n     */\r\n    public _hasGlobalContextVariable(name: string) {\r\n        return name in this._globalContextVariables;\r\n    }\r\n\r\n    /**\r\n     * Set an internal execution variable\r\n     * @internal\r\n     * @param name\r\n     * @param value\r\n     */\r\n    public _setExecutionVariable(block: FlowGraphBlock, name: string, value: any) {\r\n        this._executionVariables[this._getUniqueIdPrefixedName(block, name)] = value;\r\n    }\r\n\r\n    /**\r\n     * Get an internal execution variable\r\n     * @internal\r\n     * @param name\r\n     * @returns\r\n     */\r\n    public _getExecutionVariable<T>(block: FlowGraphBlock, name: string, defaultValue: T): T {\r\n        if (this._hasExecutionVariable(block, name)) {\r\n            return this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete an internal execution variable\r\n     * @internal\r\n     * @param block\r\n     * @param name\r\n     */\r\n    public _deleteExecutionVariable(block: FlowGraphBlock, name: string) {\r\n        delete this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\r\n    }\r\n\r\n    /**\r\n     * Check if an internal execution variable is defined\r\n     * @internal\r\n     * @param block\r\n     * @param name\r\n     * @returns\r\n     */\r\n    public _hasExecutionVariable(block: FlowGraphBlock, name: string) {\r\n        return this._getUniqueIdPrefixedName(block, name) in this._executionVariables;\r\n    }\r\n\r\n    /**\r\n     * Check if a connection value is defined\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @returns\r\n     */\r\n    public _hasConnectionValue(connectionPoint: FlowGraphDataConnection<any>) {\r\n        return connectionPoint.uniqueId in this._connectionValues;\r\n    }\r\n\r\n    /**\r\n     * Set a connection value\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @param value\r\n     */\r\n    public _setConnectionValue<T>(connectionPoint: FlowGraphDataConnection<T>, value: T) {\r\n        this._connectionValues[connectionPoint.uniqueId] = value;\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.SetConnectionValue,\r\n            payload: {\r\n                connectionPointId: connectionPoint.uniqueId,\r\n                value,\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set a connection value by key\r\n     * @internal\r\n     * @param key the key of the connection value\r\n     * @param value the value of the connection\r\n     */\r\n    public _setConnectionValueByKey<T>(key: string, value: T) {\r\n        this._connectionValues[key] = value;\r\n    }\r\n\r\n    /**\r\n     * Get a connection value\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @returns\r\n     */\r\n    public _getConnectionValue<T>(connectionPoint: FlowGraphDataConnection<T>): T {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GetConnectionValue,\r\n            payload: {\r\n                connectionPointId: connectionPoint.uniqueId,\r\n                value: this._connectionValues[connectionPoint.uniqueId],\r\n            },\r\n        });\r\n        return this._connectionValues[connectionPoint.uniqueId];\r\n    }\r\n\r\n    /**\r\n     * Get the configuration\r\n     * @internal\r\n     * @param name\r\n     * @param value\r\n     */\r\n    public get configuration() {\r\n        return this._configuration;\r\n    }\r\n\r\n    /**\r\n     * Check if there are any pending blocks in this context\r\n     * @returns true if there are pending blocks\r\n     */\r\n    public get hasPendingBlocks() {\r\n        return this._pendingBlocks.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Add a block to the list of blocks that have pending tasks.\r\n     * @internal\r\n     * @param block\r\n     */\r\n    public _addPendingBlock(block: FlowGraphAsyncExecutionBlock) {\r\n        // check if block is already in the array\r\n        if (this._pendingBlocks.includes(block)) {\r\n            return;\r\n        }\r\n        this._pendingBlocks.push(block);\r\n        // sort pending blocks by priority\r\n        this._pendingBlocks.sort((a, b) => a.priority - b.priority);\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of blocks that have pending tasks.\r\n     * @internal\r\n     * @param block\r\n     */\r\n    public _removePendingBlock(block: FlowGraphAsyncExecutionBlock) {\r\n        const index = this._pendingBlocks.indexOf(block);\r\n        if (index !== -1) {\r\n            this._pendingBlocks.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all pending blocks.\r\n     * @internal\r\n     */\r\n    public _clearPendingBlocks() {\r\n        for (const block of this._pendingBlocks) {\r\n            block._cancelPendingTasks(this);\r\n        }\r\n        this._pendingBlocks.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Function that notifies the node executed observable\r\n     * @param node\r\n     */\r\n    public _notifyExecuteNode(node: FlowGraphBlock) {\r\n        this.onNodeExecutedObservable.notifyObservers(node);\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: node.getClassName(),\r\n            uniqueId: node.uniqueId,\r\n            action: FlowGraphAction.ExecuteBlock,\r\n        });\r\n    }\r\n\r\n    public _notifyOnTick(framePayload: IFlowGraphOnTickEventPayload) {\r\n        // set the values as global variables\r\n        this._setGlobalContextVariable(\"timeSinceStart\", framePayload.timeSinceStart);\r\n        this._setGlobalContextVariable(\"deltaTime\", framePayload.deltaTime);\r\n        // iterate the pending blocks and run each one's onFrame function\r\n        for (const block of this._pendingBlocks) {\r\n            block._executeOnTick?.(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _increaseExecutionId() {\r\n        this._executionId++;\r\n    }\r\n    /**\r\n     * A monotonically increasing ID for each execution.\r\n     * Incremented for every block executed.\r\n     */\r\n    public get executionId() {\r\n        return this._executionId;\r\n    }\r\n\r\n    /**\r\n     * Serializes a context\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializationFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializationFunction: (key: string, value: any, serializationObject: any) => void = defaultValueSerializationFunction) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject._userVariables = {};\r\n        for (const key in this._userVariables) {\r\n            valueSerializationFunction(key, this._userVariables[key], serializationObject._userVariables);\r\n        }\r\n        serializationObject._connectionValues = {};\r\n        for (const key in this._connectionValues) {\r\n            valueSerializationFunction(key, this._connectionValues[key], serializationObject._connectionValues);\r\n        }\r\n        // serialize assets context, if not scene\r\n        if (this.assetsContext !== this.getScene()) {\r\n            serializationObject._assetsContext = {\r\n                meshes: this.assetsContext.meshes.map((m) => m.id),\r\n                materials: this.assetsContext.materials.map((m) => m.id),\r\n                textures: this.assetsContext.textures.map((m) => m.name),\r\n                animations: this.assetsContext.animations.map((m) => m.name),\r\n                lights: this.assetsContext.lights.map((m) => m.id),\r\n                cameras: this.assetsContext.cameras.map((m) => m.id),\r\n                sounds: this.assetsContext.sounds?.map((m) => m.name),\r\n                skeletons: this.assetsContext.skeletons.map((m) => m.id),\r\n                particleSystems: this.assetsContext.particleSystems.map((m) => m.name),\r\n                geometries: this.assetsContext.geometries.map((m) => m.id),\r\n                multiMaterials: this.assetsContext.multiMaterials.map((m) => m.id),\r\n                transformNodes: this.assetsContext.transformNodes.map((m) => m.id),\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the class name of the object.\r\n     */\r\n    public getClassName() {\r\n        return \"FlowGraphContext\";\r\n    }\r\n}\r\n", "import type { PointerInfo } from \"core/Events/pointerEvents\";\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { Observer } from \"core/Misc/observable\";\nimport { Observable } from \"core/Misc/observable\";\nimport type { Scene } from \"core/scene\";\nimport type { Nullable } from \"core/types\";\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\n\n/**\n * the interface of the object the scene event coordinator will trigger.\n */\nexport interface IFlowGraphEventTrigger {\n    /**\n     * The type of the event\n     */\n    type: FlowGraphEventType;\n    /**\n     * The data of the event\n     */\n    payload?: any;\n}\n\n/**\n * This class is responsible for coordinating the events that are triggered in the scene.\n * It registers all observers needed to track certain events and triggers the blocks that are listening to them.\n * Abstracting the events from the class will allow us to easily change the events that are being listened to, and trigger them in any order.\n */\nexport class FlowGraphSceneEventCoordinator {\n    /**\n     * @internal\n     */\n    public readonly _scene: Scene;\n\n    /**\n     * register to this observable to get flow graph event notifications.\n     */\n    public onEventTriggeredObservable: Observable<IFlowGraphEventTrigger> = new Observable();\n\n    /**\n     * Was scene-ready already triggered?\n     */\n    public sceneReadyTriggered: boolean = false;\n\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\n    private _sceneReadyObserver: Nullable<Observer<Scene>>;\n    private _sceneOnBeforeRenderObserver: Nullable<Observer<Scene>>;\n    private _meshPickedObserver: Nullable<Observer<PointerInfo>>;\n    private _meshUnderPointerObserver: Nullable<Observer<{ mesh: Nullable<AbstractMesh>; pointerId: number }>>;\n    private _pointerUnderMeshState: { [pointerId: number]: Nullable<AbstractMesh> } = {};\n\n    private _startingTime: number = 0;\n\n    constructor(scene: Scene) {\n        this._scene = scene;\n        this._initialize();\n    }\n\n    private _initialize() {\n        this._sceneReadyObserver = this._scene.onReadyObservable.add(() => {\n            if (!this.sceneReadyTriggered) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneReady });\n                this.sceneReadyTriggered = true;\n            }\n        });\n\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n            this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneDispose });\n        });\n        this._sceneOnBeforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n            const deltaTime = this._scene.getEngine().getDeltaTime() / 1000; // set in seconds\n            this.onEventTriggeredObservable.notifyObservers({\n                type: FlowGraphEventType.SceneBeforeRender,\n                payload: {\n                    timeSinceStart: this._startingTime,\n                    deltaTime,\n                },\n            });\n            this._startingTime += deltaTime;\n        });\n\n        this._meshPickedObserver = this._scene.onPointerObservable.add((pointerInfo) => {\n            this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.MeshPick, payload: pointerInfo });\n        }, PointerEventTypes.POINTERPICK); // should it be pointerdown?\n\n        this._meshUnderPointerObserver = this._scene.onMeshUnderPointerUpdatedObservable.add((data) => {\n            // check if the data has changed. Check the state of the last change and see if it is a mesh or null.\n            // if it is a mesh and the previous state was null, trigger over event. If it is null and the previous state was a mesh, trigger out event.\n            // if it is a mesh and the previous state was a mesh, trigger out from the old mesh and over the new mesh\n            // if it is null and the previous state was null, do nothing.\n            const pointerId = data.pointerId;\n            const mesh = data.mesh;\n            const previousState = this._pointerUnderMeshState[pointerId];\n            if (!previousState && mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOver, payload: { pointerId, mesh } });\n            } else if (previousState && !mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOut, payload: { pointerId, mesh: previousState } });\n            } else if (previousState && mesh && previousState !== mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOut, payload: { pointerId, mesh: previousState, over: mesh } });\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOver, payload: { pointerId, mesh, out: previousState } });\n            }\n            this._pointerUnderMeshState[pointerId] = mesh;\n        }, PointerEventTypes.POINTERMOVE);\n    }\n\n    public dispose() {\n        this._sceneDisposeObserver?.remove();\n        this._sceneReadyObserver?.remove();\n        this._sceneOnBeforeRenderObserver?.remove();\n        this._meshPickedObserver?.remove();\n        this._meshUnderPointerObserver?.remove();\n        this.onEventTriggeredObservable.clear();\n    }\n}\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\r\nimport { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\r\nimport type { IFlowGraphEventTrigger } from \"./flowGraphSceneEventCoordinator\";\r\nimport { FlowGraphSceneEventCoordinator } from \"./flowGraphSceneEventCoordinator\";\r\nimport type { FlowGraphMeshPickEventBlock } from \"./Blocks/Event/flowGraphMeshPickEventBlock\";\r\nimport { _isADescendantOf } from \"./utils\";\r\n\r\nexport const enum FlowGraphState {\r\n    /**\r\n     * The graph is stopped\r\n     */\r\n    Stopped,\r\n    /**\r\n     * The graph is running\r\n     */\r\n    Started,\r\n}\r\n\r\n/**\r\n * Parameters used to create a flow graph.\r\n */\r\nexport interface IFlowGraphParams {\r\n    /**\r\n     * The scene that the flow graph belongs to.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n}\r\n\r\n/**\r\n * Options for parsing a flow graph.\r\n */\r\nexport interface IFlowGraphParseOptions {\r\n    /**\r\n     * A function that parses complex values in a scene.\r\n     * @param key the key of the value\r\n     * @param serializationObject the object to read the value from\r\n     * @param scene the scene to read the value from\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The flow graph coordinator.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n    /**\r\n     * A function that converts a path to an object accessor.\r\n     */\r\n    pathConverter?: IPathToObjectConverter<IObjectAccessor>;\r\n}\r\n/**\r\n * Class used to represent a flow graph.\r\n * A flow graph is a graph of blocks that can be used to create complex logic.\r\n * Blocks can be added to the graph and connected to each other.\r\n * The graph can then be started, which will init and start all of its event blocks.\r\n *\r\n * @experimental FlowGraph is still in development and is subject to change.\r\n */\r\nexport class FlowGraph {\r\n    /**\r\n     * An observable that is triggered when the state of the graph changes.\r\n     */\r\n    public onStateChangedObservable: Observable<FlowGraphState> = new Observable();\r\n    /** @internal */\r\n    public _eventBlocks: { [keyof in FlowGraphEventType]: FlowGraphEventBlock[] } = {\r\n        [FlowGraphEventType.SceneReady]: [],\r\n        [FlowGraphEventType.SceneDispose]: [],\r\n        [FlowGraphEventType.SceneBeforeRender]: [],\r\n        [FlowGraphEventType.MeshPick]: [],\r\n        [FlowGraphEventType.PointerDown]: [],\r\n        [FlowGraphEventType.PointerUp]: [],\r\n        [FlowGraphEventType.PointerMove]: [],\r\n        [FlowGraphEventType.PointerOver]: [],\r\n        [FlowGraphEventType.PointerOut]: [],\r\n        [FlowGraphEventType.SceneAfterRender]: [],\r\n        [FlowGraphEventType.NoTrigger]: [],\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    public readonly _scene: Scene;\r\n    private _coordinator: FlowGraphCoordinator;\r\n    private _executionContexts: FlowGraphContext[] = [];\r\n    private _sceneEventCoordinator: FlowGraphSceneEventCoordinator;\r\n    private _eventObserver: Nullable<Observer<IFlowGraphEventTrigger>>;\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    private _state: FlowGraphState = FlowGraphState.Stopped;\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    public get state() {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    public set state(value: FlowGraphState) {\r\n        this._state = value;\r\n        this.onStateChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Construct a Flow Graph\r\n     * @param params construction parameters. currently only the scene\r\n     */\r\n    public constructor(params: IFlowGraphParams) {\r\n        this._scene = params.scene;\r\n        this._sceneEventCoordinator = new FlowGraphSceneEventCoordinator(this._scene);\r\n        this._coordinator = params.coordinator;\r\n\r\n        this._eventObserver = this._sceneEventCoordinator.onEventTriggeredObservable.add((event) => {\r\n            for (const context of this._executionContexts) {\r\n                const order = this._getContextualOrder(event.type, context);\r\n                for (const block of order) {\r\n                    // iterate contexts\r\n                    if (!block._executeEvent(context, event.payload)) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // custom behavior(s) of specific events\r\n            switch (event.type) {\r\n                case FlowGraphEventType.SceneReady:\r\n                    this._sceneEventCoordinator.sceneReadyTriggered = true;\r\n                    break;\r\n                case FlowGraphEventType.SceneBeforeRender:\r\n                    for (const context of this._executionContexts) {\r\n                        context._notifyOnTick(event.payload);\r\n                    }\r\n                    break;\r\n                case FlowGraphEventType.SceneDispose:\r\n                    this.dispose();\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a context. A context represents one self contained execution for the graph, with its own variables.\r\n     * @returns the context, where you can get and set variables\r\n     */\r\n    public createContext() {\r\n        const context = new FlowGraphContext({ scene: this._scene, coordinator: this._coordinator });\r\n        this._executionContexts.push(context);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Returns the execution context at a given index\r\n     * @param index the index of the context\r\n     * @returns the execution context at that index\r\n     */\r\n    public getContext(index: number) {\r\n        return this._executionContexts[index];\r\n    }\r\n\r\n    /**\r\n     * Add an event block. When the graph is started, it will start listening to events\r\n     * from the block and execute the graph when they are triggered.\r\n     * @param block the event block to be added\r\n     */\r\n    public addEventBlock(block: FlowGraphEventBlock): void {\r\n        if (block.type === FlowGraphEventType.PointerOver || block.type === FlowGraphEventType.PointerOut) {\r\n            this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        }\r\n\r\n        // don't add if NoTrigger, but still start the pending tasks\r\n        if (block.type !== FlowGraphEventType.NoTrigger) {\r\n            this._eventBlocks[block.type].push(block);\r\n        }\r\n        // if already started, sort and add to the pending\r\n        if (this.state === FlowGraphState.Started) {\r\n            for (const context of this._executionContexts) {\r\n                block._startPendingTasks(context);\r\n            }\r\n        } else {\r\n            this.onStateChangedObservable.addOnce((state) => {\r\n                if (state === FlowGraphState.Started) {\r\n                    for (const context of this._executionContexts) {\r\n                        block._startPendingTasks(context);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the flow graph. Initializes the event blocks and starts listening to events.\r\n     */\r\n    public start() {\r\n        if (this.state === FlowGraphState.Started) {\r\n            return;\r\n        }\r\n        if (this._executionContexts.length === 0) {\r\n            this.createContext();\r\n        }\r\n        this.onStateChangedObservable.add((state) => {\r\n            if (state === FlowGraphState.Started) {\r\n                this._startPendingEvents();\r\n                // the only event we need to check is the scene ready event. If the scene is already ready when the graph starts, we should start the pending tasks.\r\n                if (this._scene.isReady(true)) {\r\n                    this._sceneEventCoordinator.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneReady });\r\n                }\r\n            }\r\n        });\r\n        this.state = FlowGraphState.Started;\r\n    }\r\n\r\n    private _startPendingEvents() {\r\n        for (const context of this._executionContexts) {\r\n            for (const type in this._eventBlocks) {\r\n                const order = this._getContextualOrder(type as FlowGraphEventType, context);\r\n                for (const block of order) {\r\n                    block._startPendingTasks(context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getContextualOrder(type: FlowGraphEventType, context: FlowGraphContext): FlowGraphEventBlock[] {\r\n        const order = this._eventBlocks[type].sort((a, b) => b.initPriority - a.initPriority);\r\n\r\n        if (type === FlowGraphEventType.MeshPick) {\r\n            const meshPickOrder = [] as FlowGraphEventBlock[];\r\n            for (const block1 of order) {\r\n                // If the block is a mesh pick, guarantee that picks of children meshes come before picks of parent meshes\r\n                const mesh1 = (block1 as FlowGraphMeshPickEventBlock).asset.getValue(context);\r\n                let i = 0;\r\n                for (; i < order.length; i++) {\r\n                    const block2 = order[i];\r\n                    const mesh2 = (block2 as FlowGraphMeshPickEventBlock).asset.getValue(context);\r\n                    if (mesh1 && mesh2 && _isADescendantOf(mesh1, mesh2)) {\r\n                        break;\r\n                    }\r\n                }\r\n                meshPickOrder.splice(i, 0, block1);\r\n            }\r\n            return meshPickOrder;\r\n        }\r\n        return order;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\r\n     */\r\n    public dispose() {\r\n        if (this.state === FlowGraphState.Stopped) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Stopped;\r\n        for (const context of this._executionContexts) {\r\n            context._clearPendingBlocks();\r\n        }\r\n        this._executionContexts.length = 0;\r\n        for (const type in this._eventBlocks) {\r\n            this._eventBlocks[type as FlowGraphEventType].length = 0;\r\n        }\r\n        this._eventObserver?.remove();\r\n        this._sceneEventCoordinator.dispose();\r\n    }\r\n\r\n    /**\r\n     * Executes a function in all blocks of a flow graph, starting with the event blocks.\r\n     * @param visitor the function to execute.\r\n     */\r\n    public visitAllBlocks(visitor: (block: FlowGraphBlock) => void) {\r\n        const visitList: FlowGraphBlock[] = [];\r\n        const idsAddedToVisitList = new Set<string>();\r\n        for (const type in this._eventBlocks) {\r\n            for (const block of this._eventBlocks[type as FlowGraphEventType]) {\r\n                visitList.push(block);\r\n                idsAddedToVisitList.add(block.uniqueId);\r\n            }\r\n        }\r\n\r\n        while (visitList.length > 0) {\r\n            const block = visitList.pop()!;\r\n            visitor(block);\r\n\r\n            for (const dataIn of block.dataInputs) {\r\n                for (const connection of dataIn._connectedPoint) {\r\n                    if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                        visitList.push(connection._ownerBlock);\r\n                        idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                    }\r\n                }\r\n            }\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalOut of block.signalOutputs) {\r\n                    for (const connection of signalOut._connectedPoint) {\r\n                        if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                            visitList.push(connection._ownerBlock);\r\n                            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes a graph\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializeFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject.allBlocks = [];\r\n        this.visitAllBlocks((block) => {\r\n            const serializedBlock: any = {};\r\n            block.serialize(serializedBlock);\r\n            serializationObject.allBlocks.push(serializedBlock);\r\n        });\r\n        serializationObject.executionContexts = [];\r\n        for (const context of this._executionContexts) {\r\n            const serializedContext: any = {};\r\n            context.serialize(serializedContext, valueSerializeFunction);\r\n            serializationObject.executionContexts.push(serializedContext);\r\n        }\r\n    }\r\n}\r\n", "import type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraph } from \"./flowGraph\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Parameters used to create a flow graph engine.\r\n */\r\nexport interface IFlowGraphCoordinatorConfiguration {\r\n    /**\r\n     * The scene that the flow graph engine belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n\r\n/**\r\n * Parameters used to parse a flow graph coordinator.\r\n */\r\nexport interface FlowGraphCoordinatorParseOptions {\r\n    /**\r\n     * A function that will be called to parse the value of a property.\r\n     * @param key the key of the property\r\n     * @param serializationObject the serialization object where the property is located\r\n     * @param scene the scene that the block is being parsed in\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The path converter to use to convert the path to an object accessor.\r\n     */\r\n    pathConverter: IPathToObjectConverter<IObjectAccessor>;\r\n    /**\r\n     * The scene that the flow graph coordinator belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n/**\r\n * This class holds all of the existing flow graphs and is responsible for creating new ones.\r\n * It also handles starting/stopping multiple graphs and communication between them through an Event Coordinator\r\n * This is the entry point for the flow graph system.\r\n * @experimental This class is still in development and is subject to change.\r\n */\r\nexport class FlowGraphCoordinator {\r\n    /**\r\n     * The maximum number of events per type.\r\n     * This is used to limit the number of events that can be created in a single scene.\r\n     * This is to prevent infinite loops.\r\n     */\r\n    public static MaxEventsPerType: number = 30;\r\n\r\n    /**\r\n     * The maximum number of execution of a specific event in a single frame.\r\n     */\r\n    public static MaxEventTypeExecutionPerFrame: number = 30;\r\n    /**\r\n     * @internal\r\n     * A list of all the coordinators per scene. Will be used by the inspector\r\n     */\r\n    public static readonly SceneCoordinators: Map<Scene, FlowGraphCoordinator[]> = new Map();\r\n\r\n    /**\r\n     * When set to true (default) custom events will be dispatched synchronously.\r\n     * This means that the events will be dispatched immediately when they are triggered.\r\n     */\r\n    public dispatchEventsSynchronously: boolean = true;\r\n\r\n    private readonly _flowGraphs: FlowGraph[] = [];\r\n\r\n    private _customEventsMap: Map<string, Observable<any>> = new Map();\r\n\r\n    private _eventExecutionCounter: Map<string, number> = new Map();\r\n\r\n    private _disposeObserver: Observer<Scene>;\r\n    private _onBeforeRenderObserver: Observer<Scene>;\r\n    private _executeOnNextFrame: { id: string; data?: any; uniqueId: number }[] = [];\r\n    private _eventUniqueId: number = 0;\r\n\r\n    public constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public config: IFlowGraphCoordinatorConfiguration\r\n    ) {\r\n        // When the scene is disposed, dispose all graphs currently running on it.\r\n        this._disposeObserver = this.config.scene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._onBeforeRenderObserver = this.config.scene.onBeforeRenderObservable.add(() => {\r\n            // Reset the event execution counter at the beginning of each frame.\r\n            this._eventExecutionCounter.clear();\r\n            // duplicate the _executeOnNextFrame array to avoid modifying it while iterating over it\r\n            const executeOnNextFrame = this._executeOnNextFrame.slice(0);\r\n            if (executeOnNextFrame.length) {\r\n                // Execute the events that were triggered on the next frame.\r\n                executeOnNextFrame.forEach((event) => {\r\n                    this.notifyCustomEvent(event.id, event.data, false);\r\n                    // remove the event from the array\r\n                    const index = this._executeOnNextFrame.findIndex((e) => e.uniqueId === event.uniqueId);\r\n                    if (index !== -1) {\r\n                        this._executeOnNextFrame.splice(index, 1);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        // Add itself to the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\r\n        coordinators.push(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new flow graph and adds it to the list of existing flow graphs\r\n     * @returns a new flow graph\r\n     */\r\n    public createGraph(): FlowGraph {\r\n        const graph = new FlowGraph({ scene: this.config.scene, coordinator: this });\r\n        this._flowGraphs.push(graph);\r\n        return graph;\r\n    }\r\n\r\n    /**\r\n     * Removes a flow graph from the list of existing flow graphs and disposes it\r\n     * @param graph the graph to remove\r\n     */\r\n    public removeGraph(graph: FlowGraph) {\r\n        const index = this._flowGraphs.indexOf(graph);\r\n        if (index !== -1) {\r\n            graph.dispose();\r\n            this._flowGraphs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts all graphs\r\n     */\r\n    public start() {\r\n        this._flowGraphs.forEach((graph) => graph.start());\r\n    }\r\n\r\n    /**\r\n     * Disposes all graphs\r\n     */\r\n    public dispose() {\r\n        this._flowGraphs.forEach((graph) => graph.dispose());\r\n        this._flowGraphs.length = 0;\r\n        this._disposeObserver?.remove();\r\n        this._onBeforeRenderObserver?.remove();\r\n\r\n        // Remove itself from the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\r\n        const index = coordinators.indexOf(this);\r\n        if (index !== -1) {\r\n            coordinators.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this coordinator to a JSON object.\r\n     * @param serializationObject the object to serialize to\r\n     * @param valueSerializeFunction the function to use to serialize the value\r\n     */\r\n    public serialize(serializationObject: any, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject._flowGraphs = [];\r\n        this._flowGraphs.forEach((graph) => {\r\n            const serializedGraph = {};\r\n            graph.serialize(serializedGraph, valueSerializeFunction);\r\n            serializationObject._flowGraphs.push(serializedGraph);\r\n        });\r\n        serializationObject.dispatchEventsSynchronously = this.dispatchEventsSynchronously;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of flow graphs\r\n     */\r\n    public get flowGraphs() {\r\n        return this._flowGraphs;\r\n    }\r\n\r\n    /**\r\n     * Get an observable that will be notified when the event with the given id is fired.\r\n     * @param id the id of the event\r\n     * @returns the observable for the event\r\n     */\r\n    public getCustomEventObservable(id: string): Observable<any> {\r\n        let observable = this._customEventsMap.get(id);\r\n        if (!observable) {\r\n            // receive event is initialized before scene start, so no need to notify if triggered. but possible!\r\n            observable = new Observable<any>(/*undefined, true*/);\r\n            this._customEventsMap.set(id, observable);\r\n        }\r\n        return observable;\r\n    }\r\n\r\n    /**\r\n     * Notifies the observable for the given event id with the given data.\r\n     * @param id the id of the event\r\n     * @param data the data to send with the event\r\n     * @param async if true, the event will be dispatched asynchronously\r\n     */\r\n    public notifyCustomEvent(id: string, data: any, async: boolean = !this.dispatchEventsSynchronously) {\r\n        if (async) {\r\n            this._executeOnNextFrame.push({ id, data, uniqueId: this._eventUniqueId++ });\r\n            return;\r\n        }\r\n        // check if we are not exceeding the max number of events\r\n        if (this._eventExecutionCounter.has(id)) {\r\n            const count = this._eventExecutionCounter.get(id)!;\r\n            this._eventExecutionCounter.set(id, count + 1);\r\n            if (count >= FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {\r\n                count === FlowGraphCoordinator.MaxEventTypeExecutionPerFrame && Logger.Warn(`FlowGraphCoordinator: Too many executions of event \"${id}\".`);\r\n                return;\r\n            }\r\n        } else {\r\n            this._eventExecutionCounter.set(id, 1);\r\n        }\r\n        const observable = this._customEventsMap.get(id);\r\n        if (observable) {\r\n            observable.notifyObservers(data);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAEkB,iBAiDL;AAnDb;;;AAEA,KAAA,SAAkBA,kBAAe;AAC7B,MAAAA,iBAAA,cAAA,IAAA;AACA,MAAAA,iBAAA,cAAA,IAAA;AACA,MAAAA,iBAAA,mBAAA,IAAA;AACA,MAAAA,iBAAA,oBAAA,IAAA;AACA,MAAAA,iBAAA,mBAAA,IAAA;AACA,MAAAA,iBAAA,sBAAA,IAAA;AACA,MAAAA,iBAAA,mBAAA,IAAA;AACA,MAAAA,iBAAA,eAAA,IAAA;AACA,MAAAA,iBAAA,oBAAA,IAAA;AACA,MAAAA,iBAAA,oBAAA,IAAA;AACA,MAAAA,iBAAA,gBAAA,IAAA;AACA,MAAAA,iBAAA,oBAAA,IAAA;IACJ,GAbkB,oBAAA,kBAAe,CAAA,EAAA;AAiD3B,IAAO,kBAAP,MAAsB;MAA5B,cAAA;AAIW,aAAA,eAAwB;AAMxB,aAAA,MAA2B,CAAA;MAoBtC;MAlBW,WAAW,MAAuB;AA/D7C;AAgEQ,YAAI,CAAC,KAAK,MAAM;AACZ,eAAK,OAAO,KAAK,IAAG;QACxB;AACA,aAAK,IAAI,KAAK,IAAI;AAClB,YAAI,KAAK,cAAc;AACnB,gBAAM,SAAQ,UAAK,YAAL,mBAAc;AAC5B,cAAI,OAAO,UAAU,YAAY,MAAM,cAAc;AACjD,mBAAO,IAAI,WAAW,KAAK,SAAS,IAAI,KAAK,SAAS,MAAM,GAAG,EAAE,CAAC,CAAC,IAAI,KAAK,MAAM,MAAM,KAAK,UAAU,MAAM,aAAY,CAAE,CAAC,KAAK,MAAM,SAAQ,CAAE,EAAE;UACvJ,OAAO;AACH,mBAAO,IAAI,WAAW,KAAK,SAAS,IAAI,KAAK,SAAS,MAAM,GAAG,EAAE,CAAC,CAAC,IAAI,KAAK,MAAM,MAAM,KAAK,UAAU,KAAK,OAAO,CAAC,EAAE;UAC1H;QACJ;MACJ;MAEO,eAAe,QAAuB;AACzC,eAAO,KAAK,IAAI,OAAO,CAAC,MAAM,EAAE,WAAW,MAAM;MACrD;;;;;;ICpBS;;;;AA5Db;AACA;AAMA;AAEA;AAEA;AAGA;AA8CM,IAAO,mBAAP,MAAuB;;;;MAgEzB,IAAW,gBAAa;AACpB,eAAO,KAAK;MAChB;MAEA,IAAW,cAAc,OAAc;AACnC,YAAI,KAAK,mBAAmB,OAAO;AAC/B;QACJ;AACA,aAAK,iBAAiB;AACtB,YAAI,KAAK,gBAAgB;AACrB,eAAK,SAAS,IAAI,gBAAe;AACjC,eAAK,OAAO,eAAe;QAC/B,OAAO;AACH,eAAK,SAAS;QAClB;MACJ;MAEA,YAAY,QAAsC;AA5E3C,aAAA,WAAW,WAAU;AAIpB,aAAA,iBAAyC,CAAA;AAIzC,aAAA,sBAA8C,CAAA;AAK9C,aAAA,0BAAkD,CAAA;AAIlD,aAAA,oBAA4C,CAAA;AAQ5C,aAAA,iBAAiD,CAAA;AAKjD,aAAA,eAAe;AAIhB,aAAA,2BAAuD,IAAI,WAAU;AAarE,aAAA,yBAAyB;AAExB,aAAA,iBAAiB;AA4BrB,aAAK,iBAAiB;AACtB,aAAK,gBAAgB,OAAO,iBAAiB,OAAO;MACxD;;;;;;MAOO,YAAY,MAAY;AAC3B,eAAO,QAAQ,KAAK;MACxB;;;;;;MAOO,YAAY,MAAc,OAAU;;AACvC,aAAK,eAAe,IAAI,IAAI;AAC5B,mBAAK,WAAL,mBAAa,WAAW;UACpB,MAAM,KAAK,IAAG;UACd,WAAW,KAAK,aAAY;UAC5B,UAAU,KAAK;UACf,QAAM;UACN,SAAS;YACL;YACA;;;MAGZ;;;;;;;MAQO,SAAuC,MAAS,OAAa;AAChE,eAAO,0BAA0B,KAAK,eAAe,MAAM,KAAK;MACpE;;;;;;MAOO,YAAY,MAAY;;AAC3B,mBAAK,WAAL,mBAAa,WAAW;UACpB,MAAM,KAAK,IAAG;UACd,WAAW,KAAK,aAAY;UAC5B,UAAU,KAAK;UACf,QAAM;UACN,SAAS;YACL;YACA,OAAO,KAAK,eAAe,IAAI;;;AAGvC,eAAO,KAAK,eAAe,IAAI;MACnC;;;;MAKA,IAAW,gBAAa;AACpB,eAAO,KAAK;MAChB;;;;;MAMO,WAAQ;AACX,eAAO,KAAK,eAAe;MAC/B;MAEQ,yBAAyB,KAAqB,MAAY;AAC9D,eAAO,GAAG,IAAI,QAAQ,IAAI,IAAI;MAClC;;;;;;;MAQO,0BAA6B,MAAc,cAAe;;AAC7D,mBAAK,WAAL,mBAAa,WAAW;UACpB,MAAM,KAAK,IAAG;UACd,WAAW,KAAK,aAAY;UAC5B,UAAU,KAAK;UACf,QAAM;UACN,SAAS;YACL;YACA;YACA,eAAe,KAAK,wBAAwB,IAAI;;;AAGxD,YAAI,KAAK,0BAA0B,IAAI,GAAG;AACtC,iBAAO,KAAK,wBAAwB,IAAI;QAC5C,OAAO;AACH,iBAAO;QACX;MACJ;;;;;;;MAQO,0BAA6B,MAAc,OAAQ;;AACtD,mBAAK,WAAL,mBAAa,WAAW;UACpB,MAAM,KAAK,IAAG;UACd,WAAW,KAAK,aAAY;UAC5B,UAAU,KAAK;UACf,QAAM;UACN,SAAS,EAAE,MAAM,MAAK;;AAE1B,aAAK,wBAAwB,IAAI,IAAI;MACzC;;;;;;MAOO,6BAA6B,MAAY;;AAC5C,mBAAK,WAAL,mBAAa,WAAW;UACpB,MAAM,KAAK,IAAG;UACd,WAAW,KAAK,aAAY;UAC5B,UAAU,KAAK;UACf,QAAM;UACN,SAAS,EAAE,KAAI;;AAEnB,eAAO,KAAK,wBAAwB,IAAI;MAC5C;;;;;;;MAQO,0BAA0B,MAAY;AACzC,eAAO,QAAQ,KAAK;MACxB;;;;;;;MAQO,sBAAsB,OAAuB,MAAc,OAAU;AACxE,aAAK,oBAAoB,KAAK,yBAAyB,OAAO,IAAI,CAAC,IAAI;MAC3E;;;;;;;MAQO,sBAAyB,OAAuB,MAAc,cAAe;AAChF,YAAI,KAAK,sBAAsB,OAAO,IAAI,GAAG;AACzC,iBAAO,KAAK,oBAAoB,KAAK,yBAAyB,OAAO,IAAI,CAAC;QAC9E,OAAO;AACH,iBAAO;QACX;MACJ;;;;;;;MAQO,yBAAyB,OAAuB,MAAY;AAC/D,eAAO,KAAK,oBAAoB,KAAK,yBAAyB,OAAO,IAAI,CAAC;MAC9E;;;;;;;;MASO,sBAAsB,OAAuB,MAAY;AAC5D,eAAO,KAAK,yBAAyB,OAAO,IAAI,KAAK,KAAK;MAC9D;;;;;;;MAQO,oBAAoB,iBAA6C;AACpE,eAAO,gBAAgB,YAAY,KAAK;MAC5C;;;;;;;MAQO,oBAAuB,iBAA6C,OAAQ;;AAC/E,aAAK,kBAAkB,gBAAgB,QAAQ,IAAI;AACnD,mBAAK,WAAL,mBAAa,WAAW;UACpB,MAAM,KAAK,IAAG;UACd,WAAW,KAAK,aAAY;UAC5B,UAAU,KAAK;UACf,QAAM;UACN,SAAS;YACL,mBAAmB,gBAAgB;YACnC;;;MAGZ;;;;;;;MAQO,yBAA4B,KAAa,OAAQ;AACpD,aAAK,kBAAkB,GAAG,IAAI;MAClC;;;;;;;MAQO,oBAAuB,iBAA2C;;AACrE,mBAAK,WAAL,mBAAa,WAAW;UACpB,MAAM,KAAK,IAAG;UACd,WAAW,KAAK,aAAY;UAC5B,UAAU,KAAK;UACf,QAAM;UACN,SAAS;YACL,mBAAmB,gBAAgB;YACnC,OAAO,KAAK,kBAAkB,gBAAgB,QAAQ;;;AAG9D,eAAO,KAAK,kBAAkB,gBAAgB,QAAQ;MAC1D;;;;;;;MAQA,IAAW,gBAAa;AACpB,eAAO,KAAK;MAChB;;;;;MAMA,IAAW,mBAAgB;AACvB,eAAO,KAAK,eAAe,SAAS;MACxC;;;;;;MAOO,iBAAiB,OAAmC;AAEvD,YAAI,KAAK,eAAe,SAAS,KAAK,GAAG;AACrC;QACJ;AACA,aAAK,eAAe,KAAK,KAAK;AAE9B,aAAK,eAAe,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,QAAQ;MAC9D;;;;;;MAOO,oBAAoB,OAAmC;AAC1D,cAAM,QAAQ,KAAK,eAAe,QAAQ,KAAK;AAC/C,YAAI,UAAU,IAAI;AACd,eAAK,eAAe,OAAO,OAAO,CAAC;QACvC;MACJ;;;;;MAMO,sBAAmB;AACtB,mBAAW,SAAS,KAAK,gBAAgB;AACrC,gBAAM,oBAAoB,IAAI;QAClC;AACA,aAAK,eAAe,SAAS;MACjC;;;;;;MAOO,mBAAmB,MAAoB;;AAC1C,aAAK,yBAAyB,gBAAgB,IAAI;AAClD,mBAAK,WAAL,mBAAa,WAAW;UACpB,MAAM,KAAK,IAAG;UACd,WAAW,KAAK,aAAY;UAC5B,UAAU,KAAK;UACf,QAAM;;MAEd;MAEO,cAAc,cAA0C;;AAE3D,aAAK,0BAA0B,kBAAkB,aAAa,cAAc;AAC5E,aAAK,0BAA0B,aAAa,aAAa,SAAS;AAElE,mBAAW,SAAS,KAAK,gBAAgB;AACrC,sBAAM,mBAAN,+BAAuB;QAC3B;MACJ;;;;MAKO,uBAAoB;AACvB,aAAK;MACT;;;;;MAKA,IAAW,cAAW;AAClB,eAAO,KAAK;MAChB;;;;;;MAOO,UAAU,sBAA2B,CAAA,GAAI,6BAA0F,mCAAiC;;AACvK,4BAAoB,WAAW,KAAK;AACpC,4BAAoB,iBAAiB,CAAA;AACrC,mBAAW,OAAO,KAAK,gBAAgB;AACnC,qCAA2B,KAAK,KAAK,eAAe,GAAG,GAAG,oBAAoB,cAAc;QAChG;AACA,4BAAoB,oBAAoB,CAAA;AACxC,mBAAW,OAAO,KAAK,mBAAmB;AACtC,qCAA2B,KAAK,KAAK,kBAAkB,GAAG,GAAG,oBAAoB,iBAAiB;QACtG;AAEA,YAAI,KAAK,kBAAkB,KAAK,SAAQ,GAAI;AACxC,8BAAoB,iBAAiB;YACjC,QAAQ,KAAK,cAAc,OAAO,IAAI,CAAC,MAAM,EAAE,EAAE;YACjD,WAAW,KAAK,cAAc,UAAU,IAAI,CAAC,MAAM,EAAE,EAAE;YACvD,UAAU,KAAK,cAAc,SAAS,IAAI,CAAC,MAAM,EAAE,IAAI;YACvD,YAAY,KAAK,cAAc,WAAW,IAAI,CAAC,MAAM,EAAE,IAAI;YAC3D,QAAQ,KAAK,cAAc,OAAO,IAAI,CAAC,MAAM,EAAE,EAAE;YACjD,SAAS,KAAK,cAAc,QAAQ,IAAI,CAAC,MAAM,EAAE,EAAE;YACnD,SAAQ,UAAK,cAAc,WAAnB,mBAA2B,IAAI,CAAC,MAAM,EAAE;YAChD,WAAW,KAAK,cAAc,UAAU,IAAI,CAAC,MAAM,EAAE,EAAE;YACvD,iBAAiB,KAAK,cAAc,gBAAgB,IAAI,CAAC,MAAM,EAAE,IAAI;YACrE,YAAY,KAAK,cAAc,WAAW,IAAI,CAAC,MAAM,EAAE,EAAE;YACzD,gBAAgB,KAAK,cAAc,eAAe,IAAI,CAAC,MAAM,EAAE,EAAE;YACjE,gBAAgB,KAAK,cAAc,eAAe,IAAI,CAAC,MAAM,EAAE,EAAE;;QAEzE;MACJ;;;;MAKO,eAAY;AACf,eAAO;MACX;;AAhdO,eAAA;MADN,UAAS;;;;;;AC/Dd,IA2Ba;AA3Bb;;;AAGA;AAwBM,IAAO,iCAAP,MAAqC;MAyBvC,YAAY,OAAY;AAhBjB,aAAA,6BAAiE,IAAI,WAAU;AAK/E,aAAA,sBAA+B;AAO9B,aAAA,yBAA0E,CAAA;AAE1E,aAAA,gBAAwB;AAG5B,aAAK,SAAS;AACd,aAAK,YAAW;MACpB;MAEQ,cAAW;AACf,aAAK,sBAAsB,KAAK,OAAO,kBAAkB,IAAI,MAAK;AAC9D,cAAI,CAAC,KAAK,qBAAqB;AAC3B,iBAAK,2BAA2B,gBAAgB;cAAE,MAAI;;YAA+B,CAAE;AACvF,iBAAK,sBAAsB;UAC/B;QACJ,CAAC;AAED,aAAK,wBAAwB,KAAK,OAAO,oBAAoB,IAAI,MAAK;AAClE,eAAK,2BAA2B,gBAAgB;YAAE,MAAI;;UAAiC,CAAE;QAC7F,CAAC;AACD,aAAK,+BAA+B,KAAK,OAAO,yBAAyB,IAAI,MAAK;AAC9E,gBAAM,YAAY,KAAK,OAAO,UAAS,EAAG,aAAY,IAAK;AAC3D,eAAK,2BAA2B,gBAAgB;YAC5C,MAAI;YACJ,SAAS;cACL,gBAAgB,KAAK;cACrB;;WAEP;AACD,eAAK,iBAAiB;QAC1B,CAAC;AAED,aAAK,sBAAsB,KAAK,OAAO,oBAAoB,IAAI,CAAC,gBAAe;AAC3E,eAAK,2BAA2B,gBAAgB,EAAE,MAAI,YAA+B,SAAS,YAAW,CAAE;QAC/G,GAAG,kBAAkB,WAAW;AAEhC,aAAK,4BAA4B,KAAK,OAAO,oCAAoC,IAAI,CAAC,SAAQ;AAK1F,gBAAM,YAAY,KAAK;AACvB,gBAAM,OAAO,KAAK;AAClB,gBAAM,gBAAgB,KAAK,uBAAuB,SAAS;AAC3D,cAAI,CAAC,iBAAiB,MAAM;AACxB,iBAAK,2BAA2B,gBAAgB,EAAE,MAAI,eAAkC,SAAS,EAAE,WAAW,KAAI,EAAE,CAAE;UAC1H,WAAW,iBAAiB,CAAC,MAAM;AAC/B,iBAAK,2BAA2B,gBAAgB,EAAE,MAAI,cAAiC,SAAS,EAAE,WAAW,MAAM,cAAa,EAAE,CAAE;UACxI,WAAW,iBAAiB,QAAQ,kBAAkB,MAAM;AACxD,iBAAK,2BAA2B,gBAAgB,EAAE,MAAI,cAAiC,SAAS,EAAE,WAAW,MAAM,eAAe,MAAM,KAAI,EAAE,CAAE;AAChJ,iBAAK,2BAA2B,gBAAgB,EAAE,MAAI,eAAkC,SAAS,EAAE,WAAW,MAAM,KAAK,cAAa,EAAE,CAAE;UAC9I;AACA,eAAK,uBAAuB,SAAS,IAAI;QAC7C,GAAG,kBAAkB,WAAW;MACpC;MAEO,UAAO;AAxGlB;AAyGQ,mBAAK,0BAAL,mBAA4B;AAC5B,mBAAK,wBAAL,mBAA0B;AAC1B,mBAAK,iCAAL,mBAAmC;AACnC,mBAAK,wBAAL,mBAA0B;AAC1B,mBAAK,8BAAL,mBAAgC;AAChC,aAAK,2BAA2B,MAAK;MACzC;;;;;;AC/GJ,IAiBkB,gBAqDL;AAtEb;;;AAIA;AAEA;AAOA;AAEA;AAEA,KAAA,SAAkBC,iBAAc;AAI5B,MAAAA,gBAAAA,gBAAA,SAAA,IAAA,CAAA,IAAA;AAIA,MAAAA,gBAAAA,gBAAA,SAAA,IAAA,CAAA,IAAA;IACJ,GATkB,mBAAA,iBAAc,CAAA,EAAA;AAqD1B,IAAO,YAAP,MAAgB;;;;MAoClB,IAAW,QAAK;AACZ,eAAO,KAAK;MAChB;;;;MAKA,IAAW,MAAM,OAAqB;AAClC,aAAK,SAAS;AACd,aAAK,yBAAyB,gBAAgB,KAAK;MACvD;;;;;MAMA,YAAmB,QAAwB;AAhDpC,aAAA,2BAAuD,IAAI,WAAU;AAErE,aAAA,eAAyE;UAC5E;YAAA;;UAAA,GAAiC,CAAA;UACjC;YAAA;;UAAA,GAAmC,CAAA;UACnC;YAAA;;UAAA,GAAwC,CAAA;UACxC;YAAA;;UAAA,GAA+B,CAAA;UAC/B;YAAA;;UAAA,GAAkC,CAAA;UAClC;YAAA;;UAAA,GAAgC,CAAA;UAChC;YAAA;;UAAA,GAAkC,CAAA;UAClC;YAAA;;UAAA,GAAkC,CAAA;UAClC;YAAA;;UAAA,GAAiC,CAAA;UACjC;YAAA;;UAAA,GAAuC,CAAA;UACvC;YAAA;;UAAA,GAAgC,CAAA;;AAO5B,aAAA,qBAAyC,CAAA;AAOzC,aAAA,SAAM;AAsBV,aAAK,SAAS,OAAO;AACrB,aAAK,yBAAyB,IAAI,+BAA+B,KAAK,MAAM;AAC5E,aAAK,eAAe,OAAO;AAE3B,aAAK,iBAAiB,KAAK,uBAAuB,2BAA2B,IAAI,CAAC,UAAS;AACvF,qBAAW,WAAW,KAAK,oBAAoB;AAC3C,kBAAM,QAAQ,KAAK,oBAAoB,MAAM,MAAM,OAAO;AAC1D,uBAAW,SAAS,OAAO;AAEvB,kBAAI,CAAC,MAAM,cAAc,SAAS,MAAM,OAAO,GAAG;AAC9C;cACJ;YACJ;UACJ;AAEA,kBAAQ,MAAM,MAAM;YAChB,KAAA;AACI,mBAAK,uBAAuB,sBAAsB;AAClD;YACJ,KAAA;AACI,yBAAW,WAAW,KAAK,oBAAoB;AAC3C,wBAAQ,cAAc,MAAM,OAAO;cACvC;AACA;YACJ,KAAA;AACI,mBAAK,QAAO;AACZ;UACR;QACJ,CAAC;MACL;;;;;MAMO,gBAAa;AAChB,cAAM,UAAU,IAAI,iBAAiB,EAAE,OAAO,KAAK,QAAQ,aAAa,KAAK,aAAY,CAAE;AAC3F,aAAK,mBAAmB,KAAK,OAAO;AACpC,eAAO;MACX;;;;;;MAOO,WAAW,OAAa;AAC3B,eAAO,KAAK,mBAAmB,KAAK;MACxC;;;;;;MAOO,cAAc,OAA0B;AAC3C,YAAI,MAAM,SAAI,iBAAuC,MAAM,SAAI,cAAoC;AAC/F,eAAK,OAAO,mCAAmC;QACnD;AAGA,YAAI,MAAM,SAAI,aAAmC;AAC7C,eAAK,aAAa,MAAM,IAAI,EAAE,KAAK,KAAK;QAC5C;AAEA,YAAI,KAAK,UAAK,GAA6B;AACvC,qBAAW,WAAW,KAAK,oBAAoB;AAC3C,kBAAM,mBAAmB,OAAO;UACpC;QACJ,OAAO;AACH,eAAK,yBAAyB,QAAQ,CAAC,UAAS;AAC5C,gBAAI,UAAK,GAA6B;AAClC,yBAAW,WAAW,KAAK,oBAAoB;AAC3C,sBAAM,mBAAmB,OAAO;cACpC;YACJ;UACJ,CAAC;QACL;MACJ;;;;MAKO,QAAK;AACR,YAAI,KAAK,UAAK,GAA6B;AACvC;QACJ;AACA,YAAI,KAAK,mBAAmB,WAAW,GAAG;AACtC,eAAK,cAAa;QACtB;AACA,aAAK,yBAAyB,IAAI,CAAC,UAAS;AACxC,cAAI,UAAK,GAA6B;AAClC,iBAAK,oBAAmB;AAExB,gBAAI,KAAK,OAAO,QAAQ,IAAI,GAAG;AAC3B,mBAAK,uBAAuB,2BAA2B,gBAAgB;gBAAE,MAAI;;cAA+B,CAAE;YAClH;UACJ;QACJ,CAAC;AACD,aAAK,QAAK;MACd;MAEQ,sBAAmB;AACvB,mBAAW,WAAW,KAAK,oBAAoB;AAC3C,qBAAW,QAAQ,KAAK,cAAc;AAClC,kBAAM,QAAQ,KAAK,oBAAoB,MAA4B,OAAO;AAC1E,uBAAW,SAAS,OAAO;AACvB,oBAAM,mBAAmB,OAAO;YACpC;UACJ;QACJ;MACJ;MAEQ,oBAAoB,MAA0B,SAAyB;AAC3E,cAAM,QAAQ,KAAK,aAAa,IAAI,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,eAAe,EAAE,YAAY;AAEpF,YAAI,SAAI,YAAkC;AACtC,gBAAM,gBAAgB,CAAA;AACtB,qBAAW,UAAU,OAAO;AAExB,kBAAM,QAAS,OAAuC,MAAM,SAAS,OAAO;AAC5E,gBAAI,IAAI;AACR,mBAAO,IAAI,MAAM,QAAQ,KAAK;AAC1B,oBAAM,SAAS,MAAM,CAAC;AACtB,oBAAM,QAAS,OAAuC,MAAM,SAAS,OAAO;AAC5E,kBAAI,SAAS,SAAS,iBAAiB,OAAO,KAAK,GAAG;AAClD;cACJ;YACJ;AACA,0BAAc,OAAO,GAAG,GAAG,MAAM;UACrC;AACA,iBAAO;QACX;AACA,eAAO;MACX;;;;MAKO,UAAO;AAtQlB;AAuQQ,YAAI,KAAK,UAAK,GAA6B;AACvC;QACJ;AACA,aAAK,QAAK;AACV,mBAAW,WAAW,KAAK,oBAAoB;AAC3C,kBAAQ,oBAAmB;QAC/B;AACA,aAAK,mBAAmB,SAAS;AACjC,mBAAW,QAAQ,KAAK,cAAc;AAClC,eAAK,aAAa,IAA0B,EAAE,SAAS;QAC3D;AACA,mBAAK,mBAAL,mBAAqB;AACrB,aAAK,uBAAuB,QAAO;MACvC;;;;;MAMO,eAAe,SAAwC;AAC1D,cAAM,YAA8B,CAAA;AACpC,cAAM,sBAAsB,oBAAI,IAAG;AACnC,mBAAW,QAAQ,KAAK,cAAc;AAClC,qBAAW,SAAS,KAAK,aAAa,IAA0B,GAAG;AAC/D,sBAAU,KAAK,KAAK;AACpB,gCAAoB,IAAI,MAAM,QAAQ;UAC1C;QACJ;AAEA,eAAO,UAAU,SAAS,GAAG;AACzB,gBAAM,QAAQ,UAAU,IAAG;AAC3B,kBAAQ,KAAK;AAEb,qBAAW,UAAU,MAAM,YAAY;AACnC,uBAAW,cAAc,OAAO,iBAAiB;AAC7C,kBAAI,CAAC,oBAAoB,IAAI,WAAW,YAAY,QAAQ,GAAG;AAC3D,0BAAU,KAAK,WAAW,WAAW;AACrC,oCAAoB,IAAI,WAAW,YAAY,QAAQ;cAC3D;YACJ;UACJ;AACA,cAAI,iBAAiB,yBAAyB;AAC1C,uBAAW,aAAa,MAAM,eAAe;AACzC,yBAAW,cAAc,UAAU,iBAAiB;AAChD,oBAAI,CAAC,oBAAoB,IAAI,WAAW,YAAY,QAAQ,GAAG;AAC3D,4BAAU,KAAK,WAAW,WAAW;AACrC,sCAAoB,IAAI,WAAW,YAAY,QAAQ;gBAC3D;cACJ;YACJ;UACJ;QACJ;MACJ;;;;;;MAOO,UAAU,sBAA2B,CAAA,GAAI,wBAAoF;AAChI,4BAAoB,YAAY,CAAA;AAChC,aAAK,eAAe,CAAC,UAAS;AAC1B,gBAAM,kBAAuB,CAAA;AAC7B,gBAAM,UAAU,eAAe;AAC/B,8BAAoB,UAAU,KAAK,eAAe;QACtD,CAAC;AACD,4BAAoB,oBAAoB,CAAA;AACxC,mBAAW,WAAW,KAAK,oBAAoB;AAC3C,gBAAM,oBAAyB,CAAA;AAC/B,kBAAQ,UAAU,mBAAmB,sBAAsB;AAC3D,8BAAoB,kBAAkB,KAAK,iBAAiB;QAChE;MACJ;;;;;;AC/UJ,IA4Ca;AA5Cb;;;AAEA;AAIA;AAsCM,IAAO,uBAAP,MAAO,sBAAoB;MAmC7B,YAIW,QAA0C;AAA1C,aAAA,SAAA;AAjBJ,aAAA,8BAAuC;AAE7B,aAAA,cAA2B,CAAA;AAEpC,aAAA,mBAAiD,oBAAI,IAAG;AAExD,aAAA,yBAA8C,oBAAI,IAAG;AAIrD,aAAA,sBAAsE,CAAA;AACtE,aAAA,iBAAyB;AAS7B,aAAK,mBAAmB,KAAK,OAAO,MAAM,oBAAoB,IAAI,MAAK;AACnE,eAAK,QAAO;QAChB,CAAC;AAED,aAAK,0BAA0B,KAAK,OAAO,MAAM,yBAAyB,IAAI,MAAK;AAE/E,eAAK,uBAAuB,MAAK;AAEjC,gBAAM,qBAAqB,KAAK,oBAAoB,MAAM,CAAC;AAC3D,cAAI,mBAAmB,QAAQ;AAE3B,+BAAmB,QAAQ,CAAC,UAAS;AACjC,mBAAK,kBAAkB,MAAM,IAAI,MAAM,MAAM,KAAK;AAElD,oBAAM,QAAQ,KAAK,oBAAoB,UAAU,CAAC,MAAM,EAAE,aAAa,MAAM,QAAQ;AACrF,kBAAI,UAAU,IAAI;AACd,qBAAK,oBAAoB,OAAO,OAAO,CAAC;cAC5C;YACJ,CAAC;UACL;QACJ,CAAC;AAGD,cAAM,eAAe,sBAAqB,kBAAkB,IAAI,KAAK,OAAO,KAAK,KAAK,CAAA;AACtF,qBAAa,KAAK,IAAI;MAC1B;;;;;MAMO,cAAW;AACd,cAAM,QAAQ,IAAI,UAAU,EAAE,OAAO,KAAK,OAAO,OAAO,aAAa,KAAI,CAAE;AAC3E,aAAK,YAAY,KAAK,KAAK;AAC3B,eAAO;MACX;;;;;MAMO,YAAY,OAAgB;AAC/B,cAAM,QAAQ,KAAK,YAAY,QAAQ,KAAK;AAC5C,YAAI,UAAU,IAAI;AACd,gBAAM,QAAO;AACb,eAAK,YAAY,OAAO,OAAO,CAAC;QACpC;MACJ;;;;MAKO,QAAK;AACR,aAAK,YAAY,QAAQ,CAAC,UAAU,MAAM,MAAK,CAAE;MACrD;;;;MAKO,UAAO;AAjJlB;AAkJQ,aAAK,YAAY,QAAQ,CAAC,UAAU,MAAM,QAAO,CAAE;AACnD,aAAK,YAAY,SAAS;AAC1B,mBAAK,qBAAL,mBAAuB;AACvB,mBAAK,4BAAL,mBAA8B;AAG9B,cAAM,eAAe,sBAAqB,kBAAkB,IAAI,KAAK,OAAO,KAAK,KAAK,CAAA;AACtF,cAAM,QAAQ,aAAa,QAAQ,IAAI;AACvC,YAAI,UAAU,IAAI;AACd,uBAAa,OAAO,OAAO,CAAC;QAChC;MACJ;;;;;;MAOO,UAAU,qBAA0B,wBAAoF;AAC3H,4BAAoB,cAAc,CAAA;AAClC,aAAK,YAAY,QAAQ,CAAC,UAAS;AAC/B,gBAAM,kBAAkB,CAAA;AACxB,gBAAM,UAAU,iBAAiB,sBAAsB;AACvD,8BAAoB,YAAY,KAAK,eAAe;QACxD,CAAC;AACD,4BAAoB,8BAA8B,KAAK;MAC3D;;;;MAKA,IAAW,aAAU;AACjB,eAAO,KAAK;MAChB;;;;;;MAOO,yBAAyB,IAAU;AACtC,YAAI,aAAa,KAAK,iBAAiB,IAAI,EAAE;AAC7C,YAAI,CAAC,YAAY;AAEb,uBAAa,IAAI;;UAAmC;AACpD,eAAK,iBAAiB,IAAI,IAAI,UAAU;QAC5C;AACA,eAAO;MACX;;;;;;;MAQO,kBAAkB,IAAY,MAAW,QAAiB,CAAC,KAAK,6BAA2B;AAC9F,YAAI,OAAO;AACP,eAAK,oBAAoB,KAAK,EAAE,IAAI,MAAM,UAAU,KAAK,iBAAgB,CAAE;AAC3E;QACJ;AAEA,YAAI,KAAK,uBAAuB,IAAI,EAAE,GAAG;AACrC,gBAAM,QAAQ,KAAK,uBAAuB,IAAI,EAAE;AAChD,eAAK,uBAAuB,IAAI,IAAI,QAAQ,CAAC;AAC7C,cAAI,SAAS,sBAAqB,+BAA+B;AAC7D,sBAAU,sBAAqB,iCAAiC,OAAO,KAAK,uDAAuD,EAAE,IAAI;AACzI;UACJ;QACJ,OAAO;AACH,eAAK,uBAAuB,IAAI,IAAI,CAAC;QACzC;AACA,cAAM,aAAa,KAAK,iBAAiB,IAAI,EAAE;AAC/C,YAAI,YAAY;AACZ,qBAAW,gBAAgB,IAAI;QACnC;MACJ;;AA5Kc,yBAAA,mBAA2B;AAK3B,yBAAA,gCAAwC;AAK/B,yBAAA,oBAAwD,oBAAI,IAAG;;;",
  "names": ["FlowGraphAction", "FlowGraphState"]
}
