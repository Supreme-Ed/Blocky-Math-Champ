// src/server/blockMappingLogger.ts
// Logs block mappings to a file

import fs from 'fs';
import path from 'path';

// Collection of all mappings to log to BLOCK_MAPPING.md
// Format: { 'type:source:sourceFile': 'target:sourceFile' }
const mappingLog: Record<string, string> = {};

/**
 * Log a block mapping to the collection
 * @param source - The source block (Minecraft block ID or name)
 * @param target - The target block (game block type)
 * @param type - The type of mapping ('id' or 'name')
 * @param sourceFile - The source NBT file (optional)
 */
export function logMapping(source: string, target: string, type: 'id' | 'name', sourceFile: string = ''): void {
  // Create a key that includes the source file
  const key = `${type}:${source}:${sourceFile}`;
  // Store the target and source file
  mappingLog[key] = `${target}:${sourceFile}`;
}

/**
 * Save all mappings to BLOCK_MAPPING.md
 */
export function saveMappingLog(): void {
  try {
    let content = '# Minecraft Block Mapping Log\n\n';
    content += 'This file is automatically generated each time the game runs.\n\n';

    // Add timestamp
    content += `Generated: ${new Date().toISOString()}\n\n`;

    // Block ID mappings
    content += '## Block ID Mappings\n\n';
    content += '| Minecraft Block ID | Game Block Type | Source NBT File |\n';
    content += '|-------------------|----------------|----------------|\n';

    Object.keys(mappingLog)
      .filter(key => key.startsWith('id:'))
      .sort()
      .forEach(key => {
        // Extract the Minecraft ID and source file from the key
        const parts = key.split(':');
        const minecraftId = parts[1];

        // Extract the target and source file from the value
        const valueParts = mappingLog[key].split(':');
        const target = valueParts[0];
        const sourceFile = valueParts[1] || 'unknown';

        content += `| ${minecraftId} | ${target} | ${sourceFile} |\n`;
      });

    // Block name mappings
    content += '\n## Block Name Mappings\n\n';
    content += '| Minecraft Block Name | Game Block Type | Source NBT File |\n';
    content += '|---------------------|----------------|----------------|\n';

    Object.keys(mappingLog)
      .filter(key => key.startsWith('name:'))
      .sort()
      .forEach(key => {
        // Extract the Minecraft name and source file from the key
        const parts = key.split(':');
        const minecraftName = parts[1];

        // Extract the target and source file from the value
        const valueParts = mappingLog[key].split(':');
        const target = valueParts[0];
        const sourceFile = valueParts[1] || 'unknown';

        content += `| ${minecraftName} | ${target} | ${sourceFile} |\n`;
      });

    // Write to file
    fs.writeFileSync(path.join(process.cwd(), 'BLOCK_MAPPING.md'), content);
    console.log('Block mapping log saved to BLOCK_MAPPING.md');
  } catch (error) {
    console.error('Error saving mapping log:', error);
  }
}

// Register the save function to run when the process exits
process.on('exit', saveMappingLog);

// Also save on SIGINT (Ctrl+C)
process.on('SIGINT', () => {
  saveMappingLog();
  process.exit();
});

// Export a function to add a mapping directly
export function addMapping(source: string, target: string, type: 'id' | 'name', sourceFile: string = ''): void {
  logMapping(source, target, type, sourceFile);
}

// Export a function to add multiple mappings at once
export function addBulkMappings(mappings: Record<string, string>): void {
  Object.entries(mappings).forEach(([key, value]) => {
    // The key format is now 'type:source:sourceFile'
    const keyParts = key.split(':');
    const type = keyParts[0];
    const source = keyParts[1];
    const sourceFile = keyParts.length > 2 ? keyParts[2] : '';

    // The value format is now 'target:sourceFile'
    const valueParts = value.split(':');
    const target = valueParts[0];
    const valueSourceFile = valueParts.length > 1 ? valueParts[1] : '';

    // Use the source file from the key or value, preferring the key's version
    const finalSourceFile = sourceFile || valueSourceFile;

    if (type === 'id' || type === 'name') {
      logMapping(source, target, type as 'id' | 'name', finalSourceFile);
    }
  });
}
